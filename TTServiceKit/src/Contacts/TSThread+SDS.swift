//
//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
//

import Foundation
import GRDB
import SignalCoreKit

// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
// Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// MARK: - Record

public struct ThreadRecord: SDSRecord {
    public weak var delegate: SDSRecordDelegate?

    public var tableMetadata: SDSTableMetadata {
        TSThreadSerializer.table
    }

    public static var databaseTableName: String {
        TSThreadSerializer.table.tableName
    }

    public var id: Int64?

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    public let recordType: SDSRecordType
    public let uniqueId: String

    // Properties
    public let archivalDate: Double?
    public let conversationEntity: Data?
    public let creationDate: Double
    public let draftQuoteMessageId: String?
    public let groupModel: Data?
    public let hasDismissedOffers: Bool?
    public let hasEverHadMessage: Bool
    public let lastMessageDate: Double?
    public let lastestMsg: Data?
    public let messageDraft: String?
    public let mutedUntilDate: Double?
    public let plainTextEnable: Bool
    public let readPositionEntity: Data?
    public let removedFromConversation: Bool
    public let stickCallingDate: Double?
    public let stickDate: Double?
    public let translateSettingType: UInt32?
    public let unreadFlag: UInt32
    public let unreadState: UInt
    public let unreadTimeStimeStamp: UInt64
    public let isArchived: Bool
    public let unreadMessageCount: UInt
    public let mentionedAllMsg: Data?
    public let mentionedMeMsg: Data?
    public let shouldBeVisible: Bool
    public let threadConfig: Data?
    public let mentionsDraft: Data?
    public let friendContactVersion: Int?
    public let receivedFriendReq: Bool?
    public let expiresInSeconds: UInt64
    public let messageClearAnchor: UInt64

    public enum CodingKeys: String, CodingKey, ColumnExpression, CaseIterable {
        case id
        case recordType
        case uniqueId
        case archivalDate
        case conversationEntity
        case creationDate
        case draftQuoteMessageId
        case groupModel
        case hasDismissedOffers
        case hasEverHadMessage
        case lastMessageDate
        case lastestMsg
        case messageDraft
        case mutedUntilDate
        case plainTextEnable
        case readPositionEntity
        case removedFromConversation
        case stickCallingDate
        case stickDate
        case translateSettingType
        case unreadFlag
        case unreadState
        case unreadTimeStimeStamp
        case isArchived
        case unreadMessageCount
        case mentionedAllMsg
        case mentionedMeMsg
        case shouldBeVisible
        case threadConfig
        case mentionsDraft
        case friendContactVersion
        case receivedFriendReq
        case expiresInSeconds
        case messageClearAnchor
    }

    public static func columnName(_ column: ThreadRecord.CodingKeys, fullyQualified: Bool = false) -> String {
        fullyQualified ? "\(databaseTableName).\(column.rawValue)" : column.rawValue
    }

    public func didInsert(with rowID: Int64, for column: String?) {
        guard let delegate = delegate else {
            owsFailDebug("Missing delegate.")
            return
        }
        delegate.updateRowId(rowID)
    }
}

// MARK: - Row Initializer

public extension ThreadRecord {
    static var databaseSelection: [SQLSelectable] {
        CodingKeys.allCases
    }

    init(row: Row) {
        id = row[0]
        recordType = row[1]
        uniqueId = row[2]
        archivalDate = row[3]
        conversationEntity = row[4]
        creationDate = row[5]
        draftQuoteMessageId = row[6]
        groupModel = row[7]
        hasDismissedOffers = row[8]
        hasEverHadMessage = row[9]
        lastMessageDate = row[10]
        lastestMsg = row[11]
        messageDraft = row[12]
        mutedUntilDate = row[13]
        plainTextEnable = row[14]
        readPositionEntity = row[15]
        removedFromConversation = row[16]
        stickCallingDate = row[17]
        stickDate = row[18]
        unreadFlag = row[19]
        unreadState = row[20]
        unreadTimeStimeStamp = row[21]
        isArchived = row[22]
        unreadMessageCount = row[23]
        mentionedAllMsg = row[24]
        mentionedMeMsg = row[25]
        shouldBeVisible = row[26]
        threadConfig = row[27]
        mentionsDraft = row[28]
        friendContactVersion = row[29]
        receivedFriendReq = row[30]
        translateSettingType = row[31]
        expiresInSeconds = row[32]
        messageClearAnchor = row[33]
    }
}

// MARK: - StringInterpolation

public extension String.StringInterpolation {
    mutating func appendInterpolation(threadColumn column: ThreadRecord.CodingKeys) {
        appendLiteral(ThreadRecord.columnName(column))
    }
    mutating func appendInterpolation(threadColumnFullyQualified column: ThreadRecord.CodingKeys) {
        appendLiteral(ThreadRecord.columnName(column, fullyQualified: true))
    }
}

// MARK: - Deserialization

// TODO: Rework metadata to not include, for example, columns, column indices.
extension TSThread {
    // This method defines how to deserialize a model, given a
    // database row.  The recordType column is used to determine
    // the corresponding model class.
    class func fromRecord(_ record: ThreadRecord) throws -> TSThread {

        guard let recordId = record.id else {
            throw SDSError.invalidValue
        }

        switch record.recordType {
        case .dTVirtualThread:

            let uniqueId: String = record.uniqueId
            let archivalDateInterval: Double? = record.archivalDate
            let archivalDate: Date? = SDSDeserialization.optionalDoubleAsDate(archivalDateInterval, name: "archivalDate")
            let conversationEntitySerialized: Data? = record.conversationEntity
            let conversationEntity: DTConversationEntity? = try SDSDeserialization.optionalUnarchive(conversationEntitySerialized, name: "conversationEntity")
            let creationDateInterval: Double = record.creationDate
            let creationDate: Date = SDSDeserialization.requiredDoubleAsDate(creationDateInterval, name: "creationDate")
            let draftQuoteMessageId: String? = record.draftQuoteMessageId
            let expiresInSeconds: UInt64 = record.expiresInSeconds
            let hasEverHadMessage: Bool = record.hasEverHadMessage
            let isArchived: Bool = record.isArchived
            let lastMessageDateInterval: Double? = record.lastMessageDate
            let lastMessageDate: Date? = SDSDeserialization.optionalDoubleAsDate(lastMessageDateInterval, name: "lastMessageDate")
            let lastestMsgSerialized: Data? = record.lastestMsg
            let lastestMsg: TSMessage? = try SDSDeserialization.optionalUnarchive(lastestMsgSerialized, name: "lastestMsg")
            let mentionedAllMsgSerialized: Data? = record.mentionedAllMsg
            let mentionedAllMsg: DTMentionedMsgInfo? = try SDSDeserialization.optionalUnarchive(mentionedAllMsgSerialized, name: "mentionedAllMsg")
            let mentionedMeMsgSerialized: Data? = record.mentionedMeMsg
            let mentionedMeMsg: DTMentionedMsgInfo? = try SDSDeserialization.optionalUnarchive(mentionedMeMsgSerialized, name: "mentionedMeMsg")
            let mentionsDraftSerialized: Data? = record.mentionsDraft
            let mentionsDraft: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsDraftSerialized, name: "mentionsDraft")
            let messageClearAnchor: UInt64 = record.messageClearAnchor
            let messageDraft: String? = record.messageDraft
            let mutedUntilDateInterval: Double? = record.mutedUntilDate
            let mutedUntilDate: Date? = SDSDeserialization.optionalDoubleAsDate(mutedUntilDateInterval, name: "mutedUntilDate")
            let plainTextEnable: Bool = record.plainTextEnable
            let readPositionEntitySerialized: Data? = record.readPositionEntity
            let readPositionEntity: DTReadPositionEntity? = try SDSDeserialization.optionalUnarchive(readPositionEntitySerialized, name: "readPositionEntity")
            let removedFromConversation: Bool = record.removedFromConversation
            let shouldBeVisible: Bool = record.shouldBeVisible
            let stickCallingDateInterval: Double? = record.stickCallingDate
            let stickCallingDate: Date? = SDSDeserialization.optionalDoubleAsDate(stickCallingDateInterval, name: "stickCallingDate")
            let stickDateInterval: Double? = record.stickDate
            let stickDate: Date? = SDSDeserialization.optionalDoubleAsDate(stickDateInterval, name: "stickDate")
            let threadConfigSerialized: Data? = record.threadConfig
            let threadConfig: DTThreadConfigEntity? = try SDSDeserialization.optionalUnarchive(threadConfigSerialized, name: "threadConfig")
            let translateSettingType: NSNumber? = SDSDeserialization.optionalNumericAsNSNumber(record.translateSettingType, name: "translateSettingType", conversion: { NSNumber(value: $0) })
            let unreadFlag: UInt32 = record.unreadFlag
            let unreadMessageCount: UInt = record.unreadMessageCount
            let unreadState: UInt = record.unreadState
            let unreadTimeStimeStamp: UInt64 = record.unreadTimeStimeStamp

            return DTVirtualThread(grdbId: recordId,
                                   uniqueId: uniqueId,
                                   archivalDate: archivalDate,
                                   conversationEntity: conversationEntity,
                                   creationDate: creationDate,
                                   draftQuoteMessageId: draftQuoteMessageId,
                                   expiresInSeconds: expiresInSeconds,
                                   hasEverHadMessage: hasEverHadMessage,
                                   isArchived: isArchived,
                                   lastMessageDate: lastMessageDate,
                                   lastestMsg: lastestMsg,
                                   mentionedAllMsg: mentionedAllMsg,
                                   mentionedMeMsg: mentionedMeMsg,
                                   mentionsDraft: mentionsDraft,
                                   messageClearAnchor: messageClearAnchor,
                                   messageDraft: messageDraft,
                                   mutedUntilDate: mutedUntilDate,
                                   plainTextEnable: plainTextEnable,
                                   readPositionEntity: readPositionEntity,
                                   removedFromConversation: removedFromConversation,
                                   shouldBeVisible: shouldBeVisible,
                                   stickCallingDate: stickCallingDate,
                                   stickDate: stickDate,
                                   threadConfig: threadConfig,
                                   translateSettingType: translateSettingType,
                                   unreadFlag: unreadFlag,
                                   unreadMessageCount: unreadMessageCount,
                                   unreadState: unreadState,
                                   unreadTimeStimeStamp: unreadTimeStimeStamp)

        case .contactThread:

            let uniqueId: String = record.uniqueId
            let archivalDateInterval: Double? = record.archivalDate
            let archivalDate: Date? = SDSDeserialization.optionalDoubleAsDate(archivalDateInterval, name: "archivalDate")
            let conversationEntitySerialized: Data? = record.conversationEntity
            let conversationEntity: DTConversationEntity? = try SDSDeserialization.optionalUnarchive(conversationEntitySerialized, name: "conversationEntity")
            let creationDateInterval: Double = record.creationDate
            let creationDate: Date = SDSDeserialization.requiredDoubleAsDate(creationDateInterval, name: "creationDate")
            let draftQuoteMessageId: String? = record.draftQuoteMessageId
            let expiresInSeconds: UInt64 = record.expiresInSeconds
            let hasEverHadMessage: Bool = record.hasEverHadMessage
            let isArchived: Bool = record.isArchived
            let lastMessageDateInterval: Double? = record.lastMessageDate
            let lastMessageDate: Date? = SDSDeserialization.optionalDoubleAsDate(lastMessageDateInterval, name: "lastMessageDate")
            let lastestMsgSerialized: Data? = record.lastestMsg
            let lastestMsg: TSMessage? = try SDSDeserialization.optionalUnarchive(lastestMsgSerialized, name: "lastestMsg")
            let mentionedAllMsgSerialized: Data? = record.mentionedAllMsg
            let mentionedAllMsg: DTMentionedMsgInfo? = try SDSDeserialization.optionalUnarchive(mentionedAllMsgSerialized, name: "mentionedAllMsg")
            let mentionedMeMsgSerialized: Data? = record.mentionedMeMsg
            let mentionedMeMsg: DTMentionedMsgInfo? = try SDSDeserialization.optionalUnarchive(mentionedMeMsgSerialized, name: "mentionedMeMsg")
            let mentionsDraftSerialized: Data? = record.mentionsDraft
            let mentionsDraft: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsDraftSerialized, name: "mentionsDraft")
            let messageClearAnchor: UInt64 = record.messageClearAnchor
            let messageDraft: String? = record.messageDraft
            let mutedUntilDateInterval: Double? = record.mutedUntilDate
            let mutedUntilDate: Date? = SDSDeserialization.optionalDoubleAsDate(mutedUntilDateInterval, name: "mutedUntilDate")
            let plainTextEnable: Bool = record.plainTextEnable
            let readPositionEntitySerialized: Data? = record.readPositionEntity
            let readPositionEntity: DTReadPositionEntity? = try SDSDeserialization.optionalUnarchive(readPositionEntitySerialized, name: "readPositionEntity")
            let removedFromConversation: Bool = record.removedFromConversation
            let shouldBeVisible: Bool = record.shouldBeVisible
            let stickCallingDateInterval: Double? = record.stickCallingDate
            let stickCallingDate: Date? = SDSDeserialization.optionalDoubleAsDate(stickCallingDateInterval, name: "stickCallingDate")
            let stickDateInterval: Double? = record.stickDate
            let stickDate: Date? = SDSDeserialization.optionalDoubleAsDate(stickDateInterval, name: "stickDate")
            let threadConfigSerialized: Data? = record.threadConfig
            let threadConfig: DTThreadConfigEntity? = try SDSDeserialization.optionalUnarchive(threadConfigSerialized, name: "threadConfig")
            let translateSettingType: NSNumber? = SDSDeserialization.optionalNumericAsNSNumber(record.translateSettingType, name: "translateSettingType", conversion: { NSNumber(value: $0) })
            let unreadFlag: UInt32 = record.unreadFlag
            let unreadMessageCount: UInt = record.unreadMessageCount
            let unreadState: UInt = record.unreadState
            let unreadTimeStimeStamp: UInt64 = record.unreadTimeStimeStamp
            let friendContactVersion: Int = try SDSDeserialization.required(record.friendContactVersion, name: "friendContactVersion")
            let hasDismissedOffers: Bool = try SDSDeserialization.required(record.hasDismissedOffers, name: "hasDismissedOffers")
            let receivedFriendReq: Bool = try SDSDeserialization.required(record.receivedFriendReq, name: "receivedFriendReq")

            return TSContactThread(grdbId: recordId,
                                   uniqueId: uniqueId,
                                   archivalDate: archivalDate,
                                   conversationEntity: conversationEntity,
                                   creationDate: creationDate,
                                   draftQuoteMessageId: draftQuoteMessageId,
                                   expiresInSeconds: expiresInSeconds,
                                   hasEverHadMessage: hasEverHadMessage,
                                   isArchived: isArchived,
                                   lastMessageDate: lastMessageDate,
                                   lastestMsg: lastestMsg,
                                   mentionedAllMsg: mentionedAllMsg,
                                   mentionedMeMsg: mentionedMeMsg,
                                   mentionsDraft: mentionsDraft,
                                   messageClearAnchor: messageClearAnchor,
                                   messageDraft: messageDraft,
                                   mutedUntilDate: mutedUntilDate,
                                   plainTextEnable: plainTextEnable,
                                   readPositionEntity: readPositionEntity,
                                   removedFromConversation: removedFromConversation,
                                   shouldBeVisible: shouldBeVisible,
                                   stickCallingDate: stickCallingDate,
                                   stickDate: stickDate,
                                   threadConfig: threadConfig,
                                   translateSettingType: translateSettingType,
                                   unreadFlag: unreadFlag,
                                   unreadMessageCount: unreadMessageCount,
                                   unreadState: unreadState,
                                   unreadTimeStimeStamp: unreadTimeStimeStamp,
                                   friendContactVersion: friendContactVersion,
                                   hasDismissedOffers: hasDismissedOffers,
                                   receivedFriendReq: receivedFriendReq)

        case .groupThread:

            let uniqueId: String = record.uniqueId
            let archivalDateInterval: Double? = record.archivalDate
            let archivalDate: Date? = SDSDeserialization.optionalDoubleAsDate(archivalDateInterval, name: "archivalDate")
            let conversationEntitySerialized: Data? = record.conversationEntity
            let conversationEntity: DTConversationEntity? = try SDSDeserialization.optionalUnarchive(conversationEntitySerialized, name: "conversationEntity")
            let creationDateInterval: Double = record.creationDate
            let creationDate: Date = SDSDeserialization.requiredDoubleAsDate(creationDateInterval, name: "creationDate")
            let draftQuoteMessageId: String? = record.draftQuoteMessageId
            let expiresInSeconds: UInt64 = record.expiresInSeconds
            let hasEverHadMessage: Bool = record.hasEverHadMessage
            let isArchived: Bool = record.isArchived
            let lastMessageDateInterval: Double? = record.lastMessageDate
            let lastMessageDate: Date? = SDSDeserialization.optionalDoubleAsDate(lastMessageDateInterval, name: "lastMessageDate")
            let lastestMsgSerialized: Data? = record.lastestMsg
            let lastestMsg: TSMessage? = try SDSDeserialization.optionalUnarchive(lastestMsgSerialized, name: "lastestMsg")
            let mentionedAllMsgSerialized: Data? = record.mentionedAllMsg
            let mentionedAllMsg: DTMentionedMsgInfo? = try SDSDeserialization.optionalUnarchive(mentionedAllMsgSerialized, name: "mentionedAllMsg")
            let mentionedMeMsgSerialized: Data? = record.mentionedMeMsg
            let mentionedMeMsg: DTMentionedMsgInfo? = try SDSDeserialization.optionalUnarchive(mentionedMeMsgSerialized, name: "mentionedMeMsg")
            let mentionsDraftSerialized: Data? = record.mentionsDraft
            let mentionsDraft: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsDraftSerialized, name: "mentionsDraft")
            let messageClearAnchor: UInt64 = record.messageClearAnchor
            let messageDraft: String? = record.messageDraft
            let mutedUntilDateInterval: Double? = record.mutedUntilDate
            let mutedUntilDate: Date? = SDSDeserialization.optionalDoubleAsDate(mutedUntilDateInterval, name: "mutedUntilDate")
            let plainTextEnable: Bool = record.plainTextEnable
            let readPositionEntitySerialized: Data? = record.readPositionEntity
            let readPositionEntity: DTReadPositionEntity? = try SDSDeserialization.optionalUnarchive(readPositionEntitySerialized, name: "readPositionEntity")
            let removedFromConversation: Bool = record.removedFromConversation
            let shouldBeVisible: Bool = record.shouldBeVisible
            let stickCallingDateInterval: Double? = record.stickCallingDate
            let stickCallingDate: Date? = SDSDeserialization.optionalDoubleAsDate(stickCallingDateInterval, name: "stickCallingDate")
            let stickDateInterval: Double? = record.stickDate
            let stickDate: Date? = SDSDeserialization.optionalDoubleAsDate(stickDateInterval, name: "stickDate")
            let threadConfigSerialized: Data? = record.threadConfig
            let threadConfig: DTThreadConfigEntity? = try SDSDeserialization.optionalUnarchive(threadConfigSerialized, name: "threadConfig")
            let translateSettingType: NSNumber? = SDSDeserialization.optionalNumericAsNSNumber(record.translateSettingType, name: "translateSettingType", conversion: { NSNumber(value: $0) })
            let unreadFlag: UInt32 = record.unreadFlag
            let unreadMessageCount: UInt = record.unreadMessageCount
            let unreadState: UInt = record.unreadState
            let unreadTimeStimeStamp: UInt64 = record.unreadTimeStimeStamp
            let groupModelSerialized: Data? = record.groupModel
            let groupModel: TSGroupModel = try SDSDeserialization.unarchive(groupModelSerialized, name: "groupModel")

            return TSGroupThread(grdbId: recordId,
                                 uniqueId: uniqueId,
                                 archivalDate: archivalDate,
                                 conversationEntity: conversationEntity,
                                 creationDate: creationDate,
                                 draftQuoteMessageId: draftQuoteMessageId,
                                 expiresInSeconds: expiresInSeconds,
                                 hasEverHadMessage: hasEverHadMessage,
                                 isArchived: isArchived,
                                 lastMessageDate: lastMessageDate,
                                 lastestMsg: lastestMsg,
                                 mentionedAllMsg: mentionedAllMsg,
                                 mentionedMeMsg: mentionedMeMsg,
                                 mentionsDraft: mentionsDraft,
                                 messageClearAnchor: messageClearAnchor,
                                 messageDraft: messageDraft,
                                 mutedUntilDate: mutedUntilDate,
                                 plainTextEnable: plainTextEnable,
                                 readPositionEntity: readPositionEntity,
                                 removedFromConversation: removedFromConversation,
                                 shouldBeVisible: shouldBeVisible,
                                 stickCallingDate: stickCallingDate,
                                 stickDate: stickDate,
                                 threadConfig: threadConfig,
                                 translateSettingType: translateSettingType,
                                 unreadFlag: unreadFlag,
                                 unreadMessageCount: unreadMessageCount,
                                 unreadState: unreadState,
                                 unreadTimeStimeStamp: unreadTimeStimeStamp,
                                 groupModel: groupModel)

        case .thread:

            let uniqueId: String = record.uniqueId
            let archivalDateInterval: Double? = record.archivalDate
            let archivalDate: Date? = SDSDeserialization.optionalDoubleAsDate(archivalDateInterval, name: "archivalDate")
            let conversationEntitySerialized: Data? = record.conversationEntity
            let conversationEntity: DTConversationEntity? = try SDSDeserialization.optionalUnarchive(conversationEntitySerialized, name: "conversationEntity")
            let creationDateInterval: Double = record.creationDate
            let creationDate: Date = SDSDeserialization.requiredDoubleAsDate(creationDateInterval, name: "creationDate")
            let draftQuoteMessageId: String? = record.draftQuoteMessageId
            let expiresInSeconds: UInt64 = record.expiresInSeconds
            let hasEverHadMessage: Bool = record.hasEverHadMessage
            let isArchived: Bool = record.isArchived
            let lastMessageDateInterval: Double? = record.lastMessageDate
            let lastMessageDate: Date? = SDSDeserialization.optionalDoubleAsDate(lastMessageDateInterval, name: "lastMessageDate")
            let lastestMsgSerialized: Data? = record.lastestMsg
            let lastestMsg: TSMessage? = try SDSDeserialization.optionalUnarchive(lastestMsgSerialized, name: "lastestMsg")
            let mentionedAllMsgSerialized: Data? = record.mentionedAllMsg
            let mentionedAllMsg: DTMentionedMsgInfo? = try SDSDeserialization.optionalUnarchive(mentionedAllMsgSerialized, name: "mentionedAllMsg")
            let mentionedMeMsgSerialized: Data? = record.mentionedMeMsg
            let mentionedMeMsg: DTMentionedMsgInfo? = try SDSDeserialization.optionalUnarchive(mentionedMeMsgSerialized, name: "mentionedMeMsg")
            let mentionsDraftSerialized: Data? = record.mentionsDraft
            let mentionsDraft: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsDraftSerialized, name: "mentionsDraft")
            let messageClearAnchor: UInt64 = record.messageClearAnchor
            let messageDraft: String? = record.messageDraft
            let mutedUntilDateInterval: Double? = record.mutedUntilDate
            let mutedUntilDate: Date? = SDSDeserialization.optionalDoubleAsDate(mutedUntilDateInterval, name: "mutedUntilDate")
            let plainTextEnable: Bool = record.plainTextEnable
            let readPositionEntitySerialized: Data? = record.readPositionEntity
            let readPositionEntity: DTReadPositionEntity? = try SDSDeserialization.optionalUnarchive(readPositionEntitySerialized, name: "readPositionEntity")
            let removedFromConversation: Bool = record.removedFromConversation
            let shouldBeVisible: Bool = record.shouldBeVisible
            let stickCallingDateInterval: Double? = record.stickCallingDate
            let stickCallingDate: Date? = SDSDeserialization.optionalDoubleAsDate(stickCallingDateInterval, name: "stickCallingDate")
            let stickDateInterval: Double? = record.stickDate
            let stickDate: Date? = SDSDeserialization.optionalDoubleAsDate(stickDateInterval, name: "stickDate")
            let threadConfigSerialized: Data? = record.threadConfig
            let threadConfig: DTThreadConfigEntity? = try SDSDeserialization.optionalUnarchive(threadConfigSerialized, name: "threadConfig")
            let translateSettingType: NSNumber? = SDSDeserialization.optionalNumericAsNSNumber(record.translateSettingType, name: "translateSettingType", conversion: { NSNumber(value: $0) })
            let unreadFlag: UInt32 = record.unreadFlag
            let unreadMessageCount: UInt = record.unreadMessageCount
            let unreadState: UInt = record.unreadState
            let unreadTimeStimeStamp: UInt64 = record.unreadTimeStimeStamp

            return TSThread(grdbId: recordId,
                            uniqueId: uniqueId,
                            archivalDate: archivalDate,
                            conversationEntity: conversationEntity,
                            creationDate: creationDate,
                            draftQuoteMessageId: draftQuoteMessageId,
                            expiresInSeconds: expiresInSeconds,
                            hasEverHadMessage: hasEverHadMessage,
                            isArchived: isArchived,
                            lastMessageDate: lastMessageDate,
                            lastestMsg: lastestMsg,
                            mentionedAllMsg: mentionedAllMsg,
                            mentionedMeMsg: mentionedMeMsg,
                            mentionsDraft: mentionsDraft,
                            messageClearAnchor: messageClearAnchor,
                            messageDraft: messageDraft,
                            mutedUntilDate: mutedUntilDate,
                            plainTextEnable: plainTextEnable,
                            readPositionEntity: readPositionEntity,
                            removedFromConversation: removedFromConversation,
                            shouldBeVisible: shouldBeVisible,
                            stickCallingDate: stickCallingDate,
                            stickDate: stickDate,
                            threadConfig: threadConfig,
                            translateSettingType: translateSettingType,
                            unreadFlag: unreadFlag,
                            unreadMessageCount: unreadMessageCount,
                            unreadState: unreadState,
                            unreadTimeStimeStamp: unreadTimeStimeStamp)

        default:
            owsFailDebug("Unexpected record type: \(record.recordType)")
            throw SDSError.invalidValue
        }
    }
}

// MARK: - SDSModel

extension TSThread: SDSModel {
    public var serializer: SDSSerializer {
        // Any subclass can be cast to it's superclass,
        // so the order of this switch statement matters.
        // We need to do a "depth first" search by type.
        switch self {
        case let model as TSGroupThread:
            assert(type(of: model) == TSGroupThread.self)
            return TSGroupThreadSerializer(model: model)
        case let model as TSContactThread:
            assert(type(of: model) == TSContactThread.self)
            return TSContactThreadSerializer(model: model)
        case let model as DTVirtualThread:
            assert(type(of: model) == DTVirtualThread.self)
            return DTVirtualThreadSerializer(model: model)
        default:
            return TSThreadSerializer(model: self)
        }
    }

    public func asRecord() throws -> SDSRecord {
        try serializer.asRecord()
    }

    public var sdsTableName: String {
        ThreadRecord.databaseTableName
    }

    public static var table: SDSTableMetadata {
        TSThreadSerializer.table
    }
}

// MARK: - DeepCopyable

extension TSThread: DeepCopyable {

    public func deepCopy() throws -> AnyObject {
        // Any subclass can be cast to it's superclass,
        // so the order of this switch statement matters.
        // We need to do a "depth first" search by type.
        guard let id = self.grdbId?.int64Value else {
            throw OWSAssertionError("Model missing grdbId.")
        }

        if let modelToCopy = self as? TSGroupThread {
            assert(type(of: modelToCopy) == TSGroupThread.self)
            let uniqueId: String = modelToCopy.uniqueId
            let archivalDate: Date? = modelToCopy.archivalDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let conversationEntity: DTConversationEntity?
            if let conversationEntityForCopy = modelToCopy.conversationEntity {
               conversationEntity = try DeepCopies.deepCopy(conversationEntityForCopy)
            } else {
               conversationEntity = nil
            }
            let creationDate: Date = modelToCopy.creationDate
            let draftQuoteMessageId: String? = modelToCopy.draftQuoteMessageId
            let expiresInSeconds: UInt64 = modelToCopy.expiresInSeconds
            let hasEverHadMessage: Bool = modelToCopy.hasEverHadMessage
            let isArchived: Bool = modelToCopy.isArchived
            let lastMessageDate: Date? = modelToCopy.lastMessageDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let lastestMsg: TSMessage?
            if let lastestMsgForCopy = modelToCopy.lastestMsg {
               lastestMsg = try DeepCopies.deepCopy(lastestMsgForCopy)
            } else {
               lastestMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionedAllMsg: DTMentionedMsgInfo?
            if let mentionedAllMsgForCopy = modelToCopy.mentionedAllMsg {
               mentionedAllMsg = try DeepCopies.deepCopy(mentionedAllMsgForCopy)
            } else {
               mentionedAllMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionedMeMsg: DTMentionedMsgInfo?
            if let mentionedMeMsgForCopy = modelToCopy.mentionedMeMsg {
               mentionedMeMsg = try DeepCopies.deepCopy(mentionedMeMsgForCopy)
            } else {
               mentionedMeMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionsDraft: [DTMention]?
            if let mentionsDraftForCopy = modelToCopy.mentionsDraft {
               mentionsDraft = try DeepCopies.deepCopy(mentionsDraftForCopy)
            } else {
               mentionsDraft = nil
            }
            let messageClearAnchor: UInt64 = modelToCopy.messageClearAnchor
            let messageDraft: String? = modelToCopy.messageDraft
            let mutedUntilDate: Date? = modelToCopy.mutedUntilDate
            let plainTextEnable: Bool = modelToCopy.plainTextEnable
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let readPositionEntity: DTReadPositionEntity?
            if let readPositionEntityForCopy = modelToCopy.readPositionEntity {
               readPositionEntity = try DeepCopies.deepCopy(readPositionEntityForCopy)
            } else {
               readPositionEntity = nil
            }
            let removedFromConversation: Bool = modelToCopy.isRemovedFromConversation
            let shouldBeVisible: Bool = modelToCopy.shouldBeVisible
            let stickCallingDate: Date? = modelToCopy.stickCallingDate
            let stickDate: Date? = modelToCopy.stickDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let threadConfig: DTThreadConfigEntity?
            if let threadConfigForCopy = modelToCopy.threadConfig {
               threadConfig = try DeepCopies.deepCopy(threadConfigForCopy)
            } else {
               threadConfig = nil
            }
            let translateSettingType: NSNumber? = modelToCopy.translateSettingType
            let unreadFlag: UInt32 = modelToCopy.unreadFlag
            let unreadMessageCount: UInt = modelToCopy.unreadMessageCount
            let unreadState: UInt = modelToCopy.unreadState
            let unreadTimeStimeStamp: UInt64 = modelToCopy.unreadTimeStimeStamp
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let groupModel: TSGroupModel = try DeepCopies.deepCopy(modelToCopy.groupModel)

            return TSGroupThread(grdbId: id,
                                 uniqueId: uniqueId,
                                 archivalDate: archivalDate,
                                 conversationEntity: conversationEntity,
                                 creationDate: creationDate,
                                 draftQuoteMessageId: draftQuoteMessageId,
                                 expiresInSeconds: expiresInSeconds,
                                 hasEverHadMessage: hasEverHadMessage,
                                 isArchived: isArchived,
                                 lastMessageDate: lastMessageDate,
                                 lastestMsg: lastestMsg,
                                 mentionedAllMsg: mentionedAllMsg,
                                 mentionedMeMsg: mentionedMeMsg,
                                 mentionsDraft: mentionsDraft,
                                 messageClearAnchor: messageClearAnchor,
                                 messageDraft: messageDraft,
                                 mutedUntilDate: mutedUntilDate,
                                 plainTextEnable: plainTextEnable,
                                 readPositionEntity: readPositionEntity,
                                 removedFromConversation: removedFromConversation,
                                 shouldBeVisible: shouldBeVisible,
                                 stickCallingDate: stickCallingDate,
                                 stickDate: stickDate,
                                 threadConfig: threadConfig,
                                 translateSettingType: translateSettingType,
                                 unreadFlag: unreadFlag,
                                 unreadMessageCount: unreadMessageCount,
                                 unreadState: unreadState,
                                 unreadTimeStimeStamp: unreadTimeStimeStamp,
                                 groupModel: groupModel)
        }

        if let modelToCopy = self as? TSContactThread {
            assert(type(of: modelToCopy) == TSContactThread.self)
            let uniqueId: String = modelToCopy.uniqueId
            let archivalDate: Date? = modelToCopy.archivalDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let conversationEntity: DTConversationEntity?
            if let conversationEntityForCopy = modelToCopy.conversationEntity {
               conversationEntity = try DeepCopies.deepCopy(conversationEntityForCopy)
            } else {
               conversationEntity = nil
            }
            let creationDate: Date = modelToCopy.creationDate
            let draftQuoteMessageId: String? = modelToCopy.draftQuoteMessageId
            let expiresInSeconds: UInt64 = modelToCopy.expiresInSeconds
            let hasEverHadMessage: Bool = modelToCopy.hasEverHadMessage
            let isArchived: Bool = modelToCopy.isArchived
            let lastMessageDate: Date? = modelToCopy.lastMessageDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let lastestMsg: TSMessage?
            if let lastestMsgForCopy = modelToCopy.lastestMsg {
               lastestMsg = try DeepCopies.deepCopy(lastestMsgForCopy)
            } else {
               lastestMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionedAllMsg: DTMentionedMsgInfo?
            if let mentionedAllMsgForCopy = modelToCopy.mentionedAllMsg {
               mentionedAllMsg = try DeepCopies.deepCopy(mentionedAllMsgForCopy)
            } else {
               mentionedAllMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionedMeMsg: DTMentionedMsgInfo?
            if let mentionedMeMsgForCopy = modelToCopy.mentionedMeMsg {
               mentionedMeMsg = try DeepCopies.deepCopy(mentionedMeMsgForCopy)
            } else {
               mentionedMeMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionsDraft: [DTMention]?
            if let mentionsDraftForCopy = modelToCopy.mentionsDraft {
               mentionsDraft = try DeepCopies.deepCopy(mentionsDraftForCopy)
            } else {
               mentionsDraft = nil
            }
            let messageClearAnchor: UInt64 = modelToCopy.messageClearAnchor
            let messageDraft: String? = modelToCopy.messageDraft
            let mutedUntilDate: Date? = modelToCopy.mutedUntilDate
            let plainTextEnable: Bool = modelToCopy.plainTextEnable
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let readPositionEntity: DTReadPositionEntity?
            if let readPositionEntityForCopy = modelToCopy.readPositionEntity {
               readPositionEntity = try DeepCopies.deepCopy(readPositionEntityForCopy)
            } else {
               readPositionEntity = nil
            }
            let removedFromConversation: Bool = modelToCopy.isRemovedFromConversation
            let shouldBeVisible: Bool = modelToCopy.shouldBeVisible
            let stickCallingDate: Date? = modelToCopy.stickCallingDate
            let stickDate: Date? = modelToCopy.stickDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let threadConfig: DTThreadConfigEntity?
            if let threadConfigForCopy = modelToCopy.threadConfig {
               threadConfig = try DeepCopies.deepCopy(threadConfigForCopy)
            } else {
               threadConfig = nil
            }
            let translateSettingType: NSNumber? = modelToCopy.translateSettingType
            let unreadFlag: UInt32 = modelToCopy.unreadFlag
            let unreadMessageCount: UInt = modelToCopy.unreadMessageCount
            let unreadState: UInt = modelToCopy.unreadState
            let unreadTimeStimeStamp: UInt64 = modelToCopy.unreadTimeStimeStamp
            let friendContactVersion: Int = modelToCopy.friendContactVersion
            let hasDismissedOffers: Bool = modelToCopy.hasDismissedOffers
            let receivedFriendReq: Bool = modelToCopy.receivedFriendReq

            return TSContactThread(grdbId: id,
                                   uniqueId: uniqueId,
                                   archivalDate: archivalDate,
                                   conversationEntity: conversationEntity,
                                   creationDate: creationDate,
                                   draftQuoteMessageId: draftQuoteMessageId,
                                   expiresInSeconds: expiresInSeconds,
                                   hasEverHadMessage: hasEverHadMessage,
                                   isArchived: isArchived,
                                   lastMessageDate: lastMessageDate,
                                   lastestMsg: lastestMsg,
                                   mentionedAllMsg: mentionedAllMsg,
                                   mentionedMeMsg: mentionedMeMsg,
                                   mentionsDraft: mentionsDraft,
                                   messageClearAnchor: messageClearAnchor,
                                   messageDraft: messageDraft,
                                   mutedUntilDate: mutedUntilDate,
                                   plainTextEnable: plainTextEnable,
                                   readPositionEntity: readPositionEntity,
                                   removedFromConversation: removedFromConversation,
                                   shouldBeVisible: shouldBeVisible,
                                   stickCallingDate: stickCallingDate,
                                   stickDate: stickDate,
                                   threadConfig: threadConfig,
                                   translateSettingType: translateSettingType,
                                   unreadFlag: unreadFlag,
                                   unreadMessageCount: unreadMessageCount,
                                   unreadState: unreadState,
                                   unreadTimeStimeStamp: unreadTimeStimeStamp,
                                   friendContactVersion: friendContactVersion,
                                   hasDismissedOffers: hasDismissedOffers,
                                   receivedFriendReq: receivedFriendReq)
        }

        if let modelToCopy = self as? DTVirtualThread {
            assert(type(of: modelToCopy) == DTVirtualThread.self)
            let uniqueId: String = modelToCopy.uniqueId
            let archivalDate: Date? = modelToCopy.archivalDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let conversationEntity: DTConversationEntity?
            if let conversationEntityForCopy = modelToCopy.conversationEntity {
               conversationEntity = try DeepCopies.deepCopy(conversationEntityForCopy)
            } else {
               conversationEntity = nil
            }
            let creationDate: Date = modelToCopy.creationDate
            let draftQuoteMessageId: String? = modelToCopy.draftQuoteMessageId
            let expiresInSeconds: UInt64 = modelToCopy.expiresInSeconds
            let hasEverHadMessage: Bool = modelToCopy.hasEverHadMessage
            let isArchived: Bool = modelToCopy.isArchived
            let lastMessageDate: Date? = modelToCopy.lastMessageDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let lastestMsg: TSMessage?
            if let lastestMsgForCopy = modelToCopy.lastestMsg {
               lastestMsg = try DeepCopies.deepCopy(lastestMsgForCopy)
            } else {
               lastestMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionedAllMsg: DTMentionedMsgInfo?
            if let mentionedAllMsgForCopy = modelToCopy.mentionedAllMsg {
               mentionedAllMsg = try DeepCopies.deepCopy(mentionedAllMsgForCopy)
            } else {
               mentionedAllMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionedMeMsg: DTMentionedMsgInfo?
            if let mentionedMeMsgForCopy = modelToCopy.mentionedMeMsg {
               mentionedMeMsg = try DeepCopies.deepCopy(mentionedMeMsgForCopy)
            } else {
               mentionedMeMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionsDraft: [DTMention]?
            if let mentionsDraftForCopy = modelToCopy.mentionsDraft {
               mentionsDraft = try DeepCopies.deepCopy(mentionsDraftForCopy)
            } else {
               mentionsDraft = nil
            }
            let messageClearAnchor: UInt64 = modelToCopy.messageClearAnchor
            let messageDraft: String? = modelToCopy.messageDraft
            let mutedUntilDate: Date? = modelToCopy.mutedUntilDate
            let plainTextEnable: Bool = modelToCopy.plainTextEnable
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let readPositionEntity: DTReadPositionEntity?
            if let readPositionEntityForCopy = modelToCopy.readPositionEntity {
               readPositionEntity = try DeepCopies.deepCopy(readPositionEntityForCopy)
            } else {
               readPositionEntity = nil
            }
            let removedFromConversation: Bool = modelToCopy.isRemovedFromConversation
            let shouldBeVisible: Bool = modelToCopy.shouldBeVisible
            let stickCallingDate: Date? = modelToCopy.stickCallingDate
            let stickDate: Date? = modelToCopy.stickDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let threadConfig: DTThreadConfigEntity?
            if let threadConfigForCopy = modelToCopy.threadConfig {
               threadConfig = try DeepCopies.deepCopy(threadConfigForCopy)
            } else {
               threadConfig = nil
            }
            let translateSettingType: NSNumber? = modelToCopy.translateSettingType
            let unreadFlag: UInt32 = modelToCopy.unreadFlag
            let unreadMessageCount: UInt = modelToCopy.unreadMessageCount
            let unreadState: UInt = modelToCopy.unreadState
            let unreadTimeStimeStamp: UInt64 = modelToCopy.unreadTimeStimeStamp

            return DTVirtualThread(grdbId: id,
                                   uniqueId: uniqueId,
                                   archivalDate: archivalDate,
                                   conversationEntity: conversationEntity,
                                   creationDate: creationDate,
                                   draftQuoteMessageId: draftQuoteMessageId,
                                   expiresInSeconds: expiresInSeconds,
                                   hasEverHadMessage: hasEverHadMessage,
                                   isArchived: isArchived,
                                   lastMessageDate: lastMessageDate,
                                   lastestMsg: lastestMsg,
                                   mentionedAllMsg: mentionedAllMsg,
                                   mentionedMeMsg: mentionedMeMsg,
                                   mentionsDraft: mentionsDraft,
                                   messageClearAnchor: messageClearAnchor,
                                   messageDraft: messageDraft,
                                   mutedUntilDate: mutedUntilDate,
                                   plainTextEnable: plainTextEnable,
                                   readPositionEntity: readPositionEntity,
                                   removedFromConversation: removedFromConversation,
                                   shouldBeVisible: shouldBeVisible,
                                   stickCallingDate: stickCallingDate,
                                   stickDate: stickDate,
                                   threadConfig: threadConfig,
                                   translateSettingType: translateSettingType,
                                   unreadFlag: unreadFlag,
                                   unreadMessageCount: unreadMessageCount,
                                   unreadState: unreadState,
                                   unreadTimeStimeStamp: unreadTimeStimeStamp)
        }

        do {
            let modelToCopy = self
            assert(type(of: modelToCopy) == TSThread.self)
            let uniqueId: String = modelToCopy.uniqueId
            let archivalDate: Date? = modelToCopy.archivalDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let conversationEntity: DTConversationEntity?
            if let conversationEntityForCopy = modelToCopy.conversationEntity {
               conversationEntity = try DeepCopies.deepCopy(conversationEntityForCopy)
            } else {
               conversationEntity = nil
            }
            let creationDate: Date = modelToCopy.creationDate
            let draftQuoteMessageId: String? = modelToCopy.draftQuoteMessageId
            let expiresInSeconds: UInt64 = modelToCopy.expiresInSeconds
            let hasEverHadMessage: Bool = modelToCopy.hasEverHadMessage
            let isArchived: Bool = modelToCopy.isArchived
            let lastMessageDate: Date? = modelToCopy.lastMessageDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let lastestMsg: TSMessage?
            if let lastestMsgForCopy = modelToCopy.lastestMsg {
               lastestMsg = try DeepCopies.deepCopy(lastestMsgForCopy)
            } else {
               lastestMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionedAllMsg: DTMentionedMsgInfo?
            if let mentionedAllMsgForCopy = modelToCopy.mentionedAllMsg {
               mentionedAllMsg = try DeepCopies.deepCopy(mentionedAllMsgForCopy)
            } else {
               mentionedAllMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionedMeMsg: DTMentionedMsgInfo?
            if let mentionedMeMsgForCopy = modelToCopy.mentionedMeMsg {
               mentionedMeMsg = try DeepCopies.deepCopy(mentionedMeMsgForCopy)
            } else {
               mentionedMeMsg = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentionsDraft: [DTMention]?
            if let mentionsDraftForCopy = modelToCopy.mentionsDraft {
               mentionsDraft = try DeepCopies.deepCopy(mentionsDraftForCopy)
            } else {
               mentionsDraft = nil
            }
            let messageClearAnchor: UInt64 = modelToCopy.messageClearAnchor
            let messageDraft: String? = modelToCopy.messageDraft
            let mutedUntilDate: Date? = modelToCopy.mutedUntilDate
            let plainTextEnable: Bool = modelToCopy.plainTextEnable
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let readPositionEntity: DTReadPositionEntity?
            if let readPositionEntityForCopy = modelToCopy.readPositionEntity {
               readPositionEntity = try DeepCopies.deepCopy(readPositionEntityForCopy)
            } else {
               readPositionEntity = nil
            }
            let removedFromConversation: Bool = modelToCopy.isRemovedFromConversation
            let shouldBeVisible: Bool = modelToCopy.shouldBeVisible
            let stickCallingDate: Date? = modelToCopy.stickCallingDate
            let stickDate: Date? = modelToCopy.stickDate
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let threadConfig: DTThreadConfigEntity?
            if let threadConfigForCopy = modelToCopy.threadConfig {
               threadConfig = try DeepCopies.deepCopy(threadConfigForCopy)
            } else {
               threadConfig = nil
            }
            let translateSettingType: NSNumber? = modelToCopy.translateSettingType
            let unreadFlag: UInt32 = modelToCopy.unreadFlag
            let unreadMessageCount: UInt = modelToCopy.unreadMessageCount
            let unreadState: UInt = modelToCopy.unreadState
            let unreadTimeStimeStamp: UInt64 = modelToCopy.unreadTimeStimeStamp

            return TSThread(grdbId: id,
                            uniqueId: uniqueId,
                            archivalDate: archivalDate,
                            conversationEntity: conversationEntity,
                            creationDate: creationDate,
                            draftQuoteMessageId: draftQuoteMessageId,
                            expiresInSeconds: expiresInSeconds,
                            hasEverHadMessage: hasEverHadMessage,
                            isArchived: isArchived,
                            lastMessageDate: lastMessageDate,
                            lastestMsg: lastestMsg,
                            mentionedAllMsg: mentionedAllMsg,
                            mentionedMeMsg: mentionedMeMsg,
                            mentionsDraft: mentionsDraft,
                            messageClearAnchor: messageClearAnchor,
                            messageDraft: messageDraft,
                            mutedUntilDate: mutedUntilDate,
                            plainTextEnable: plainTextEnable,
                            readPositionEntity: readPositionEntity,
                            removedFromConversation: removedFromConversation,
                            shouldBeVisible: shouldBeVisible,
                            stickCallingDate: stickCallingDate,
                            stickDate: stickDate,
                            threadConfig: threadConfig,
                            translateSettingType: translateSettingType,
                            unreadFlag: unreadFlag,
                            unreadMessageCount: unreadMessageCount,
                            unreadState: unreadState,
                            unreadTimeStimeStamp: unreadTimeStimeStamp)
        }

    }
}

// MARK: - Table Metadata

extension TSThreadSerializer {

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    static var idColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "id", columnType: .primaryKey) }
    static var recordTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "recordType", columnType: .int64) }
    static var uniqueIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "uniqueId", columnType: .unicodeString, isUnique: true) }
    // Properties
    static var archivalDateColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "archivalDate", columnType: .double, isOptional: true) }
    static var conversationEntityColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "conversationEntity", columnType: .blob, isOptional: true) }
    static var creationDateColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "creationDate", columnType: .double) }
    static var draftQuoteMessageIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "draftQuoteMessageId", columnType: .unicodeString, isOptional: true) }
    static var groupModelColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "groupModel", columnType: .blob, isOptional: true) }
    static var hasDismissedOffersColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "hasDismissedOffers", columnType: .int, isOptional: true) }
    static var hasEverHadMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "hasEverHadMessage", columnType: .int) }
    static var lastMessageDateColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "lastMessageDate", columnType: .double, isOptional: true) }
    static var lastestMsgColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "lastestMsg", columnType: .blob, isOptional: true) }
    static var messageDraftColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "messageDraft", columnType: .unicodeString, isOptional: true) }
    static var mutedUntilDateColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "mutedUntilDate", columnType: .double, isOptional: true) }
    static var plainTextEnableColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "plainTextEnable", columnType: .int) }
    static var readPositionEntityColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "readPositionEntity", columnType: .blob, isOptional: true) }
    static var removedFromConversationColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "removedFromConversation", columnType: .int) }
    static var stickCallingDateColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "stickCallingDate", columnType: .double, isOptional: true) }
    static var stickDateColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "stickDate", columnType: .double, isOptional: true) }
    static var translateSettingTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "translateSettingType", columnType: .int64, isOptional: true) }
    static var unreadFlagColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "unreadFlag", columnType: .int64) }
    static var unreadStateColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "unreadState", columnType: .int64) }
    static var unreadTimeStimeStampColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "unreadTimeStimeStamp", columnType: .int64) }
    static var isArchivedColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "isArchived", columnType: .int) }
    static var unreadMessageCountColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "unreadMessageCount", columnType: .int64) }
    static var mentionedAllMsgColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "mentionedAllMsg", columnType: .blob, isOptional: true) }
    static var mentionedMeMsgColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "mentionedMeMsg", columnType: .blob, isOptional: true) }
    static var shouldBeVisibleColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "shouldBeVisible", columnType: .int) }
    static var threadConfigColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "threadConfig", columnType: .blob, isOptional: true) }
    static var mentionsDraftColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "mentionsDraft", columnType: .blob, isOptional: true) }
    static var friendContactVersionColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "friendContactVersion", columnType: .int64, isOptional: true) }
    static var receivedFriendReqColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "receivedFriendReq", columnType: .int, isOptional: true) }
    static var expiresInSecondsColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "expiresInSeconds", columnType: .int64) }
    static var messageClearAnchorColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "messageClearAnchor", columnType: .int64) }

    // TODO: We should decide on a naming convention for
    //       tables that store models.
    public static var table: SDSTableMetadata {
        SDSTableMetadata(collection: TSThread.collection(),
                         tableName: "model_TSThread",
                         columns: [
        idColumn,
        recordTypeColumn,
        uniqueIdColumn,
        archivalDateColumn,
        conversationEntityColumn,
        creationDateColumn,
        draftQuoteMessageIdColumn,
        groupModelColumn,
        hasDismissedOffersColumn,
        hasEverHadMessageColumn,
        lastMessageDateColumn,
        lastestMsgColumn,
        messageDraftColumn,
        mutedUntilDateColumn,
        plainTextEnableColumn,
        readPositionEntityColumn,
        removedFromConversationColumn,
        stickCallingDateColumn,
        stickDateColumn,
        translateSettingTypeColumn,
        unreadFlagColumn,
        unreadStateColumn,
        unreadTimeStimeStampColumn,
        isArchivedColumn,
        unreadMessageCountColumn,
        mentionedAllMsgColumn,
        mentionedMeMsgColumn,
        shouldBeVisibleColumn,
        threadConfigColumn,
        mentionsDraftColumn,
        friendContactVersionColumn,
        receivedFriendReqColumn,
        expiresInSecondsColumn,
        messageClearAnchorColumn
        ])
    }
}

// MARK: - Save/Remove/Update

@objc
public extension TSThread {
    func anyInsert(transaction: SDSAnyWriteTransaction) {
        sdsSave(saveMode: .insert, transaction: transaction)
    }

    // Avoid this method whenever feasible.
    //
    // If the record has previously been saved, this method does an overwriting
    // update of the corresponding row, otherwise if it's a new record, this
    // method inserts a new row.
    //
    // For performance, when possible, you should explicitly specify whether
    // you are inserting or updating rather than calling this method.
    func anyUpsert(transaction: SDSAnyWriteTransaction) {
        let isInserting: Bool
        if TSThread.anyFetch(uniqueId: uniqueId, transaction: transaction) != nil {
            isInserting = false
        } else {
            isInserting = true
        }
        sdsSave(saveMode: isInserting ? .insert : .update, transaction: transaction)
    }

    // This method is used by "updateWith..." methods.
    //
    // This model may be updated from many threads. We don't want to save
    // our local copy (this instance) since it may be out of date.  We also
    // want to avoid re-saving a model that has been deleted.  Therefore, we
    // use "updateWith..." methods to:
    //
    // a) Update a property of this instance.
    // b) If a copy of this model exists in the database, load an up-to-date copy,
    //    and update and save that copy.
    // b) If a copy of this model _DOES NOT_ exist in the database, do _NOT_ save
    //    this local instance.
    //
    // After "updateWith...":
    //
    // a) Any copy of this model in the database will have been updated.
    // b) The local property on this instance will always have been updated.
    // c) Other properties on this instance may be out of date.
    //
    // All mutable properties of this class have been made read-only to
    // prevent accidentally modifying them directly.
    //
    // This isn't a perfect arrangement, but in practice this will prevent
    // data loss and will resolve all known issues.
    func anyUpdate(transaction: SDSAnyWriteTransaction, block: (TSThread) -> Void) {

        block(self)

        guard let dbCopy = type(of: self).anyFetch(uniqueId: uniqueId,
                                                   transaction: transaction) else {
            return
        }

        // Don't apply the block twice to the same instance.
        // It's at least unnecessary and actually wrong for some blocks.
        // e.g. `block: { $0 in $0.someField++ }`
        if dbCopy !== self {
            block(dbCopy)
        }

        dbCopy.sdsSave(saveMode: .update, transaction: transaction)
    }

    // This method is an alternative to `anyUpdate(transaction:block:)` methods.
    //
    // We should generally use `anyUpdate` to ensure we're not unintentionally
    // clobbering other columns in the database when another concurrent update
    // has occurred.
    //
    // There are cases when this doesn't make sense, e.g. when  we know we've
    // just loaded the model in the same transaction. In those cases it is
    // safe and faster to do a "overwriting" update
    func anyOverwritingUpdate(transaction: SDSAnyWriteTransaction) {
        sdsSave(saveMode: .update, transaction: transaction)
    }

    func anyRemove(transaction: SDSAnyWriteTransaction) {
        sdsRemove(transaction: transaction)
    }

    func anyReload(transaction: SDSAnyReadTransaction) {
        anyReload(transaction: transaction, ignoreMissing: false)
    }

    func anyReload(transaction: SDSAnyReadTransaction, ignoreMissing: Bool) {
        guard let latestVersion = type(of: self).anyFetch(uniqueId: uniqueId, transaction: transaction) else {
            if !ignoreMissing {
                owsFailDebug("`latest` was unexpectedly nil")
            }
            return
        }

        setValuesForKeys(latestVersion.dictionaryValue)
    }
}

// MARK: - TSThreadCursor

@objc
public class TSThreadCursor: NSObject, SDSCursor {
    private let transaction: GRDBReadTransaction
    private let cursor: RecordCursor<ThreadRecord>?

    init(transaction: GRDBReadTransaction, cursor: RecordCursor<ThreadRecord>?) {
        self.transaction = transaction
        self.cursor = cursor
    }

    public func next() throws -> TSThread? {
        guard let cursor = cursor else {
            return nil
        }
        guard let record = try cursor.next() else {
            return nil
        }
        let value = try TSThread.fromRecord(record)
        Self.modelReadCaches.threadReadCache.didReadThread(value, transaction: transaction.asAnyRead)
        return value
    }

    public func all() throws -> [TSThread] {
        var result = [TSThread]()
        while true {
            guard let model = try next() else {
                break
            }
            result.append(model)
        }
        return result
    }
}

// MARK: - Obj-C Fetch

// TODO: We may eventually want to define some combination of:
//
// * fetchCursor, fetchOne, fetchAll, etc. (ala GRDB)
// * Optional "where clause" parameters for filtering.
// * Async flavors with completions.
//
// TODO: I've defined flavors that take a read transaction.
//       Or we might take a "connection" if we end up having that class.
@objc
public extension TSThread {
    class func grdbFetchCursor(transaction: GRDBReadTransaction) -> TSThreadCursor {
        let database = transaction.database
        do {
            let cursor = try ThreadRecord.fetchCursor(database)
            return TSThreadCursor(transaction: transaction, cursor: cursor)
        } catch {
            owsFailDebug("Read failed: \(error)")
            return TSThreadCursor(transaction: transaction, cursor: nil)
        }
    }

    // Fetches a single model by "unique id".
    class func anyFetch(uniqueId: String,
                        transaction: SDSAnyReadTransaction) -> TSThread? {
        assert(uniqueId.count > 0)

        return anyFetch(uniqueId: uniqueId, transaction: transaction, ignoreCache: false)
    }

    // Fetches a single model by "unique id".
    class func anyFetch(uniqueId: String,
                        transaction: SDSAnyReadTransaction,
                        ignoreCache: Bool) -> TSThread? {
        assert(uniqueId.count > 0)

        if !ignoreCache,
            let cachedCopy = Self.modelReadCaches.threadReadCache.getThread(uniqueId: uniqueId, transaction: transaction) {
            return cachedCopy
        }

        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            let sql = "SELECT * FROM \(ThreadRecord.databaseTableName) WHERE \(threadColumn: .uniqueId) = ?"
            return grdbFetchOne(sql: sql, arguments: [uniqueId], transaction: grdbTransaction)
        }
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    class func anyEnumerate(transaction: SDSAnyReadTransaction,
                            block: @escaping (TSThread, UnsafeMutablePointer<ObjCBool>) -> Void) {
        anyEnumerate(transaction: transaction, batched: false, block: block)
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    class func anyEnumerate(transaction: SDSAnyReadTransaction,
                            batched: Bool = false,
                            block: @escaping (TSThread, UnsafeMutablePointer<ObjCBool>) -> Void) {
        let batchSize = batched ? Batching.kDefaultBatchSize : 0
        anyEnumerate(transaction: transaction, batchSize: batchSize, block: block)
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    //
    // If batchSize > 0, the enumeration is performed in autoreleased batches.
    class func anyEnumerate(transaction: SDSAnyReadTransaction,
                            batchSize: UInt,
                            block: @escaping (TSThread, UnsafeMutablePointer<ObjCBool>) -> Void) {
        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            let cursor = TSThread.grdbFetchCursor(transaction: grdbTransaction)
            Batching.loop(batchSize: batchSize,
                          loopBlock: { stop in
                                do {
                                    guard let value = try cursor.next() else {
                                        stop.pointee = true
                                        return
                                    }
                                    block(value, stop)
                                } catch let error {
                                    owsFailDebug("Couldn't fetch model: \(error)")
                                }
                              })
        }
    }

    // Traverses all records' unique ids.
    // Records are not visited in any particular order.
    class func anyEnumerateUniqueIds(transaction: SDSAnyReadTransaction,
                                     block: @escaping (String, UnsafeMutablePointer<ObjCBool>) -> Void) {
        anyEnumerateUniqueIds(transaction: transaction, batched: false, block: block)
    }

    // Traverses all records' unique ids.
    // Records are not visited in any particular order.
    class func anyEnumerateUniqueIds(transaction: SDSAnyReadTransaction,
                                     batched: Bool = false,
                                     block: @escaping (String, UnsafeMutablePointer<ObjCBool>) -> Void) {
        let batchSize = batched ? Batching.kDefaultBatchSize : 0
        anyEnumerateUniqueIds(transaction: transaction, batchSize: batchSize, block: block)
    }

    // Traverses all records' unique ids.
    // Records are not visited in any particular order.
    //
    // If batchSize > 0, the enumeration is performed in autoreleased batches.
    class func anyEnumerateUniqueIds(transaction: SDSAnyReadTransaction,
                                     batchSize: UInt,
                                     block: @escaping (String, UnsafeMutablePointer<ObjCBool>) -> Void) {
        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            grdbEnumerateUniqueIds(transaction: grdbTransaction,
                                   sql: """
                    SELECT \(threadColumn: .uniqueId)
                    FROM \(ThreadRecord.databaseTableName)
                """,
                batchSize: batchSize,
                block: block)
        }
    }

    // Does not order the results.
    class func anyFetchAll(transaction: SDSAnyReadTransaction) -> [TSThread] {
        var result = [TSThread]()
        anyEnumerate(transaction: transaction) { (model, _) in
            result.append(model)
        }
        return result
    }

    // Does not order the results.
    class func anyAllUniqueIds(transaction: SDSAnyReadTransaction) -> [String] {
        var result = [String]()
        anyEnumerateUniqueIds(transaction: transaction) { (uniqueId, _) in
            result.append(uniqueId)
        }
        return result
    }

    class func anyCount(transaction: SDSAnyReadTransaction) -> UInt {
        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            return ThreadRecord.ows_fetchCount(grdbTransaction.database)
        }
    }

    // WARNING: Do not use this method for any models which do cleanup
    //          in their anyWillRemove(), anyDidRemove() methods.
    class func anyRemoveAllWithoutInstantation(transaction: SDSAnyWriteTransaction) {
        switch transaction.writeTransaction {
        //Kris GRDB
        case .grdbWrite(let grdbTransaction):
            do {
                try ThreadRecord.deleteAll(grdbTransaction.database)
            } catch {
                owsFailDebug("deleteAll() failed: \(error)")
            }
        }

        if ftsIndexMode != .never {
            FullTextSearchFinder.allModelsWereRemoved(collection: collection(), transaction: transaction)
        }
    }

    class func anyRemoveAllWithInstantation(transaction: SDSAnyWriteTransaction) {
        // To avoid mutationDuringEnumerationException, we need
        // to remove the instances outside the enumeration.
        let uniqueIds = anyAllUniqueIds(transaction: transaction)

        var index: Int = 0
        Batching.loop(batchSize: Batching.kDefaultBatchSize,
                      loopBlock: { stop in
            guard index < uniqueIds.count else {
                stop.pointee = true
                return
            }
            let uniqueId = uniqueIds[index]
            index += 1
            guard let instance = anyFetch(uniqueId: uniqueId, transaction: transaction) else {
                owsFailDebug("Missing instance.")
                return
            }
            instance.anyRemove(transaction: transaction)
        })

        if ftsIndexMode != .never {
            FullTextSearchFinder.allModelsWereRemoved(collection: collection(), transaction: transaction)
        }
    }

    class func anyExists(
        uniqueId: String,
        transaction: SDSAnyReadTransaction
    ) -> Bool {
        assert(uniqueId.count > 0)

        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            let sql = "SELECT EXISTS ( SELECT 1 FROM \(ThreadRecord.databaseTableName) WHERE \(threadColumn: .uniqueId) = ? )"
            let arguments: StatementArguments = [uniqueId]
            return try! Bool.fetchOne(grdbTransaction.database, sql: sql, arguments: arguments) ?? false
        }
    }
}

// MARK: - Swift Fetch

public extension TSThread {
    class func grdbFetchCursor(sql: String,
                               arguments: StatementArguments = StatementArguments(),
                               transaction: GRDBReadTransaction) -> TSThreadCursor {
        do {
            let sqlRequest = SQLRequest<Void>(sql: sql, arguments: arguments, cached: true)
            let cursor = try ThreadRecord.fetchCursor(transaction.database, sqlRequest)
            return TSThreadCursor(transaction: transaction, cursor: cursor)
        } catch {
            Logger.verbose("sql: \(sql)")
            owsFailDebug("Read failed: \(error)")
            return TSThreadCursor(transaction: transaction, cursor: nil)
        }
    }

    class func grdbFetchOne(sql: String,
                            arguments: StatementArguments = StatementArguments(),
                            transaction: GRDBReadTransaction) -> TSThread? {
        assert(sql.count > 0)

        do {
            let sqlRequest = SQLRequest<Void>(sql: sql, arguments: arguments, cached: true)
            guard let record = try ThreadRecord.fetchOne(transaction.database, sqlRequest) else {
                return nil
            }

            let value = try TSThread.fromRecord(record)
            Self.modelReadCaches.threadReadCache.didReadThread(value, transaction: transaction.asAnyRead)
            return value
        } catch {
            owsFailDebug("error: \(error)")
            return nil
        }
    }
}

// MARK: - SDSSerializer

// The SDSSerializer protocol specifies how to insert and update the
// row that corresponds to this model.
class TSThreadSerializer: SDSSerializer {

    private let model: TSThread
    public required init(model: TSThread) {
        self.model = model
    }

    // MARK: - Record

    func asRecord() throws -> SDSRecord {
        let id: Int64? = model.grdbId?.int64Value

        let recordType: SDSRecordType = .thread
        let uniqueId: String = model.uniqueId

        // Properties
        let archivalDate: Double? = archiveOptionalDate(model.archivalDate)
        let conversationEntity: Data? = optionalArchive(model.conversationEntity)
        let creationDate: Double = archiveDate(model.creationDate)
        let draftQuoteMessageId: String? = model.draftQuoteMessageId
        let groupModel: Data? = nil
        let hasDismissedOffers: Bool? = nil
        let hasEverHadMessage: Bool = model.hasEverHadMessage
        let lastMessageDate: Double? = archiveOptionalDate(model.lastMessageDate)
        let lastestMsg: Data? = optionalArchive(model.lastestMsg)
        let messageDraft: String? = model.messageDraft
        let mutedUntilDate: Double? = archiveOptionalDate(model.mutedUntilDate)
        let plainTextEnable: Bool = model.plainTextEnable
        let readPositionEntity: Data? = optionalArchive(model.readPositionEntity)
        let removedFromConversation: Bool = model.isRemovedFromConversation
        let stickCallingDate: Double? = archiveOptionalDate(model.stickCallingDate)
        let stickDate: Double? = archiveOptionalDate(model.stickDate)
        let translateSettingType: UInt32? = archiveOptionalNSNumber(model.translateSettingType, conversion: { $0.uint32Value })
        let unreadFlag: UInt32 = model.unreadFlag
        let unreadState: UInt = model.unreadState
        let unreadTimeStimeStamp: UInt64 = model.unreadTimeStimeStamp
        let isArchived: Bool = model.isArchived
        let unreadMessageCount: UInt = model.unreadMessageCount
        let mentionedAllMsg: Data? = optionalArchive(model.mentionedAllMsg)
        let mentionedMeMsg: Data? = optionalArchive(model.mentionedMeMsg)
        let shouldBeVisible: Bool = model.shouldBeVisible
        let threadConfig: Data? = optionalArchive(model.threadConfig)
        let mentionsDraft: Data? = optionalArchive(model.mentionsDraft)
        let friendContactVersion: Int? = nil
        let receivedFriendReq: Bool? = nil
        let expiresInSeconds: UInt64 = model.expiresInSeconds
        let messageClearAnchor: UInt64 = model.messageClearAnchor

        return ThreadRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, archivalDate: archivalDate, conversationEntity: conversationEntity, creationDate: creationDate, draftQuoteMessageId: draftQuoteMessageId, groupModel: groupModel, hasDismissedOffers: hasDismissedOffers, hasEverHadMessage: hasEverHadMessage, lastMessageDate: lastMessageDate, lastestMsg: lastestMsg, messageDraft: messageDraft, mutedUntilDate: mutedUntilDate, plainTextEnable: plainTextEnable, readPositionEntity: readPositionEntity, removedFromConversation: removedFromConversation, stickCallingDate: stickCallingDate, stickDate: stickDate, translateSettingType: translateSettingType, unreadFlag: unreadFlag, unreadState: unreadState, unreadTimeStimeStamp: unreadTimeStimeStamp, isArchived: isArchived, unreadMessageCount: unreadMessageCount, mentionedAllMsg: mentionedAllMsg, mentionedMeMsg: mentionedMeMsg, shouldBeVisible: shouldBeVisible, threadConfig: threadConfig, mentionsDraft: mentionsDraft, friendContactVersion: friendContactVersion, receivedFriendReq: receivedFriendReq, expiresInSeconds: expiresInSeconds, messageClearAnchor: messageClearAnchor)
    }
}

// MARK: - Deep Copy

#if TESTABLE_BUILD
@objc
public extension TSThread {
    // We're not using this method at the moment,
    // but we might use it for validation of
    // other deep copy methods.
    func deepCopyUsingRecord() throws -> TSThread {
        guard let record = try asRecord() as? ThreadRecord else {
            throw OWSAssertionError("Could not convert to record.")
        }
        return try TSThread.fromRecord(record)
    }
}
#endif
                                                                                       
