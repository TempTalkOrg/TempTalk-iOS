//
//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.
//

#import "TSThread.h"
#import "SSKCryptography.h"
#import <SignalCoreKit/NSDate+OWS.h>
#import "NSString+SSK.h"
#import "OWSDisappearingMessagesConfiguration.h"
//
#import "OWSReadTracking.h"
//
#import "TSIncomingMessage.h"
#import "OWSOutgoingSyncMessage.h"
#import "TSInfoMessage.h"
#import "TSInteraction.h"
//#import "TSInvalidIdentityKeyReceivingErrorMessage.h"
#import "TSErrorMessage.h"
//
#import "OWSDisappearingMessagesConfigurationMessage.h"
#import "DTParamsBaseUtils.h"
#import "DTDisappearanceTimeIntervalConfig.h"
#import <TTServiceKit/TTServiceKit-swift.h>
#import "DTConversationNotifyEntity.h"
#import "OWSReadReceiptManager.h"
#import "DTReadPositionEntity.h"
#import "DTMentionedMsgInfo.h"
#import "OWSArchivedMessageJob.h"
#import "DTFetchThreadConfigAPI.h"

NS_ASSUME_NONNULL_BEGIN

BOOL IsNoteToSelfEnabled(void)
{
    return YES;
}

@interface TSThread ()

@property (nonatomic) NSDate *creationDate;
@property (nonatomic, copy, nullable) NSDate *archivalDate;
@property (nonatomic, nullable) NSDate *lastMessageDate;
@property (nonatomic, copy, nullable) NSString *messageDraft;
@property (atomic, nullable) NSDate *mutedUntilDate;
@property (nonatomic, strong, nullable) NSDate *stickDate;
@property (nonatomic, strong, nullable) NSDate *stickCallingDate;
@property (nonatomic, assign) NSUInteger unreadState;
@property (nonatomic, copy, nullable) NSString *draftQuoteMessageId;

@property (nonatomic) BOOL isArchived;

@property (nonatomic, nullable) NSArray <DTMention *> *mentionsDraft;

@end

#pragma mark -

@implementation TSThread

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
                    archivalDate:(nullable NSDate *)archivalDate
              conversationEntity:(nullable DTConversationEntity *)conversationEntity
                    creationDate:(NSDate *)creationDate
             draftQuoteMessageId:(nullable NSString *)draftQuoteMessageId
                expiresInSeconds:(unsigned long long)expiresInSeconds
               hasEverHadMessage:(BOOL)hasEverHadMessage
                      isArchived:(BOOL)isArchived
                 lastMessageDate:(nullable NSDate *)lastMessageDate
                      lastestMsg:(nullable TSMessage *)lastestMsg
                 mentionedAllMsg:(nullable DTMentionedMsgInfo *)mentionedAllMsg
                  mentionedMeMsg:(nullable DTMentionedMsgInfo *)mentionedMeMsg
                   mentionsDraft:(nullable NSArray<DTMention *> *)mentionsDraft
              messageClearAnchor:(unsigned long long)messageClearAnchor
                    messageDraft:(nullable NSString *)messageDraft
                  mutedUntilDate:(nullable NSDate *)mutedUntilDate
                 plainTextEnable:(BOOL)plainTextEnable
              readPositionEntity:(nullable DTReadPositionEntity *)readPositionEntity
         removedFromConversation:(BOOL)removedFromConversation
                 shouldBeVisible:(BOOL)shouldBeVisible
                stickCallingDate:(nullable NSDate *)stickCallingDate
                       stickDate:(nullable NSDate *)stickDate
                    threadConfig:(nullable DTThreadConfigEntity *)threadConfig
            translateSettingType:(nullable NSNumber *)translateSettingType
                      unreadFlag:(unsigned int)unreadFlag
              unreadMessageCount:(NSUInteger)unreadMessageCount
                     unreadState:(NSUInteger)unreadState
            unreadTimeStimeStamp:(unsigned long long)unreadTimeStimeStamp
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId];

    if (!self) {
        return self;
    }

    _archivalDate = archivalDate;
    _conversationEntity = conversationEntity;
    _creationDate = creationDate;
    _draftQuoteMessageId = draftQuoteMessageId;
    _expiresInSeconds = expiresInSeconds;
    _hasEverHadMessage = hasEverHadMessage;
    _isArchived = isArchived;
    _lastMessageDate = lastMessageDate;
    _lastestMsg = lastestMsg;
    _mentionedAllMsg = mentionedAllMsg;
    _mentionedMeMsg = mentionedMeMsg;
    _mentionsDraft = mentionsDraft;
    _messageClearAnchor = messageClearAnchor;
    _messageDraft = messageDraft;
    _mutedUntilDate = mutedUntilDate;
    _plainTextEnable = plainTextEnable;
    _readPositionEntity = readPositionEntity;
    _removedFromConversation = removedFromConversation;
    _shouldBeVisible = shouldBeVisible;
    _stickCallingDate = stickCallingDate;
    _stickDate = stickDate;
    _threadConfig = threadConfig;
    _translateSettingType = translateSettingType;
    _unreadFlag = unreadFlag;
    _unreadMessageCount = unreadMessageCount;
    _unreadState = unreadState;
    _unreadTimeStimeStamp = unreadTimeStimeStamp;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

+ (NSString *)collection {
    return @"TSThread";
}

- (instancetype)initWithUniqueId:(NSString *_Nullable)uniqueId
{
    self = [super initWithUniqueId:uniqueId];

    if (self) {
        _archivalDate    = nil;
        _lastMessageDate = nil;
        _creationDate    = [NSDate date];
        _messageDraft    = nil;
        _stickDate       = nil;
        _stickCallingDate     = nil;
        _translateSettingType = @(0);
        _removedFromConversation = false;
        NSString *_Nullable contactId = self.contactIdentifier;
    }

    return self;
}

- (nullable instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];
    if (!self) {
        return self;
    }
    
    return self;
}

- (void)removeAllThreadInteractionsWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    
    // We can't safely delete interactions while enumerating them, so
    // we collect and delete separately.
    //
    // We don't want to instantiate the interactions when collecting them
    // or when deleting them.
    NSMutableArray<NSString *> *interactionIds = [NSMutableArray new];
    NSError *error;
    InteractionFinder *interactionFinder = [[InteractionFinder alloc] initWithThreadUniqueId:self.uniqueId];
    [interactionFinder enumerateInteractionIdsWithTransaction:transaction
                                                        error:&error
                                                        block:^(NSString *key, BOOL *stop) {
                                                            [interactionIds addObject:key];
                                                        }];
    if (error != nil) {
        OWSFailDebug(@"Error during enumeration: %@", error);
    }

    [transaction ignoreInteractionUpdatesForThreadUniqueId:self.uniqueId];
    
    for (NSString *interactionId in interactionIds) {
        // We need to fetch each interaction, since [TSInteraction removeWithTransaction:] does important work.
        TSInteraction *_Nullable interaction =
            [TSInteraction anyFetchWithUniqueId:interactionId transaction:transaction];
        if (!interaction) {
            OWSFailDebug(@"couldn't load thread's interaction for deletion.");
            continue;
        }
        if(![interaction isKindOfClass:[TSMessage class]]){
            [interaction anyRemoveWithTransaction:transaction];
        }else{
            [[OWSArchivedMessageJob sharedJob] archiveMessage:(TSMessage *)interaction transaction:transaction];
        }
        OWSLogInfo(@"removeAllThreadInteractions message timestamp for sorting: %llu", interaction.timestampForSorting);
    }

    // As an optimization, we called `ignoreInteractionUpdatesForThreadUniqueId` so as not
    // to re-save the thread after *each* interaction deletion. However, we still need to resave
    // the thread just once, after all the interactions are deleted.
//    [self anyUpdateWithTransaction:transaction
//                             block:^(TSThread *thread) {
//                                 thread.lastInteractionRowId = 0;
//                             }];
}


#pragma mark To be subclassed.

- (BOOL)isGroupThread {
    OWSAbstractMethod();

    return NO;
}

- (BOOL)isBotThread {
    OWSAbstractMethod();

    return NO;
}


// Override in GroupThread
- (BOOL)isLargeGroupThread {
    OWSAbstractMethod();

    return NO;
}

- (BOOL)isWithoutReadRecipt {
    OWSAbstractMethod();

    return NO;
}

- (BOOL)isHavePermissioncanSpeak {
    OWSAbstractMethod();
    return YES;
}

// Override in GroupThread
- (BOOL)startMeetingWithoutInvitation {
    OWSAbstractMethod();
    
    return YES;
}

// Override in ContactThread
- (nullable NSString *)contactIdentifier
{
    return nil;
}

// Override in ContactThread
- (nullable NSString *)contactIdentifier_callNumber {
    return nil;
}

// Override in ContactThread
- (nullable NSArray<NSString *> *)contactIdentifier_containMac_callNumbers {
    return nil;
}

- (NSString *)nameWithTransaction:(nullable SDSAnyReadTransaction *)transaction {
    OWSAbstractMethod();

    return nil;
}

- (NSString *)debugName {
    OWSAbstractMethod();
    
    return nil;
}

- (NSArray<NSString *> *)recipientIdentifiers
{
    OWSAbstractMethod();

    return @[];
}

- (BOOL)recipientsContainsBot {
    OWSAbstractMethod();
    
    return NO;
}

- (BOOL)isNoteToSelf
{
    return NO;
}

- (BOOL)isNoteToSelfWithTransaction:(SDSAnyReadTransaction *)transaction{
    return NO;
}

- (NSArray<NSString *> *)recipientIdentifiers_containMac_callNumbers {
    return @[];
}


- (BOOL)hasSafetyNumbers
{
    return NO;
}

#pragma mark Interactions

- (void)markAllAsReadWithTransaction:(SDSAnyWriteTransaction *)transaction {
        
    InteractionFinder *finder = [[InteractionFinder alloc] initWithThreadUniqueId:self.uniqueId];
    TSInteraction *interaction = [finder latestUnseenInteractionWithTransaction:transaction];
    if(interaction){
        
        NSData *groupId = nil;
        if(self.isGroupThread){
            groupId = ((TSGroupThread *)self).groupModel.groupId;
        }
        DTReadPositionEntity *readPosition = [[DTReadPositionEntity alloc] initWithGroupId:groupId
                                                                                    readAt:[NSDate ows_millisecondTimeStamp]
                                                                             maxServerTime:interaction.serverTimestamp
                                                                          notifySequenceId:interaction.notifySequenceId
                                                                             maxSequenceId:interaction.sequenceId];
        
        OWSLogInfo(@"markAllAsRead sendReadRecipet:%@", readPosition);
        [OWSReadReceiptManager.sharedManager sendReadRecipetWithReadPosition:readPosition
                                                                      thread:self
                                                                    wasLocal:YES
                                                                  completion:nil];
    }

}

- (void)updateUnreadMessageCountWithTransaction:(SDSAnyReadTransaction *)transaction {
    _unreadMessageCount = [self getUnreadMessageCountWithTransaction:transaction];
}

- (void)updateUnreadMessageCount:(NSUInteger)count {
    _unreadMessageCount = count;
}

- (NSUInteger)getUnreadMessageCountWithTransaction:(SDSAnyReadTransaction *)transaction {
    InteractionFinder *finder = [[InteractionFinder alloc] initWithThreadUniqueId:self.uniqueId];
//    TSThread *instance = [TSThread anyFetchWithUniqueId:self.uniqueId transaction:transaction];
    DTReadPositionEntity *readPosition = self.readPositionEntity;
    return [finder unreadCountWithReadPosition:readPosition transaction:transaction];
}


- (nullable TSInteraction *)lastInteractionForInboxWithTransaction:(SDSAnyReadTransaction *)transaction
{
    OWSAssertDebug(transaction);
    return [[[InteractionFinder alloc] initWithThreadUniqueId:self.uniqueId]
            mostRecentInteractionForInboxWithTransaction:transaction];
}

- (nullable NSString *)atPersonsInteractionWithTransaction:(SDSAnyReadTransaction *)transaction {
    if(self.mentionedMeMsg.timestampForSorting > self.readPositionEntity.maxServerTime){
        return [[TSAccountManager shared] localNumberWithTransaction:transaction];
    }else if (self.mentionedAllMsg.timestampForSorting > self.readPositionEntity.maxServerTime){
        return @"MENTIONS_ALL";
    }
    return nil;
}


- (nullable NSDate *)lastMessageDate {
    if (_lastMessageDate && [_lastMessageDate isKindOfClass:NSDate.class]) {
        
        return _lastMessageDate;
    } else {
       
        return _creationDate ? : [NSDate date];
    }
}

- (nullable TSMessage *)previousMessageWithTransaction:(nullable SDSAnyReadTransaction *)transaction
{
    if (!transaction) return nil;
    
    TSInteraction *interaction = [self lastInteractionForInboxWithTransaction:transaction];
    if(!interaction || ![interaction isKindOfClass:[TSMessage class]]){
        OWSLogInfo(@"last interaction is empty!");
        return nil;
    }

    return (TSMessage *)interaction;
}

- (NSString *)lastMessageTextWithTransaction:(nullable SDSAnyReadTransaction *)transaction
{
    /*
    TSInteraction *interaction = nil;
    if(!self.lastMessageDate){
        interaction = self.lastestMsg;
    }else{
        if(self.lastestMsg && [self.lastestMsg.dateForSorting timeIntervalSinceDate:self.lastMessageDate] > 0){
            interaction = self.lastestMsg;
        }else{
            interaction = [self lastInteractionForInboxWithTransaction:transaction];
            if(interaction && self.lastestMsg && [self.lastestMsg.dateForSorting timeIntervalSinceDate:interaction.dateForSorting] > 0){
                interaction = self.lastestMsg;
            }
        }
    }
     */
    
    if (!transaction) return @"";
    
    TSInteraction *interaction = self.lastestMsg;
    if(!interaction){
        interaction = [self lastInteractionForInboxWithTransaction:transaction];
        OWSLogInfo(@"get lastInteraction : %llu", interaction.timestampForSorting);
    }
    
    NSString *previewString = @"";
    if ([interaction conformsToProtocol:@protocol(OWSPreviewText)]) {
        id<OWSPreviewText> previewable = (id<OWSPreviewText>)interaction;
        previewString = [previewable previewTextWithTransaction:transaction].filterStringForDisplay;
    }
    
//    NSString *name = [self nameWithTransaction:transaction];
//    OWSLogInfo(@"lastMessageText thread.name = %@, self.lastestMsg.date = %@, preview interaction = %llu, self.lastMessageDate = %@",name , self.lastestMsg.dateForSorting, interaction.timestampForSorting, self.lastMessageDate);
    return previewString;
}

- (nullable NSString *)atPersonsWithTransaction:(nullable SDSAnyReadTransaction *)transaction{
    if (!transaction) return nil;
    NSString *atPersonsString = [self atPersonsInteractionWithTransaction:transaction];
    return atPersonsString;
}

// Returns YES IFF the interaction should show up in the inbox as the last message.
+ (BOOL)shouldInteractionAppearInInbox:(TSInteraction *)interaction
{
    OWSAssertDebug(interaction);

    if (![interaction isKindOfClass:TSInteraction.class]) {
        return NO;
    }
    
    if (!interaction.shouldBeSaved) {
        return NO;
    }
    
    if (interaction.isDynamicInteraction) {
        OWSFailDebug(@"Unexpected interaction type: %@", interaction.class);
        return NO;
    }
    
    if ([interaction isKindOfClass:[OWSOutgoingSyncMessage class]]) {
        OWSFailDebug(@"Unexpected interaction type: %@", interaction.class);
        return NO;
    }
    
    if ([interaction isKindOfClass:[TSIncomingMessage class]] || [interaction isKindOfClass:[TSOutgoingMessage class]]) {
        TSMessage *message = (TSMessage *)interaction;
        return YES;
    }

    if ([interaction isKindOfClass:[TSErrorMessage class]]) {
        TSErrorMessage *errorMessage = (TSErrorMessage *)interaction;
        if (errorMessage.errorType == TSErrorMessageNonBlockingIdentityChange) {
            // Otherwise all group threads with the recipient will percolate to the top of the inbox, even though
            // there was no meaningful interaction.
            return NO;
        }
    } else if ([interaction isKindOfClass:[TSInfoMessage class]]) {
        TSInfoMessage *infoMessage = (TSInfoMessage *)interaction;
        if (infoMessage.messageType == TSInfoMessageVerificationStateChange ) {
            return NO;
        }
    } else if ([interaction isKindOfClass:[OWSDisappearingMessagesConfigurationMessage class]]) {
        return NO;
    }

    return YES;
}

+ (BOOL)shouldInteractionAppearAtPersons:(TSInteraction *)interaction
{
    OWSAssertDebug(interaction);

    if (![interaction isKindOfClass:[TSIncomingMessage class]]) {
        return NO;
    }
    
    if (interaction.isDynamicInteraction) {
        return NO;
    }

    if ([interaction isKindOfClass:[TSErrorMessage class]]) {
        TSErrorMessage *errorMessage = (TSErrorMessage *)interaction;
        if (errorMessage.errorType == TSErrorMessageNonBlockingIdentityChange) {
            // Otherwise all group threads with the recipient will percolate to the top of the inbox, even though
            // there was no meaningful interaction.
            return NO;
        }
    } else if ([interaction isKindOfClass:[TSInfoMessage class]]) {
        TSInfoMessage *infoMessage = (TSInfoMessage *)interaction;
        if (infoMessage.messageType == TSInfoMessageVerificationStateChange) {
            return NO;
        }
    }

    return YES;
}

- (BOOL)checkLastMsgTimestampForSortingChanged:(TSInteraction *)lastMessage
                               lastMessageDate:(NSDate *)lastMessageDate{
    if([self checkIsTheSameMessage:lastMessage]){
        if(!self.lastestMsg.dateForSorting ||
           [lastMessageDate timeIntervalSinceDate:self.lastestMsg.dateForSorting] != 0){
            return YES;
        }
    }
    return NO;
}

- (BOOL)checkIsTheSameMessage:(TSInteraction *)lastMessage {
    if(self.lastestMsg.uniqueId.length &&
       [lastMessage.uniqueId isEqualToString:self.lastestMsg.uniqueId]){
        return YES;
    }
    return NO;
}

- (void)updateWithLastMessage:(TSInteraction *)lastMessage isInserted:(BOOL)isInserted transaction:(SDSAnyWriteTransaction *)transaction {
    OWSAssertDebug(lastMessage);
    OWSAssertDebug(transaction);
    
    OWSLogInfo(@"updateWithLastMessage start %llu", lastMessage.timestampForSorting);
    
    NSDate *lastMessageDate = [lastMessage dateForSorting];
    
    // 异常
    if(!lastMessageDate){
        NSString *author = @"";
        if([lastMessage isKindOfClass:[TSOutgoingMessage class]]){
            author = @"local";
        }else if([lastMessage isKindOfClass:[TSIncomingMessage class]]){
            author = ((TSIncomingMessage *)lastMessage).authorId;
        }
        OWSLogError(@"message date is nil!");
        return;
    }
    
    //更新非撤回消息，并且同一条消息时间没有变化，onlyNeedTouch = YES；
    BOOL onlyNeedTouch = NO;
    BOOL msgTimestampForSortingChanged = NO;
    if(!isInserted){
        
        msgTimestampForSortingChanged = [self checkLastMsgTimestampForSortingChanged:lastMessage lastMessageDate:lastMessageDate];
        
        if(!([lastMessage isKindOfClass:[TSMessage class]] && [((TSMessage *)lastMessage) isRecalMessage]) &&
           !msgTimestampForSortingChanged &&
           !([lastMessage isKindOfClass:[TSMessage class]] && ((TSMessage *)lastMessage).cardVersion > self.lastestMsg.cardVersion)){
            onlyNeedTouch = YES;
        }
    }
    
    if (![self.class shouldInteractionAppearInInbox:lastMessage] || onlyNeedTouch) {
        
        OWSLogInfo(@"updateWithLastMessage touch %llu", lastMessage.timestampForSorting);
        
        [self scheduleTouchFinalizationWithTransaction:transaction];
        return;
    }
    
    __block NSUInteger count = 0;
    BOOL shouldAffectThreadSorting = YES;
    if([lastMessage isKindOfClass:[TSInfoMessage class]] && !((TSInfoMessage *)lastMessage).shouldAffectThreadSorting){
        shouldAffectThreadSorting = NO;
    }
    [self anyUpdateWithTransaction:transaction
                             block:^(TSThread * instance) {
        if(shouldAffectThreadSorting &&
           (!instance.lastMessageDate ||
            [instance.lastMessageDate isEqualToDate:instance.creationDate] ||
            [lastMessageDate timeIntervalSinceDate:instance.lastMessageDate] > 0)){
            instance.lastMessageDate = lastMessageDate;
            [instance resetIsArchivedColum];
            if (count == 1){
                OWSLogInfo(@"updateWithLastMessage update lastMessageDate %llu", lastMessage.timestampForSorting);
            }
        }
        
        NSTimeInterval msgTimeIntervalDiff = [lastMessageDate timeIntervalSinceDate:instance.lastestMsg.dateForSorting];
        
        if(!instance.lastestMsg.dateForSorting ||
           msgTimeIntervalDiff >= 0 ||
           (!isInserted && [instance checkIsTheSameMessage:lastMessage] && msgTimeIntervalDiff != 0)){
            if (((TSMessage *)lastMessage).isRecalMessage) {
                instance.lastestMsg = [self previousMessageWithTransaction:transaction];
            } else {
                instance.lastestMsg = (TSMessage *)lastMessage;
            }
            if (count == 1){
                OWSLogInfo(@"updateWithLastMessage update lastestMsg %llu", lastMessage.timestampForSorting);
            }
        }
        instance.hasEverHadMessage = YES;
        instance.shouldBeVisible = YES;
        instance.removedFromConversation = NO;
        [instance updateLatestMentionedMsg:lastMessage];
        if (count == 1){
            NSUInteger unreadCount = [instance getUnreadMessageCountWithTransaction:transaction];
            [instance updateUnreadMessageCount:unreadCount];
        }
        count++;
    }];
}

/*
- (void)updateUnreadMessageCountWithLastMessage:(TSInteraction *)lastMessage transaction:(SDSAnyWriteTransaction *)transaction{
    if ([lastMessage conformsToProtocol:@protocol(OWSReadTracking)]) {
        id<OWSReadTracking> lastMessageShadow = (id<OWSReadTracking>)lastMessage;
        
        if ([lastMessageShadow shouldAffectUnreadCounts]) {
            
            if(lastMessage.timestampForSorting > self.readPositionEntity.maxServerTime){
                _unreadMessageCount += 1;
            }
        } else if([lastMessage isKindOfClass:[TSMessage class]] && [((TSMessage *)lastMessage) isRecalMessage]){
            TSMessage *originMsg = [TSMessage anyFetchMessageWithUniqueId:lastMessage.uniqueId transaction:transaction];
            if(originMsg && [originMsg isKindOfClass:[TSIncomingMessage class]] && originMsg.timestampForSorting > self.readPositionEntity.maxServerTime){
                if(_unreadMessageCount > 0){
                    _unreadMessageCount -= 1;
                }
            }
        }
    }
}
 */

- (void)refreshLatestMentionedMsg{
    if(_mentionedMeMsg.timestampForSorting <= self.readPositionEntity.maxServerTime){
        _mentionedMeMsg = nil;
    }
    if(_mentionedAllMsg.timestampForSorting <= self.readPositionEntity.maxServerTime){
        _mentionedAllMsg = nil;
    }
}

- (void)updateLatestMentionedMsg:(TSInteraction *)interaction {
    
    if([interaction isKindOfClass:[TSMessage class]] && [((TSMessage *)interaction) isRecalMessage]){
        if(DTParamsUtils.validateString(_mentionedMeMsg.uniqueMessageId) &&
           [interaction.uniqueId isEqualToString:_mentionedMeMsg.uniqueMessageId]){
            _mentionedMeMsg = nil;
        }else if (DTParamsUtils.validateString(_mentionedAllMsg.uniqueMessageId) &&
                  [interaction.uniqueId isEqualToString:_mentionedAllMsg.uniqueMessageId]){
            _mentionedAllMsg = nil;
        }
        
        return;
    }
    
    if (![interaction isKindOfClass:[TSIncomingMessage class]]) return;
    
    TSIncomingMessage *msg = (TSIncomingMessage *)interaction;
    
    //已读
    if(msg.timestampForSorting <= self.readPositionEntity.maxServerTime){
        return;
    }
    
    if(msg.mentionedMsgType == OWSMentionedMsgTypeMe){
        if(_mentionedMeMsg.timestampForSorting < msg.timestampForSorting){
            _mentionedMeMsg = [[DTMentionedMsgInfo alloc] initWithUniqueMessageId:msg.uniqueId
                                                              timestampForSorting:msg.timestampForSorting];
        }
    } else if (msg.mentionedMsgType == OWSMentionedMsgTypeAll){
        if(_mentionedAllMsg.timestampForSorting < msg.timestampForSorting){
            _mentionedAllMsg = [[DTMentionedMsgInfo alloc] initWithUniqueMessageId:msg.uniqueId
                                                              timestampForSorting:msg.timestampForSorting];
        }
    }
    
}

- (void)scheduleTouchFinalizationWithTransaction:(SDSAnyWriteTransaction *)transactionForMethod
{
    OWSAssertDebug(transactionForMethod != nil);

    // If we insert, update or remove N interactions in a given
    // transactions, we don't need to touch the same thread more
    // than once.
    
    if(!self.grdbId) return;
    
    [transactionForMethod addTransactionFinalizationBlockForKey:self.transactionFinalizationKey
                                                          block:^(SDSAnyWriteTransaction *transactionForBlock) {
                                                              [self.databaseStorage touchThread:self
                                                                                  shouldReindex:NO
                                                                                    transaction:transactionForBlock];
                                                          }];
}

#pragma mark Disappearing Messages

- (uint32_t)messageExpiresInSeconds{
    
    uint32_t interval = 0;
    DTDisappearanceTimeIntervalEntity *entity = [DTDisappearanceTimeIntervalConfig fetchDisappearanceTimeInterval];
    if(self.isNoteToSelf){
        interval = [entity.messageMe unsignedIntValue];
    }else{
        NSNumber *messageExpiry = self.threadConfig.messageExpiry;
        if(!messageExpiry || messageExpiry.doubleValue < 0){
            
            if (self.isGroupThread) {
                
                interval = [entity.messageGroup unsignedIntValue];
            } else {
                interval = [entity.messageOthers unsignedIntValue];
            }
        } else{
            interval = messageExpiry.unsignedIntValue;
        }
    }
    
    return interval;
}

- (uint32_t)messageExpiresInSecondsWithTransaction:(SDSAnyReadTransaction *)transaction {
    uint32_t interval = 0;
    DTDisappearanceTimeIntervalEntity *entity = [DTDisappearanceTimeIntervalConfig fetchDisappearanceTimeInterval];
    if([self isNoteToSelfWithTransaction:transaction]){
        interval = [entity.messageMe unsignedIntValue];
    }else{
        NSNumber *messageExpiry = self.threadConfig.messageExpiry;
        if(!messageExpiry || messageExpiry.doubleValue < 0){
            
            if (self.isGroupThread) {
                
                interval = [entity.messageGroup unsignedIntValue];
            } else {
                interval = [entity.messageOthers unsignedIntValue];
            }
        }else{
            interval = messageExpiry.unsignedIntValue;
        }
    }
    
    return interval;
}

#pragma mark Archival

- (nullable NSDate *)archivalDate
{
    return _archivalDate;
}

- (void)archiveThreadWithTransaction:(SDSAnyWriteTransaction *)transaction {
    
    return;
    
    [self markAllAsReadWithTransaction:transaction];
    
    _messageDraft = @"";
    _stickDate = nil;
    self.archivalDate = [NSDate date];
    [self resetIsArchivedColum];
}

- (void)archiveOversizeThreadWithTransaction:(SDSAnyWriteTransaction *)transaction {
    _messageDraft = @"";
    _stickDate = nil;
    self.archivalDate = [NSDate date];
    [self resetIsArchivedColum];
}

- (void)unarchiveThread {
    self.archivalDate = nil;
    [self resetIsArchivedColum];
}

#pragma mark Drafts

- (NSString *)currentDraftWithTransaction:(SDSAnyReadTransaction *)transaction {
    TSThread *thread = [TSThread anyFetchWithUniqueId:self.uniqueId
                                          transaction:transaction];
    if (thread.messageDraft) {
        return thread.messageDraft;
    } else {
        return @"";
    }
}

- (void)setDraft:(nullable NSString *)draftString transaction:(SDSAnyWriteTransaction *)transaction {
    
    [self anyUpdateWithTransaction:transaction
                               block:^(TSThread * instance) {
        if (draftString && draftString.length) {
            NSDate *newDate = [NSDate date];
            if(!self.lastMessageDate || [newDate timeIntervalSinceDate:self.lastMessageDate] > 0){
                instance.lastMessageDate = newDate;
            }
        }
        instance.messageDraft = draftString;
    }];
}

- (TSMessage *)currentDraftQuoteMessageWithTransaction:(SDSAnyReadTransaction *)transaction {
    TSMessage *message = [TSMessage anyFetchMessageWithUniqueId:self.draftQuoteMessageId transaction:transaction];
    return message;
}

- (void)setDraftQuoteMessageId:(NSString *)messageId transaction:(SDSAnyWriteTransaction *)transaction {
    
    [self anyUpdateWithTransaction:transaction
                             block:^(TSThread * instance) {
        instance.draftQuoteMessageId = messageId;
    }];
}

- (void)setMentionsDraft:(NSArray <DTMention *> *)mentionsDraft
            transaction:(SDSAnyWriteTransaction *)transaction {
    
    [self anyUpdateWithTransaction:transaction
                               block:^(TSThread * instance) {
        instance.mentionsDraft = mentionsDraft;
    }];
}

- (NSArray <DTMention *> *)currentMentionsDraftWithTransaction:(SDSAnyReadTransaction *)transaction {
    TSThread *thread = [TSThread anyFetchWithUniqueId:self.uniqueId
                                          transaction:transaction];
    if (thread.mentionsDraft) {
        return thread.mentionsDraft;
    }
      
    return @[];
}
 
- (void)clearDraftWithTransaction:(SDSAnyWriteTransaction *)transaction {
    if (DTParamsUtils.validateString(self.messageDraft)) {
        [self setDraft:@"" transaction:transaction];
    }
    if (DTParamsUtils.validateArray(self.mentionsDraft)) {
        [self setMentionsDraft:@[] transaction:transaction];
    }
    if (DTParamsUtils.validateString(self.draftQuoteMessageId)) {
        [self setDraftQuoteMessageId:@"" transaction:transaction];
    }
}

- (void)clearDraft {
    if (DTParamsUtils.validateString(self.messageDraft)) {
        _messageDraft = @"";
    }
    if (DTParamsUtils.validateString(self.draftQuoteMessageId)) {
        _draftQuoteMessageId = @"";
    }
    if (DTParamsUtils.validateArray(self.mentionsDraft)) {
        _mentionsDraft = @[];
    }
}

#pragma mark - Muted

- (BOOL)isMuted {
    if (!self.conversationEntity) { return false;}
    if (self.conversationEntity && self.conversationEntity.muteStatus == 1) {return true;}
    return false;
}

- (BOOL)isBlocked {
    if (!self.conversationEntity) { return false;}
    if (self.conversationEntity && self.conversationEntity.blockStatus == 1) {return true;}
    return false;
}

- (void)updateWithMutedUntilDate:(NSDate *)mutedUntilDate transaction:(SDSAnyWriteTransaction *)transaction
{
    [self anyUpdateWithTransaction:transaction
                             block:^(TSThread * thread) {
        [thread setMutedUntilDate:mutedUntilDate];
    }];
}

//MARK: Sticky on top

- (nullable NSDate *)stickDate
{
    return _stickDate;
}

- (BOOL)isSticked
{
    NSDate *stickDate = _stickDate;
    return stickDate != nil;
}

- (void)unstickThreadWithTransaction:(SDSAnyWriteTransaction *)transaction {
    _stickDate = nil;
    [self unstickThreadWithTransaction:transaction referenceDate:[NSDate date]];
}

- (void)unstickThreadWithTransaction:(SDSAnyWriteTransaction *)transaction referenceDate:(NSDate *)date {
//    [self markAllAsReadWithTransaction:transaction];
    NSDate *newDate = [NSDate date];
    [self anyUpdateWithTransaction:transaction
                             block:^(TSThread * instance) {
        if(!instance.lastMessageDate || [newDate timeIntervalSinceDate:instance.lastMessageDate] > 0){
            instance.lastMessageDate = date;
        }
    }];
}

- (void)stickThread {
    NSDate *date = [NSDate date];
    _stickDate = date;
    if(!self.lastMessageDate || [date timeIntervalSinceDate:self.lastMessageDate] > 0){
        self.lastMessageDate = date;
    }
    _shouldBeVisible = YES;
}

- (void)unstickThread {
    NSDate *date = [NSDate date];
    _stickDate = nil;
    if(!self.lastMessageDate || [date timeIntervalSinceDate:self.lastMessageDate] > 0){
        self.lastMessageDate = date;
    }
    _shouldBeVisible = YES;
}

// 0: 清除设定的未读状态 1、 未读 2、全部已读
- (BOOL)isUnread {
    return _unreadFlag == 1;
}

// MARK: Sticky call on top

- (nullable NSDate *)stickCallingDate
{
    return _stickCallingDate;
}

- (BOOL)isCallingSticked
{
    NSDate *stickDate = self.stickCallingDate;
    return stickDate != nil;
}

- (void)stickCallingThreadWithTransaction:(SDSAnyWriteTransaction *)transaction {
    [self stickCallingThreadWithTransaction:transaction referenceDate:[NSDate date]];
    
    OWSLogInfo(@"[call] stick: %@", self.uniqueId);
}

- (void)stickCallingThreadWithTransaction:(SDSAnyWriteTransaction *)transaction referenceDate:(NSDate *)date {
    
    [self anyUpdateWithTransaction:transaction
                             block:^(TSThread * thread) {
        thread ->  _stickCallingDate = date;
    }];
    
}

- (void)unstickCallingThread {
    
    self.stickCallingDate = nil;
}

- (void)unstickCallingThreadWithTransaction:(SDSAnyWriteTransaction *)transaction {
    
    [self anyUpdateWithTransaction:transaction
                             block:^(TSThread * thread) {
        thread ->  _stickCallingDate = nil;
    }];
    
    OWSLogInfo(@"[call] unstick: %@", self.uniqueId);
}

#pragma mark - Conversation Color

+ (NSString *)randomConversationColorName
{
    NSUInteger count = self.conversationColorNames.count;
    NSUInteger index = arc4random_uniform((uint32_t)count);
    return [self.conversationColorNames objectAtIndex:index];
}

+ (NSString *)stableConversationColorNameForString:(NSString *)colorSeed
{
    //MARK: 末位不是数字, 获取末位字符ascii, 取ascii末位数字
    NSInteger hash = 1;
    NSUInteger index = 5;
    
//    BOOL useColor = [colorSeed hasPrefix:@"+"] || [colorSeed hasPrefix:MeetingAccoutPrefix_Web] || [colorSeed containsString:@"@"];
    if ([colorSeed isKindOfClass:NSString.class] && colorSeed.length >= 1) {
        NSString *targetDig = nil;
        if ([colorSeed containsString:@"@"]) {
            targetDig = [colorSeed substringWithRange:NSMakeRange(0, 1)];
        } else {
            targetDig = [colorSeed substringWithRange:NSMakeRange(colorSeed.length - 1, 1)];
        }
        unichar targetChar = [targetDig characterAtIndex:0];
        if (!isdigit(targetChar)) {
            NSString *ascii = [NSString stringWithFormat:@"%d", targetChar];
            targetDig = [ascii substringWithRange:NSMakeRange(ascii.length - 1, 1)];
        }
        hash = targetDig.integerValue;
        index = (hash % 10);
    }
    
    return [self.conversationColorNames objectAtIndex:index];
}

+ (NSString *)conversationSourcePersonColorNameFromString:(NSString *)colorSeed{
    NSInteger hash = 1;
    if ([colorSeed isKindOfClass:NSString.class] && colorSeed.length >= 1) {
        NSString *lastTwoDig = [colorSeed substringWithRange:NSMakeRange(colorSeed.length-2, 2)];

        hash = strtoul([lastTwoDig UTF8String],0,16);
    }

    NSUInteger index = (hash % 10);
    return [self.conversationColorNames objectAtIndex:index];
}

+ (NSUInteger)conversationColorNamesCount {
    return self.conversationColorNames.count;
}


+ (NSString *) topicColorName:(uint32_t) topicColor {
    
    if (self.conversationColorNames.count > topicColor) {
        return self.conversationColorNames[topicColor];
    }
    
    return @"color1";
}


+ (NSString *)conversationSourceGroupColorNameFromString:(NSString *)colorSeed {
    NSInteger hash = 1;
    if ([colorSeed isKindOfClass:NSString.class] && colorSeed.length >= 1) {
        NSString *lastTwoDig = [colorSeed substringWithRange:NSMakeRange(colorSeed.length-2, 1)];
        NSData *data =[lastTwoDig dataUsingEncoding:NSUTF8StringEncoding];
        NSString *hexString  = [data hexadecimalString];
        hash = strtoul([hexString UTF8String],0,16);
    }

    NSUInteger index = (hash % 10);
    return [self.conversationThreadColorNames objectAtIndex:index];
}

+ (NSArray<NSString *> *)conversationThreadColorNames
{
    return @[
        @"color1",
        @"color2",
        @"color3",
        @"color4",
        @"color5",
        @"color6",
        @"color7",
        @"color8",
        @"color9",
        @"color10",
    ];
}

+ (NSArray<NSString *> *)conversationColorNames
{
    return @[
        @"color1",
        @"color2",
        @"color3",
        @"color4",
        @"color5",
        @"color6",
        @"color7",
        @"color8",
        @"color9",
        @"color10",
    ];
}

#pragma mark - server thread id

- (NSString *)serverThreadId {
    OWSAbstractMethod();

    return nil;
}

- (void)resetIsArchivedColum{
    
    BOOL previousStatus = _isArchived;
    
    NSDate *lastMessageDate = self.lastMessageDate;
    NSDate *archivalDate    = self.archivalDate;
    if (lastMessageDate && archivalDate) {
        _isArchived = ([archivalDate timeIntervalSinceDate:lastMessageDate] > 0) ? YES : NO;
    } else if (archivalDate) {
        _isArchived = YES;
    }else{
        _isArchived = NO;
    }
    
    if(_isArchived != previousStatus){
        self.isArchived = _isArchived;
    }
}

- (void)updateReadPositionEntity:(DTReadPositionEntity *)readPositionEntity {
    
    OWSLogInfo(@"will updateReadPositionEntity:%@", readPositionEntity);
    if(readPositionEntity.maxServerTime &&
       readPositionEntity.maxServerTime >= _readPositionEntity.maxServerTime){
        OWSLogInfo(@"did updateReadPositionEntity:%@", readPositionEntity);
        self.readPositionEntity = readPositionEntity;
        [self refreshLatestMentionedMsg];
    }
    
}

- (BOOL)previewEqualTo:(id)objc {
    
    if(self == objc) return YES;
    
    if(![objc isKindOfClass:[TSThread class]]) return NO;
    
    TSThread *rObjc = (TSThread *)objc;
    
    if(self.isArchived == rObjc.isArchived &&
       self.isUnread == rObjc.isUnread &&
       ((!self.lastestMsg.uniqueId && !rObjc.lastestMsg.uniqueId) || [self.lastestMsg.uniqueId isEqualToString:rObjc.lastestMsg.uniqueId]) &&
       self.lastestMsg.isRecalMessage == rObjc.lastestMsg.isRecalMessage &&
       (self.unreadMessageCount == rObjc.unreadMessageCount ||
        [[OWSFormat formatIntMax99:self.unreadMessageCount] isEqualToString:[OWSFormat formatIntMax99:rObjc.unreadMessageCount]]) &&
       ((!self.lastMessageDate && !rObjc.lastMessageDate) || [self.lastMessageDate isEqualToDate:rObjc.lastMessageDate]) &&
       ((!self.stickCallingDate && !rObjc.stickCallingDate) || [self.stickCallingDate isEqualToDate:rObjc.stickCallingDate]) &&
       self.shouldBeVisible == rObjc.shouldBeVisible &&
       self.hasEverHadMessage == rObjc.hasEverHadMessage &&
       ((!self.mentionedMeMsg && !rObjc.mentionedMeMsg) || [self.mentionedMeMsg isEqual:rObjc.mentionedMeMsg]) &&
       ((!self.mentionedAllMsg && !rObjc.mentionedAllMsg) || [self.mentionedAllMsg isEqual:rObjc.mentionedAllMsg]) &&
       (self.lastestMsg.cardVersion == rObjc.lastestMsg.cardVersion && [self.lastestMsg.cardUniqueId isEqualToString:rObjc.lastestMsg.cardUniqueId]) &&
       self.conversationEntity.muteStatus == rObjc.conversationEntity.muteStatus){
        return YES;
    }
    return NO;
}

#pragma - hook

- (ThreadReadCache *)threadReadCache
{
    return SSKEnvironment.shared.modelReadCaches.threadReadCache;
}

- (void)anyUpdateThread{
    if(self.lastestMsg && !self.lastestMsg.grdbId){
        [self.lastestMsg updateRowId:100];
    }
}

- (void)anyWillInsertWithTransaction:(SDSAnyWriteTransaction *)transaction {
    [super anyWillInsertWithTransaction:transaction];
    [self anyUpdateThread];
}

- (void)anyWillUpdateWithTransaction:(SDSAnyWriteTransaction *)transaction {
    [super anyWillUpdateWithTransaction:transaction];
    [self anyUpdateThread];
}

- (void)anyDidInsertWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyDidInsertWithTransaction:transaction];

    [self.threadReadCache didInsertOrUpdateThread:self transaction:transaction];
}

- (void)anyDidUpdateWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyDidUpdateWithTransaction:transaction];

    [self.threadReadCache didInsertOrUpdateThread:self transaction:transaction];
}

- (void)anyDidRemoveWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyDidRemoveWithTransaction:transaction];

    [self.threadReadCache didRemoveThread:self transaction:transaction];
}

- (void)anyWillRemoveWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    
    [SDSDatabaseStorage.shared updateIdMappingWithThread:self transaction:transaction];
    
    [super anyWillRemoveWithTransaction:transaction];

    [self removeAllThreadInteractionsWithTransaction:transaction];

    // TODO: If we ever use transaction finalizations for more than
    // de-bouncing thread touches, we should promote this to TSYapDatabaseObject
    // (or at least include it in the "will remove" hook for any relevant models.
    [transaction addRemovedFinalizationKey:self.transactionFinalizationKey];
}

- (void)updateWithInsertedMessage:(TSInteraction *)message transaction:(SDSAnyWriteTransaction *)transaction
{
    [self updateWithLastMessage:message isInserted:YES transaction:transaction];
}

- (void)updateWithUpdatedMessage:(TSInteraction *)message transaction:(SDSAnyWriteTransaction *)transaction
{
//    if([message isKindOfClass:[TSMessage class]] && [((TSMessage *)message) isRecalMessage]){
    [self updateWithLastMessage:message isInserted:NO transaction:transaction];
//    }
}

- (void)updateWithRemovedMessage:(TSInteraction *)message transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(message != nil);
    OWSAssertDebug(transaction != nil);
    
    if([message.uniqueId isEqualToString:self.lastestMsg.uniqueId]){
        OWSLogInfo(@"update thread lastInteraction.");
        TSInteraction *interaction = [self lastInteractionForInboxWithTransaction:transaction];
        [self anyUpdateWithTransaction:transaction
                                 block:^(TSThread * instance) {
            instance.lastestMsg = (TSMessage *)interaction;
        }];
    }else{
        [self scheduleTouchFinalizationWithTransaction:transaction];
    }
}

+ (TSFTSIndexMode)FTSIndexMode
{
    return TSFTSIndexModeAlways;
}

@end

NS_ASSUME_NONNULL_END
