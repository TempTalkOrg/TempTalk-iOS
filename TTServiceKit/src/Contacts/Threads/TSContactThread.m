//
//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.
//

#import "TSContactThread.h"
#import "ContactsManagerProtocol.h"
#import "ContactsUpdater.h"
#import "NotificationsProtocol.h"
#import "OWSIdentityManager.h"
#import "TextSecureKitEnv.h"
#import "TSAccountManager.h"
#import "SignalAccount.h"
#import "DTParamsBaseUtils.h"
#import <TTServiceKit/TTServiceKit-swift.h>

NS_ASSUME_NONNULL_BEGIN

#define TSContactThreadPrefix @"c"

@implementation TSContactThread

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
                    archivalDate:(nullable NSDate *)archivalDate
              conversationEntity:(nullable DTConversationEntity *)conversationEntity
                    creationDate:(NSDate *)creationDate
             draftQuoteMessageId:(nullable NSString *)draftQuoteMessageId
                expiresInSeconds:(unsigned long long)expiresInSeconds
               hasEverHadMessage:(BOOL)hasEverHadMessage
                      isArchived:(BOOL)isArchived
                 lastMessageDate:(nullable NSDate *)lastMessageDate
                      lastestMsg:(nullable TSMessage *)lastestMsg
                 mentionedAllMsg:(nullable DTMentionedMsgInfo *)mentionedAllMsg
                  mentionedMeMsg:(nullable DTMentionedMsgInfo *)mentionedMeMsg
                   mentionsDraft:(nullable NSArray<DTMention *> *)mentionsDraft
              messageClearAnchor:(unsigned long long)messageClearAnchor
                    messageDraft:(nullable NSString *)messageDraft
                  mutedUntilDate:(nullable NSDate *)mutedUntilDate
                 plainTextEnable:(BOOL)plainTextEnable
              readPositionEntity:(nullable DTReadPositionEntity *)readPositionEntity
         removedFromConversation:(BOOL)removedFromConversation
                 shouldBeVisible:(BOOL)shouldBeVisible
                stickCallingDate:(nullable NSDate *)stickCallingDate
                       stickDate:(nullable NSDate *)stickDate
                    threadConfig:(nullable DTThreadConfigEntity *)threadConfig
            translateSettingType:(nullable NSNumber *)translateSettingType
                      unreadFlag:(unsigned int)unreadFlag
              unreadMessageCount:(NSUInteger)unreadMessageCount
                     unreadState:(NSUInteger)unreadState
            unreadTimeStimeStamp:(unsigned long long)unreadTimeStimeStamp
            friendContactVersion:(NSInteger)friendContactVersion
              hasDismissedOffers:(BOOL)hasDismissedOffers
               receivedFriendReq:(BOOL)receivedFriendReq
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId
                      archivalDate:archivalDate
                conversationEntity:conversationEntity
                      creationDate:creationDate
               draftQuoteMessageId:draftQuoteMessageId
                  expiresInSeconds:expiresInSeconds
                 hasEverHadMessage:hasEverHadMessage
                        isArchived:isArchived
                   lastMessageDate:lastMessageDate
                        lastestMsg:lastestMsg
                   mentionedAllMsg:mentionedAllMsg
                    mentionedMeMsg:mentionedMeMsg
                     mentionsDraft:mentionsDraft
                messageClearAnchor:messageClearAnchor
                      messageDraft:messageDraft
                    mutedUntilDate:mutedUntilDate
                   plainTextEnable:plainTextEnable
                readPositionEntity:readPositionEntity
           removedFromConversation:removedFromConversation
                   shouldBeVisible:shouldBeVisible
                  stickCallingDate:stickCallingDate
                         stickDate:stickDate
                      threadConfig:threadConfig
              translateSettingType:translateSettingType
                        unreadFlag:unreadFlag
                unreadMessageCount:unreadMessageCount
                       unreadState:unreadState
              unreadTimeStimeStamp:unreadTimeStimeStamp];

    if (!self) {
        return self;
    }

    _friendContactVersion = friendContactVersion;
    _hasDismissedOffers = hasDismissedOffers;
    _receivedFriendReq = receivedFriendReq;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

- (instancetype)initWithContactId:(NSString *)contactId {
    NSString *uniqueIdentifier = [[self class] threadIdFromContactId:contactId];

    OWSAssertDebug(contactId.length > 0);

    self = [self initWithUniqueId:uniqueIdentifier];

    return self;
}

+ (instancetype)getOrCreateThreadWithContactId:(NSString *)contactId
                                   transaction:(SDSAnyWriteTransaction *)transaction
                                         relay:(nullable NSString *)relay
{
    OWSAssertDebug(contactId.length > 0);

    SignalRecipient *recipient =
        [SignalRecipient recipientWithTextSecureIdentifier:contactId withTransaction:transaction];

    if (!recipient) {
        // If no recipient record exists for that contactId, create an empty record
        // for immediate use, then ask ContactsUpdater to try to update it async.
        recipient =
            [[SignalRecipient alloc] initWithTextSecureIdentifier:contactId
                                                            relay:relay];
        [recipient anyInsertWithTransaction:transaction];

        // Update recipient with Server record async.
        [[ContactsUpdater sharedUpdater] lookupIdentifier:contactId
            success:^(SignalRecipient *recipient) {
            }
            failure:^(NSError *error) {
                DDLogWarn(@"Failed to lookup contact with error:%@", error);
            }];
    }

    return [self getOrCreateThreadWithContactId:contactId transaction:transaction];
}

+ (instancetype)getOrCreateThreadWithContactId:(NSString *)contactId
                                   transaction:(SDSAnyWriteTransaction *)transaction {
    OWSAssertDebug(contactId.length > 0);

    TSContactThread *thread =
        [self anyFetchContactThreadWithUniqueId:[self threadIdFromContactId:contactId] transaction:transaction];

    if (!thread) {
        thread = [[TSContactThread alloc] initWithContactId:contactId];
        [thread anyInsertWithTransaction:transaction];
    }

    return thread;
}

+ (instancetype)getOrCreateThreadWithContactId:(NSString *)contactId
{
    OWSAssertDebug(contactId.length > 0);

    __block TSContactThread *thread;
    DatabaseStorageWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *transaction) {
        thread = [self getOrCreateThreadWithContactId:contactId transaction:transaction];
    });

    return thread;
}

+ (nullable instancetype)getThreadWithContactId:(NSString *)contactId transaction:(SDSAnyReadTransaction *)transaction;
{
    return [TSContactThread anyFetchContactThreadWithUniqueId:[self threadIdFromContactId:contactId] transaction:transaction];
}

- (NSString *)contactIdentifier {
    return [[self class] contactIdFromThreadId:self.uniqueId];
}

- (NSString *)contactIdentifier_callNumber {
    NSString *contactIdentifier = [self contactIdentifier];
    if ([contactIdentifier hasPrefix:@"+"]) {
        contactIdentifier = [contactIdentifier substringFromIndex:1];
    }
    
    return [NSString stringWithFormat:@"%@%@", MeetingAccoutPrefix_iOS, contactIdentifier];
}

- (nullable NSArray<NSString *> *)contactIdentifier_containMac_callNumbers {
    NSString *contactIdentifier = [self contactIdentifier];
    if (contactIdentifier) {
        return [contactIdentifier transforCallNumberToUserAccounts];
    }
    return nil;
}

- (NSArray<NSString *> *)recipientIdentifiers
{
    return @[self.contactIdentifier];
}

- (BOOL)recipientsContainsBot {
    __block BOOL containsBot = NO;
    [self.recipientIdentifiers enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if(DTParamsUtils.validateString(obj)){
            NSString *numberString = [obj stringByReplacingOccurrencesOfString:@"+"withString:@""];
            if(numberString.length <= 6){
                containsBot = YES;
                *stop = YES;
            }
        }
    }];
    return containsBot;
}

- (BOOL)isGroupThread {
    return false;
}

- (BOOL)isBotThread {
    return self.contactIdentifier.length <= 6;
}

- (BOOL)isLargeGroupThread {
    return NO;
}

- (BOOL)isHavePermissioncanSpeak {
    return YES;
}

- (BOOL)isNoteToSelf
{
    if (!IsNoteToSelfEnabled()) {
        return NO;
    }
    
    NSString *localNumber = [TSAccountManager localNumber];
    if (!localNumber || !localNumber.length) {
        return NO;
    }
    return [self.contactIdentifier isEqualToString:localNumber];
}

- (BOOL)isNoteToSelfWithTransaction:(SDSAnyReadTransaction *)transaction{
    if (!IsNoteToSelfEnabled()) {
        return NO;
    }
    
    NSString *localNumber = [[TSAccountManager sharedInstance] localNumberWithTransaction:transaction];
    if (!localNumber || !localNumber.length) {
        return NO;
    }
    return [self.contactIdentifier isEqualToString:localNumber];
}

- (BOOL)isWithoutReadRecipt {
    return NO;
}

- (BOOL)hasSafetyNumbers
{
    return !![[OWSIdentityManager sharedManager] identityKeyForRecipientId:self.contactIdentifier];
}

// TODO deprecate this? seems weird to access the displayName in the DB model
- (NSString *)nameWithTransaction:(nullable SDSAnyReadTransaction *)transaction
{
    if(!transaction) return @"contact";
    return [[TextSecureKitEnv sharedEnv].contactsManager displayNameForPhoneIdentifier:self.contactIdentifier transaction:transaction];
}

/// debug name
- (NSString *)debugName {
    return  self.uniqueId;
}

+ (NSString *)threadIdFromContactId:(NSString *)contactId {
    if (DTParamsUtils.validateString(contactId)) {
        
        return [TSContactThreadPrefix stringByAppendingString:contactId];
    } else {
        
        return nil;
    }
}

+ (NSString *)contactIdFromThreadId:(NSString *)threadId {
    return [threadId substringWithRange:NSMakeRange(1, threadId.length - 1)];
}

- (BOOL)isEqual:(TSContactThread *)other {

    if (other == self) {
        return YES;
    } else if (![super isEqual:other]) {
        return NO;
    }
    return [self.contactIdentifier isEqualToString:other.contactIdentifier];
}


- (NSString *)serverThreadId {
    
    return self.contactIdentifier;
}

- (uint32_t)messageExpiresInSeconds {
    return [super messageExpiresInSeconds];
}

- (uint32_t)messageExpiresInSecondsWithTransaction:(SDSAnyReadTransaction *)transaction {
    return [super messageExpiresInSecondsWithTransaction: transaction];
}


+ (void)updateWithRecipientId:(NSString *)recipientId
         friendContactVersion:(NSInteger)friendContactVersion
            receivedFriendReq:(BOOL)receivedFriendReq
       updateAtTheSameVersion:(BOOL)updateAtTheSameVersion
                  transaction:(SDSAnyWriteTransaction *)transaction {
    
    if (friendContactVersion <= 0){
        OWSLogError(@"friendContactVersion <= 0");
        return;
    }
    
    TSContactThread *thread = [TSContactThread getOrCreateThreadWithContactId:recipientId transaction:transaction];
    thread.receivedFriendReq = receivedFriendReq;
    TSInfoMessage *infoMsg = nil;
    if (receivedFriendReq) {
        thread.removedFromConversation = NO;
        uint64_t now = [NSDate ows_millisecondTimeStamp];
        infoMsg = [[TSInfoMessage alloc] initWithTimestamp:now
                                                  inThread:thread
                                               messageType:TSInfoMessageAskFriend
                                             customMessage:Localized(@"CONTACT_REQUEST", @"")];
    }
    if (updateAtTheSameVersion) {
        if (friendContactVersion >= thread.friendContactVersion) {
            thread.friendContactVersion = friendContactVersion - 1;
            [thread anyInsertWithTransaction:transaction];
            if (infoMsg) {
                [thread updateWithInsertedMessage:infoMsg transaction:transaction];
            }
        }
    } else {
        if (friendContactVersion > thread.friendContactVersion ||
            (friendContactVersion == thread.friendContactVersion && thread.receivedFriendReq && receivedFriendReq)) {
            thread.friendContactVersion = friendContactVersion;
            [thread anyInsertWithTransaction:transaction];
            if (infoMsg) {
                [thread updateWithInsertedMessage:infoMsg transaction:transaction];
            }
        }
    }
    
}

- (NSString *)generateConversationId {
    NSString *localNumber = TSAccountManager.localNumber;
    NSString *threadNumber = [self contactIdentifier];
    NSString *conversationIdString = nil;
    if([localNumber compare:threadNumber options:NSCaseInsensitiveSearch | NSNumericSearch] == NSOrderedAscending){
        conversationIdString = [NSString stringWithFormat:@"%@:%@",localNumber, threadNumber];
    } else {
        conversationIdString = [NSString stringWithFormat:@"%@:%@",threadNumber, localNumber];
    }
    return conversationIdString;
}

@end

NS_ASSUME_NONNULL_END
