//
//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.
//

#import "TSGroupThread.h"
#import "SignalRecipient.h"
#import "TSAttachmentStream.h"
#import "TSAccountManager.h"
#import "NSNotificationCenter+OWS.h"
#import <TTServiceKit/TTServiceKit-Swift.h>
//#import <YapDatabase/YapDatabaseConnection.h>
////

#import "DTGroupConfig.h"

NS_ASSUME_NONNULL_BEGIN

NSString *const TSGroupThreadAvatarChangedNotification = @"TSGroupThreadAvatarChangedNotification";
NSString *const TSGroupThread_NotificationKey_UniqueId = @"TSGroupThread_NotificationKey_UniqueId";

static NSString *const kDTOldToNewGroupIdPrefix = @"WEEK";

@implementation TSGroupThread

#define TSGroupThreadPrefix @"g"

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
                    archivalDate:(nullable NSDate *)archivalDate
              conversationEntity:(nullable DTConversationEntity *)conversationEntity
                    creationDate:(NSDate *)creationDate
             draftQuoteMessageId:(nullable NSString *)draftQuoteMessageId
                expiresInSeconds:(unsigned long long)expiresInSeconds
               hasEverHadMessage:(BOOL)hasEverHadMessage
                      isArchived:(BOOL)isArchived
                 lastMessageDate:(nullable NSDate *)lastMessageDate
                      lastestMsg:(nullable TSMessage *)lastestMsg
                 mentionedAllMsg:(nullable DTMentionedMsgInfo *)mentionedAllMsg
                  mentionedMeMsg:(nullable DTMentionedMsgInfo *)mentionedMeMsg
                   mentionsDraft:(nullable NSArray<DTMention *> *)mentionsDraft
              messageClearAnchor:(unsigned long long)messageClearAnchor
                    messageDraft:(nullable NSString *)messageDraft
                  mutedUntilDate:(nullable NSDate *)mutedUntilDate
                 plainTextEnable:(BOOL)plainTextEnable
              readPositionEntity:(nullable DTReadPositionEntity *)readPositionEntity
         removedFromConversation:(BOOL)removedFromConversation
                 shouldBeVisible:(BOOL)shouldBeVisible
                stickCallingDate:(nullable NSDate *)stickCallingDate
                       stickDate:(nullable NSDate *)stickDate
                    threadConfig:(nullable DTThreadConfigEntity *)threadConfig
            translateSettingType:(nullable NSNumber *)translateSettingType
                      unreadFlag:(unsigned int)unreadFlag
              unreadMessageCount:(NSUInteger)unreadMessageCount
                     unreadState:(NSUInteger)unreadState
            unreadTimeStimeStamp:(unsigned long long)unreadTimeStimeStamp
                      groupModel:(TSGroupModel *)groupModel
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId
                      archivalDate:archivalDate
                conversationEntity:conversationEntity
                      creationDate:creationDate
               draftQuoteMessageId:draftQuoteMessageId
                  expiresInSeconds:expiresInSeconds
                 hasEverHadMessage:hasEverHadMessage
                        isArchived:isArchived
                   lastMessageDate:lastMessageDate
                        lastestMsg:lastestMsg
                   mentionedAllMsg:mentionedAllMsg
                    mentionedMeMsg:mentionedMeMsg
                     mentionsDraft:mentionsDraft
                messageClearAnchor:messageClearAnchor
                      messageDraft:messageDraft
                    mutedUntilDate:mutedUntilDate
                   plainTextEnable:plainTextEnable
                readPositionEntity:readPositionEntity
           removedFromConversation:removedFromConversation
                   shouldBeVisible:shouldBeVisible
                  stickCallingDate:stickCallingDate
                         stickDate:stickDate
                      threadConfig:threadConfig
              translateSettingType:translateSettingType
                        unreadFlag:unreadFlag
                unreadMessageCount:unreadMessageCount
                       unreadState:unreadState
              unreadTimeStimeStamp:unreadTimeStimeStamp];

    if (!self) {
        return self;
    }

    _groupModel = groupModel;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

- (instancetype)initWithGroupModel:(TSGroupModel *)groupModel
{
    OWSAssertDebug(groupModel);
    OWSAssertDebug(groupModel.groupId.length > 0);
//    OWSAssertDebug(groupModel.groupMemberIds.count > 0);
    for (NSString *recipientId in groupModel.groupMemberIds) {
        OWSAssertDebug(recipientId.length > 0);
    }
    
    if(![self validateGroupId:groupModel.groupId]){
        return nil;
    }

    NSString *uniqueIdentifier = [[self class] threadIdFromGroupId:groupModel.groupId];
    self = [super initWithUniqueId:uniqueIdentifier];
    if (!self) {
        return self;
    }

    _groupModel = groupModel;

    return self;
}

- (instancetype)initWithGroupId:(NSData *)groupId transaction:(SDSAnyWriteTransaction *)transaction
{
    //OWSAssertDebug(groupId.length > 0);

    NSString *localNumber = [[TSAccountManager sharedInstance] localNumberWithTransaction:transaction];
    OWSAssertDebug(localNumber.length > 0);
    
    if(![self validateGroupId:groupId]){
        return nil;
    }

    TSGroupModel *groupModel = [[TSGroupModel alloc] initWithTitle:nil
                                                         memberIds:@[ localNumber ]
                                                             image:nil
                                                           groupId:groupId
                                                        groupOwner:nil
                                                        groupAdmin:nil
                                                       transaction:transaction];

    self = [self initWithGroupModel:groupModel];
    if (!self) {
        return self;
    }

    return self;
}

+ (instancetype _Nullable)getThreadWithGroupId:(NSData *)groupId transaction:(SDSAnyReadTransaction *)transaction
{
    //GRDB-Kris--
    //    OWSAssertDebug(groupId.length > 0);
    
    if (!groupId) {
        OWSLogError(@"groupId = nil");
        
        return nil;
    }
    
    NSString *uniqueId = [self threadIdFromGroupId:groupId];
    return [TSGroupThread anyFetchGroupThreadWithUniqueId:uniqueId transaction:transaction];
}

+ (instancetype _Nullable)threadWithGroupId:(NSData *)groupId transaction:(SDSAnyReadTransaction *)transaction
{
    //GRDB-Kris--
//    OWSAssertDebug(groupId.length > 0);
    
    if (!groupId) {
        OWSLogError(@"groupId = nil");
        
        return nil;
    }

    NSString *uniqueId = [self threadIdFromGroupId:groupId];
    return [TSGroupThread anyFetchGroupThreadWithUniqueId:uniqueId transaction:transaction];
}

+ (nullable instancetype)getThreadWithGroupId:(NSData *)groupId {
//    OWSAssertDebug(groupId.length > 0);
    
    if (!groupId) {
        OWSLogError(@"groupId = nil");
        
        return nil;
    }
    
    __block TSGroupThread *thread = nil;
    
    [self.databaseStorage readWithBlock:^(SDSAnyReadTransaction *transaction) {
        NSString *uniqueId = [self threadIdFromGroupId:groupId];
        thread = [TSGroupThread anyFetchGroupThreadWithUniqueId:uniqueId transaction:transaction];
    }];

    return thread;
}

+ (instancetype)getOrCreateThreadWithGroupId:(NSData *)groupId
{
    __block TSGroupThread *thread;
    DatabaseStorageWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *transaction) {
        thread = [self getOrCreateThreadWithGroupId:groupId transaction:transaction];
    });
    return thread;
}

+ (instancetype)getOrCreateThreadWithGroupId:(NSData *)groupId
                                 transaction:(SDSAnyWriteTransaction *)transaction
{
    BOOL generate = NO;
    return [self getOrCreateThreadWithGroupId:groupId
                                             generate:&generate
                                          transaction:transaction];
}

+ (instancetype)getOrCreateThreadWithGroupId:(NSData *)groupId
                                    generate:(BOOL *)generate
                                 transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(groupId.length > 0);
    OWSAssertDebug(transaction);

    TSGroupThread *thread = [self anyFetchGroupThreadWithUniqueId:[self threadIdFromGroupId:groupId]
                                                      transaction:transaction];
    if (!thread) {
        *generate = YES;
        thread = [[self alloc] initWithGroupId:groupId
                                   transaction:transaction];
        [thread anyInsertWithTransaction:transaction];
    }
    return thread;
}

+ (instancetype)getOrCreateThreadWithGroupModel:(TSGroupModel *)groupModel
                                    transaction:(SDSAnyWriteTransaction *)transaction {
    OWSAssertDebug(groupModel);
    OWSAssertDebug(groupModel.groupId.length > 0);
    OWSAssertDebug(transaction);
    
    TSGroupThread *thread = [self threadWithGroupId:groupModel.groupId transaction:transaction];
    if (!thread) {
        thread = [[TSGroupThread alloc] initWithGroupModel:groupModel];
        [thread anyInsertWithTransaction:transaction];
    }
    return thread;
}

+ (instancetype)getOrCreateThreadWithGroupModel:(TSGroupModel *)groupModel
{
    OWSAssertDebug(groupModel);
    OWSAssertDebug(groupModel.groupId.length > 0);

    __block TSGroupThread *thread;
    DatabaseStorageWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *transaction) {
        thread = [self getOrCreateThreadWithGroupModel:groupModel transaction:transaction];
    });
    
    return thread;
}

+ (NSString *)threadIdFromGroupId:(NSData *)groupId
{
    OWSAssertDebug(groupId.length > 0);

    if (groupId.length <= 0) { return nil; }
    
    return [TSGroupThreadPrefix stringByAppendingString:[groupId base64EncodedString]];
}

- (BOOL)isLocalUserInGroup
{
    NSString *_Nullable localAddress = [TSAccountManager localNumber];
    if (localAddress == nil) {
        return NO;
    }
    
    return [self.groupModel.groupMemberIds containsObject:localAddress];
}

- (BOOL)isLocalUserInGroupWithTransaction:(SDSAnyReadTransaction *)transaction
{
    NSString *_Nullable localAddress = [TSAccountManager.shared localNumberWithTransaction:transaction];
    if (localAddress == nil) {
        return NO;
    }
    
    return [self.groupModel.groupMemberIds containsObject:localAddress];
}

+ (NSData *)groupIdFromThreadId:(NSString *)threadId
{
    OWSAssertDebug(threadId.length > 0);

    return [NSData dataFromBase64String:[threadId substringWithRange:NSMakeRange(1, threadId.length - 1)]];
}

- (NSArray<NSString *> *)recipientIdentifiers
{
    NSMutableArray<NSString *> *groupMemberIds = [self.groupModel.groupMemberIds mutableCopy];
    if (groupMemberIds == nil || groupMemberIds.count == 0) {
        return @[];
    }

    [groupMemberIds removeObject:[TSAccountManager localNumber]];

    return [groupMemberIds copy];
}

- (BOOL)recipientsContainsBot {
    __block BOOL containsBot = NO;
    [self.recipientIdentifiers enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        if(DTParamsUtils.validateString(obj)){
            NSString *numberString = [obj stringByReplacingOccurrencesOfString:@"+"withString:@""];
            if(numberString.length <= 6){
                containsBot = YES;
                *stop = YES;
            }
        }
    }];
    return containsBot;
}

- (NSArray<NSString *> *)recipientIdentifiers_containMac_callNumbers {
    NSArray<NSString *> *recipientIdentifiers = [self recipientIdentifiers].mutableCopy;
    NSMutableArray *callNumbers = @[].mutableCopy;
    for (NSString *recipientIdentifier in recipientIdentifiers) {
        
        if (recipientIdentifier.length <= 6) {
            continue;
        }
        
        NSArray <NSString *> *callAccounts = [recipientIdentifier transforCallNumberToUserAccounts];
        [callNumbers addObjectsFromArray:callAccounts];
    }
    return callNumbers;
}

// @returns all threads to which the recipient is a member.
//
// @note If this becomes a hotspot we can extract into a YapDB View.
// As is, the number of groups should be small (dozens, *maybe* hundreds), and we only enumerate them upon SN changes.
+ (NSArray<TSGroupThread *> *)groupThreadsWithRecipientId:(NSString *)recipientId
                                              transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(recipientId.length > 0);
    OWSAssertDebug(transaction);

    NSMutableArray<TSGroupThread *> *groupThreads = [NSMutableArray new];

    [TSThread anyEnumerateWithTransaction:transaction
                                  batched:YES
                                    block:^(TSThread *thread, BOOL *stop) {
                                        if ([thread isKindOfClass:[TSGroupThread class]]) {
                                            TSGroupThread *groupThread = (TSGroupThread *)thread;
                                            if ([groupThread.groupModel.groupMemberIds containsObject:recipientId]) {
                                                [groupThreads addObject:groupThread];
                                            }
                                        }
                                    }];

    return [groupThreads copy];
}

- (BOOL)isGroupThread
{
    return true;
}

- (BOOL)isBotThread {
    return false;
}

- (BOOL)isLargeGroupThread {
    return NO;
}

- (BOOL)isHavePermissioncanSpeak {
    ///如果是群组Thread
   return self.groupModel.isSelfCanSpeak;
}

- (BOOL)isWithoutReadRecipt {
    return NO;
}

- (BOOL)startMeetingWithoutInvitation {
    DTGroupConfigEntity *groupConfigEntity = [DTGroupConfig fetchGroupConfig];
    if(self.groupModel.groupMemberIds.count >= groupConfigEntity.meetingWithoutRingThreshold){
        return YES;
    }
    
    return NO;
}

- (BOOL)isEqual:(TSGroupThread *)other {
    if (other == self) {
        return YES;
    } else if (![super isEqual:other]) {
        return NO;
    }
    return [self.groupModel.groupId isEqualToData:other.groupModel.groupId];
}

- (NSString *)nameWithTransaction:(nullable SDSAnyReadTransaction *)transaction
{
    return self.groupModel.groupName && self.groupModel.groupName.length > 0 ? self.groupModel.groupName : Localized(@"NEW_GROUP_DEFAULT_TITLE", @"");
}

/// debug log
- (NSString *)debugName {
    return self.groupModel.groupName && self.groupModel.groupName.length > 0 ? self.groupModel.groupName : Localized(@"NEW_GROUP_DEFAULT_TITLE", @"");
}

- (void)updateAvatarWithAttachmentStream:(TSAttachmentStream *)attachmentStream
{
    
    DatabaseStorageWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *transaction) {
        [self updateAvatarWithAttachmentStream:attachmentStream transaction:transaction];
    });
    
}

- (void)updateAvatarWithAttachmentStream:(TSAttachmentStream *)attachmentStream
                             transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(attachmentStream);
    OWSAssertDebug(transaction);
    
    [self anyUpdateGroupThreadWithTransaction:transaction
                                        block:^(TSGroupThread * instance) {
        instance.groupModel.groupImage = [attachmentStream image];
    }];
    
    [transaction addAsyncCompletionOnMain:^{
        [self fireAvatarChangedNotification];
    }];

    // Avatars are stored directly in the database, so there's no need
    // to keep the attachment around after assigning the image.
    [attachmentStream anyRemoveWithTransaction:transaction];
}

- (void)fireAvatarChangedNotification
{
    NSDictionary *userInfo = @{ TSGroupThread_NotificationKey_UniqueId : self.uniqueId };

    [[NSNotificationCenter defaultCenter] postNotificationNameAsync:TSGroupThreadAvatarChangedNotification object:self.uniqueId userInfo:userInfo];
                                               
//        postNotificationName:TSGroupThreadAvatarChangedNotification
//                                                        object:self.uniqueId
//                                                      userInfo:userInfo];
}

+ (nullable NSString *)transformToServerGroupIdWithLocalGroupId:(NSData *)groupId{
    NSString *serverGId = nil;
    if(groupId.length == 32){
        serverGId = [[NSString alloc] initWithData:groupId encoding:NSUTF8StringEncoding];
    }else if (groupId.length == 16){
        serverGId = [[groupId hexadecimalString] uppercaseString];
        if(serverGId.length){
            return [kDTOldToNewGroupIdPrefix stringByAppendingString:serverGId];
        }else{
            OWSLogError(@"[TSGroupThread] groupId length == 0");
        }
    }else{
        OWSLogError(@"[TSGroupThread] groupId %@.", groupId);
    }
    
    return serverGId;
}

+ (nullable NSData *)transformToLocalGroupIdWithServerGroupId:(NSString *)groupId{
    if(!groupId.length) return nil;
    
    NSData *localGId = nil;
    if([groupId hasPrefix:kDTOldToNewGroupIdPrefix]){
        groupId = [groupId substringFromIndex:kDTOldToNewGroupIdPrefix.length];
        localGId = [NSData dataFromHexString:groupId];
    }else{
        localGId = [groupId dataUsingEncoding:NSUTF8StringEncoding];
    }
    
    return localGId;
}

- (NSString *)serverThreadId {
    
    if (!self.groupModel.groupId || self.groupModel.groupId.length == 0) {
        OWSLogInfo(@"[TSGroupThread] groupModel: \n%@", self.groupModel.description);
    }
    
    return [TSGroupThread transformToServerGroupIdWithLocalGroupId:self.groupModel.groupId];
}

- (BOOL)validateGroupId:(NSData *)groupId {
    if(groupId.length == 32 ||
       groupId.length == 16){
        return YES;
    }
    return NO;
}

- (BOOL)businessFromVega {
    return false;
}

#pragma mark Disappearing Messages

- (uint32_t)messageExpiresInSeconds{
    
    NSNumber *messageExpiry = self.groupModel.messageExpiry;
    
    if(!messageExpiry || messageExpiry.doubleValue < 0){
        return [super messageExpiresInSeconds];
    } else {
        return messageExpiry.unsignedIntValue;
    }
}

- (uint32_t)messageExpiresInSecondsWithTransaction:(SDSAnyReadTransaction *)transaction {
    return [self messageExpiresInSeconds];
}

@end

NS_ASSUME_NONNULL_END
