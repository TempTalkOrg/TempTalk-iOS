// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: DifftService.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

//*
// Copyright (C) 2014-2016 Open Whisper Systems
//
// Licensed according to the LICENSE file in this repository.

/// iOS - since we use a modern proto-compiler, we must specify
/// the legacy proto format.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct DifftServiceProtos_ConversationMsgInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversationPreview: DifftServiceProtos_ConversationPreview {
    get {return _conversationPreview ?? DifftServiceProtos_ConversationPreview()}
    set {_conversationPreview = newValue}
  }
  /// Returns true if `conversationPreview` has been explicitly set.
  var hasConversationPreview: Bool {return self._conversationPreview != nil}
  /// Clears the value of `conversationPreview`. Subsequent reads from it will return its default value.
  mutating func clearConversationPreview() {self._conversationPreview = nil}

  /// 可拉取最老的消息 sequenceId，用于拉取消息
  var oldestMsgSid: UInt64 {
    get {return _oldestMsgSid ?? 0}
    set {_oldestMsgSid = newValue}
  }
  /// Returns true if `oldestMsgSid` has been explicitly set.
  var hasOldestMsgSid: Bool {return self._oldestMsgSid != nil}
  /// Clears the value of `oldestMsgSid`. Subsequent reads from it will return its default value.
  mutating func clearOldestMsgSid() {self._oldestMsgSid = nil}

  /// 可拉取最老的消息 notifySequenceId，用于拉取消息
  var oldestMsgNsID: UInt64 {
    get {return _oldestMsgNsID ?? 0}
    set {_oldestMsgNsID = newValue}
  }
  /// Returns true if `oldestMsgNsID` has been explicitly set.
  var hasOldestMsgNsID: Bool {return self._oldestMsgNsID != nil}
  /// Clears the value of `oldestMsgNsID`. Subsequent reads from it will return its default value.
  mutating func clearOldestMsgNsID() {self._oldestMsgNsID = nil}

  /// 可拉取最新的消息 sequenceId，用于拉取消息
  var lastestMsgSid: UInt64 {
    get {return _lastestMsgSid ?? 0}
    set {_lastestMsgSid = newValue}
  }
  /// Returns true if `lastestMsgSid` has been explicitly set.
  var hasLastestMsgSid: Bool {return self._lastestMsgSid != nil}
  /// Clears the value of `lastestMsgSid`. Subsequent reads from it will return its default value.
  mutating func clearLastestMsgSid() {self._lastestMsgSid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _conversationPreview: DifftServiceProtos_ConversationPreview? = nil
  fileprivate var _oldestMsgSid: UInt64? = nil
  fileprivate var _oldestMsgNsID: UInt64? = nil
  fileprivate var _lastestMsgSid: UInt64? = nil
}

struct DifftServiceProtos_ConversationPreview: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversationID: DifftServiceProtos_ConversationId {
    get {return _conversationID ?? DifftServiceProtos_ConversationId()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  mutating func clearConversationID() {self._conversationID = nil}

  var readPosition: DifftServiceProtos_ReadPosition {
    get {return _readPosition ?? DifftServiceProtos_ReadPosition()}
    set {_readPosition = newValue}
  }
  /// Returns true if `readPosition` has been explicitly set.
  var hasReadPosition: Bool {return self._readPosition != nil}
  /// Clears the value of `readPosition`. Subsequent reads from it will return its default value.
  mutating func clearReadPosition() {self._readPosition = nil}

  var unreadCorrection: UInt32 {
    get {return _unreadCorrection ?? 0}
    set {_unreadCorrection = newValue}
  }
  /// Returns true if `unreadCorrection` has been explicitly set.
  var hasUnreadCorrection: Bool {return self._unreadCorrection != nil}
  /// Clears the value of `unreadCorrection`. Subsequent reads from it will return its default value.
  mutating func clearUnreadCorrection() {self._unreadCorrection = nil}

  var lastestMsg: DifftServiceProtos_Envelope {
    get {return _lastestMsg ?? DifftServiceProtos_Envelope()}
    set {_lastestMsg = newValue}
  }
  /// Returns true if `lastestMsg` has been explicitly set.
  var hasLastestMsg: Bool {return self._lastestMsg != nil}
  /// Clears the value of `lastestMsg`. Subsequent reads from it will return its default value.
  mutating func clearLastestMsg() {self._lastestMsg = nil}

  var onePageMsgs: [DifftServiceProtos_Envelope] = []

  var lastestMsgNsID: UInt64 {
    get {return _lastestMsgNsID ?? 0}
    set {_lastestMsgNsID = newValue}
  }
  /// Returns true if `lastestMsgNsID` has been explicitly set.
  var hasLastestMsgNsID: Bool {return self._lastestMsgNsID != nil}
  /// Clears the value of `lastestMsgNsID`. Subsequent reads from it will return its default value.
  mutating func clearLastestMsgNsID() {self._lastestMsgNsID = nil}

  var maxOutgoingNsID: UInt64 {
    get {return _maxOutgoingNsID ?? 0}
    set {_maxOutgoingNsID = newValue}
  }
  /// Returns true if `maxOutgoingNsID` has been explicitly set.
  var hasMaxOutgoingNsID: Bool {return self._maxOutgoingNsID != nil}
  /// Clears the value of `maxOutgoingNsID`. Subsequent reads from it will return its default value.
  mutating func clearMaxOutgoingNsID() {self._maxOutgoingNsID = nil}

  /// 新增，用于消息拉取
  var maxOutgoingSid: UInt64 {
    get {return _maxOutgoingSid ?? 0}
    set {_maxOutgoingSid = newValue}
  }
  /// Returns true if `maxOutgoingSid` has been explicitly set.
  var hasMaxOutgoingSid: Bool {return self._maxOutgoingSid != nil}
  /// Clears the value of `maxOutgoingSid`. Subsequent reads from it will return its default value.
  mutating func clearMaxOutgoingSid() {self._maxOutgoingSid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _conversationID: DifftServiceProtos_ConversationId? = nil
  fileprivate var _readPosition: DifftServiceProtos_ReadPosition? = nil
  fileprivate var _unreadCorrection: UInt32? = nil
  fileprivate var _lastestMsg: DifftServiceProtos_Envelope? = nil
  fileprivate var _lastestMsgNsID: UInt64? = nil
  fileprivate var _maxOutgoingNsID: UInt64? = nil
  fileprivate var _maxOutgoingSid: UInt64? = nil
}

struct DifftServiceProtos_ConversationId: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 1v1 会话，对方号码
  var number: String {
    get {return _number ?? String()}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {self._number = nil}

  /// 群组，群组id,
  var groupID: Data {
    get {return _groupID ?? Data()}
    set {_groupID = newValue}
  }
  /// Returns true if `groupID` has been explicitly set.
  var hasGroupID: Bool {return self._groupID != nil}
  /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
  mutating func clearGroupID() {self._groupID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _number: String? = nil
  fileprivate var _groupID: Data? = nil
}

struct DifftServiceProtos_Envelope: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: DifftServiceProtos_Envelope.TypeEnum {
    get {return _storage._type ?? .unknown}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var source: String {
    get {return _storage._source ?? String()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {_uniqueStorage()._source = nil}

  var sourceDevice: UInt32 {
    get {return _storage._sourceDevice ?? 0}
    set {_uniqueStorage()._sourceDevice = newValue}
  }
  /// Returns true if `sourceDevice` has been explicitly set.
  var hasSourceDevice: Bool {return _storage._sourceDevice != nil}
  /// Clears the value of `sourceDevice`. Subsequent reads from it will return its default value.
  mutating func clearSourceDevice() {_uniqueStorage()._sourceDevice = nil}

  var relay: String {
    get {return _storage._relay ?? String()}
    set {_uniqueStorage()._relay = newValue}
  }
  /// Returns true if `relay` has been explicitly set.
  var hasRelay: Bool {return _storage._relay != nil}
  /// Clears the value of `relay`. Subsequent reads from it will return its default value.
  mutating func clearRelay() {_uniqueStorage()._relay = nil}

  var timestamp: UInt64 {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  /// Contains an encrypted DataMessage
  var legacyMessage: Data {
    get {return _storage._legacyMessage ?? Data()}
    set {_uniqueStorage()._legacyMessage = newValue}
  }
  /// Returns true if `legacyMessage` has been explicitly set.
  var hasLegacyMessage: Bool {return _storage._legacyMessage != nil}
  /// Clears the value of `legacyMessage`. Subsequent reads from it will return its default value.
  mutating func clearLegacyMessage() {_uniqueStorage()._legacyMessage = nil}

  /// Contains an encrypted Content
  var content: Data {
    get {return _storage._content ?? Data()}
    set {_uniqueStorage()._content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return _storage._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {_uniqueStorage()._content = nil}

  var lastestMsgFlag: Bool {
    get {return _storage._lastestMsgFlag ?? false}
    set {_uniqueStorage()._lastestMsgFlag = newValue}
  }
  /// Returns true if `lastestMsgFlag` has been explicitly set.
  var hasLastestMsgFlag: Bool {return _storage._lastestMsgFlag != nil}
  /// Clears the value of `lastestMsgFlag`. Subsequent reads from it will return its default value.
  mutating func clearLastestMsgFlag() {_uniqueStorage()._lastestMsgFlag = nil}

  /// msg seq number. Note: number 9 and 10 are reserved fields
  var sequenceID: UInt64 {
    get {return _storage._sequenceID ?? 0}
    set {_uniqueStorage()._sequenceID = newValue}
  }
  /// Returns true if `sequenceID` has been explicitly set.
  var hasSequenceID: Bool {return _storage._sequenceID != nil}
  /// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
  mutating func clearSequenceID() {_uniqueStorage()._sequenceID = nil}

  var systemShowTimestamp: UInt64 {
    get {return _storage._systemShowTimestamp ?? 0}
    set {_uniqueStorage()._systemShowTimestamp = newValue}
  }
  /// Returns true if `systemShowTimestamp` has been explicitly set.
  var hasSystemShowTimestamp: Bool {return _storage._systemShowTimestamp != nil}
  /// Clears the value of `systemShowTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearSystemShowTimestamp() {_uniqueStorage()._systemShowTimestamp = nil}

  var msgType: DifftServiceProtos_Envelope.MsgType {
    get {return _storage._msgType ?? .msgUnknown}
    set {_uniqueStorage()._msgType = newValue}
  }
  /// Returns true if `msgType` has been explicitly set.
  var hasMsgType: Bool {return _storage._msgType != nil}
  /// Clears the value of `msgType`. Subsequent reads from it will return its default value.
  mutating func clearMsgType() {_uniqueStorage()._msgType = nil}

  var notifySequenceID: UInt64 {
    get {return _storage._notifySequenceID ?? 0}
    set {_uniqueStorage()._notifySequenceID = newValue}
  }
  /// Returns true if `notifySequenceID` has been explicitly set.
  var hasNotifySequenceID: Bool {return _storage._notifySequenceID != nil}
  /// Clears the value of `notifySequenceID`. Subsequent reads from it will return its default value.
  mutating func clearNotifySequenceID() {_uniqueStorage()._notifySequenceID = nil}

  var identityKey: String {
    get {return _storage._identityKey ?? String()}
    set {_uniqueStorage()._identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  var hasIdentityKey: Bool {return _storage._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKey() {_uniqueStorage()._identityKey = nil}

  var peerContext: String {
    get {return _storage._peerContext ?? String()}
    set {_uniqueStorage()._peerContext = newValue}
  }
  /// Returns true if `peerContext` has been explicitly set.
  var hasPeerContext: Bool {return _storage._peerContext != nil}
  /// Clears the value of `peerContext`. Subsequent reads from it will return its default value.
  mutating func clearPeerContext() {_uniqueStorage()._peerContext = nil}

  var msgExtra: DifftServiceProtos_MsgExtra {
    get {return _storage._msgExtra ?? DifftServiceProtos_MsgExtra()}
    set {_uniqueStorage()._msgExtra = newValue}
  }
  /// Returns true if `msgExtra` has been explicitly set.
  var hasMsgExtra: Bool {return _storage._msgExtra != nil}
  /// Clears the value of `msgExtra`. Subsequent reads from it will return its default value.
  mutating func clearMsgExtra() {_uniqueStorage()._msgExtra = nil}

  var criticalLevel: DifftServiceProtos_Envelope.CriticalLevel {
    get {return _storage._criticalLevel ?? .levelUnknown}
    set {_uniqueStorage()._criticalLevel = newValue}
  }
  /// Returns true if `criticalLevel` has been explicitly set.
  var hasCriticalLevel: Bool {return _storage._criticalLevel != nil}
  /// Clears the value of `criticalLevel`. Subsequent reads from it will return its default value.
  mutating func clearCriticalLevel() {_uniqueStorage()._criticalLevel = nil}

  var pushTimestamp: UInt64 {
    get {return _storage._pushTimestamp ?? 0}
    set {_uniqueStorage()._pushTimestamp = newValue}
  }
  /// Returns true if `pushTimestamp` has been explicitly set.
  var hasPushTimestamp: Bool {return _storage._pushTimestamp != nil}
  /// Clears the value of `pushTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearPushTimestamp() {_uniqueStorage()._pushTimestamp = nil}

  /// room id,calling消息中roomId为空时，使用该字段;
  /// roomId和CallMessage中roomId都非空时，两者不相等时报错
  var roomID: String {
    get {return _storage._roomID ?? String()}
    set {_uniqueStorage()._roomID = newValue}
  }
  /// Returns true if `roomID` has been explicitly set.
  var hasRoomID: Bool {return _storage._roomID != nil}
  /// Clears the value of `roomID`. Subsequent reads from it will return its default value.
  mutating func clearRoomID() {_uniqueStorage()._roomID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case unknown = 0
    case ciphertext = 1
    case keyExchange = 2
    case prekeyBundle = 3
    case receipt = 5
    case notify = 6
    case plaintext = 7
    case etoee = 8

    init() {
      self = .unknown
    }

  }

  enum MsgType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case msgUnknown = 0
    case msgNormal = 1
    case msgSync = 2
    case msgReadReceipt = 3
    case msgSyncReadReceipt = 4
    case msgDeliveryReceipt = 5
    case msgNotify = 6
    case msgRecall = 7
    case msgRecalled = 8
    case msgSyncPreviewable = 9
    case msgClientNotify = 10
    case msgScheduleNormal = 11
    case msgEncCall = 12

    init() {
      self = .msgUnknown
    }

  }

  enum CriticalLevel: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case levelUnknown = 0
    case levelCritical = 1000

    init() {
      self = .levelUnknown
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DifftServiceProtos_Content: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataMessage: DifftServiceProtos_DataMessage {
    get {return _storage._dataMessage ?? DifftServiceProtos_DataMessage()}
    set {_uniqueStorage()._dataMessage = newValue}
  }
  /// Returns true if `dataMessage` has been explicitly set.
  var hasDataMessage: Bool {return _storage._dataMessage != nil}
  /// Clears the value of `dataMessage`. Subsequent reads from it will return its default value.
  mutating func clearDataMessage() {_uniqueStorage()._dataMessage = nil}

  var syncMessage: DifftServiceProtos_SyncMessage {
    get {return _storage._syncMessage ?? DifftServiceProtos_SyncMessage()}
    set {_uniqueStorage()._syncMessage = newValue}
  }
  /// Returns true if `syncMessage` has been explicitly set.
  var hasSyncMessage: Bool {return _storage._syncMessage != nil}
  /// Clears the value of `syncMessage`. Subsequent reads from it will return its default value.
  mutating func clearSyncMessage() {_uniqueStorage()._syncMessage = nil}

  ///  optional CallMessage    callMessage    = 3;
  var nullMessage: DifftServiceProtos_NullMessage {
    get {return _storage._nullMessage ?? DifftServiceProtos_NullMessage()}
    set {_uniqueStorage()._nullMessage = newValue}
  }
  /// Returns true if `nullMessage` has been explicitly set.
  var hasNullMessage: Bool {return _storage._nullMessage != nil}
  /// Clears the value of `nullMessage`. Subsequent reads from it will return its default value.
  mutating func clearNullMessage() {_uniqueStorage()._nullMessage = nil}

  var receiptMessage: DifftServiceProtos_ReceiptMessage {
    get {return _storage._receiptMessage ?? DifftServiceProtos_ReceiptMessage()}
    set {_uniqueStorage()._receiptMessage = newValue}
  }
  /// Returns true if `receiptMessage` has been explicitly set.
  var hasReceiptMessage: Bool {return _storage._receiptMessage != nil}
  /// Clears the value of `receiptMessage`. Subsequent reads from it will return its default value.
  mutating func clearReceiptMessage() {_uniqueStorage()._receiptMessage = nil}

  var typingMessage: DifftServiceProtos_TypingMessage {
    get {return _storage._typingMessage ?? DifftServiceProtos_TypingMessage()}
    set {_uniqueStorage()._typingMessage = newValue}
  }
  /// Returns true if `typingMessage` has been explicitly set.
  var hasTypingMessage: Bool {return _storage._typingMessage != nil}
  /// Clears the value of `typingMessage`. Subsequent reads from it will return its default value.
  mutating func clearTypingMessage() {_uniqueStorage()._typingMessage = nil}

  var notifyMessage: DifftServiceProtos_NotifyMessage {
    get {return _storage._notifyMessage ?? DifftServiceProtos_NotifyMessage()}
    set {_uniqueStorage()._notifyMessage = newValue}
  }
  /// Returns true if `notifyMessage` has been explicitly set.
  var hasNotifyMessage: Bool {return _storage._notifyMessage != nil}
  /// Clears the value of `notifyMessage`. Subsequent reads from it will return its default value.
  mutating func clearNotifyMessage() {_uniqueStorage()._notifyMessage = nil}

  /// Enc Call 消息
  var callMessage: DifftServiceProtos_CallMessage {
    get {return _storage._callMessage ?? DifftServiceProtos_CallMessage()}
    set {_uniqueStorage()._callMessage = newValue}
  }
  /// Returns true if `callMessage` has been explicitly set.
  var hasCallMessage: Bool {return _storage._callMessage != nil}
  /// Clears the value of `callMessage`. Subsequent reads from it will return its default value.
  mutating func clearCallMessage() {_uniqueStorage()._callMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DifftServiceProtos_CallMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var calling: DifftServiceProtos_CallMessage.Calling {
    get {return _calling ?? DifftServiceProtos_CallMessage.Calling()}
    set {_calling = newValue}
  }
  /// Returns true if `calling` has been explicitly set.
  var hasCalling: Bool {return self._calling != nil}
  /// Clears the value of `calling`. Subsequent reads from it will return its default value.
  mutating func clearCalling() {self._calling = nil}

  var joined: DifftServiceProtos_CallMessage.Joined {
    get {return _joined ?? DifftServiceProtos_CallMessage.Joined()}
    set {_joined = newValue}
  }
  /// Returns true if `joined` has been explicitly set.
  var hasJoined: Bool {return self._joined != nil}
  /// Clears the value of `joined`. Subsequent reads from it will return its default value.
  mutating func clearJoined() {self._joined = nil}

  var cancel: DifftServiceProtos_CallMessage.Cancel {
    get {return _cancel ?? DifftServiceProtos_CallMessage.Cancel()}
    set {_cancel = newValue}
  }
  /// Returns true if `cancel` has been explicitly set.
  var hasCancel: Bool {return self._cancel != nil}
  /// Clears the value of `cancel`. Subsequent reads from it will return its default value.
  mutating func clearCancel() {self._cancel = nil}

  var reject: DifftServiceProtos_CallMessage.Reject {
    get {return _reject ?? DifftServiceProtos_CallMessage.Reject()}
    set {_reject = newValue}
  }
  /// Returns true if `reject` has been explicitly set.
  var hasReject: Bool {return self._reject != nil}
  /// Clears the value of `reject`. Subsequent reads from it will return its default value.
  mutating func clearReject() {self._reject = nil}

  var hangup: DifftServiceProtos_CallMessage.Hangup {
    get {return _hangup ?? DifftServiceProtos_CallMessage.Hangup()}
    set {_hangup = newValue}
  }
  /// Returns true if `hangup` has been explicitly set.
  var hasHangup: Bool {return self._hangup != nil}
  /// Clears the value of `hangup`. Subsequent reads from it will return its default value.
  mutating func clearHangup() {self._hangup = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// calling : 发起Call & 邀请他人时发送
  struct Calling: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// roomId,可能为空；请求starting messages时，
    /// client 还不知道room id，邀请人入会时才已知room id
    var roomID: String {
      get {return _roomID ?? String()}
      set {_roomID = newValue}
    }
    /// Returns true if `roomID` has been explicitly set.
    var hasRoomID: Bool {return self._roomID != nil}
    /// Clears the value of `roomID`. Subsequent reads from it will return its default value.
    mutating func clearRoomID() {self._roomID = nil}

    /// instant Call时，conversationId为空；1on1 Call同步消息时，conversationId存callee号码；
    /// 发给callee时，conversationId存caller号码
    var conversationID: DifftServiceProtos_ConversationId {
      get {return _conversationID ?? DifftServiceProtos_ConversationId()}
      set {_conversationID = newValue}
    }
    /// Returns true if `conversationID` has been explicitly set.
    var hasConversationID: Bool {return self._conversationID != nil}
    /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
    mutating func clearConversationID() {self._conversationID = nil}

    var roomName: String {
      get {return _roomName ?? String()}
      set {_roomName = newValue}
    }
    /// Returns true if `roomName` has been explicitly set.
    var hasRoomName: Bool {return self._roomName != nil}
    /// Clears the value of `roomName`. Subsequent reads from it will return its default value.
    mutating func clearRoomName() {self._roomName = nil}

    ///  Call creator or 临时邀请人
    var caller: String {
      get {return _caller ?? String()}
      set {_caller = newValue}
    }
    /// Returns true if `caller` has been explicitly set.
    var hasCaller: Bool {return self._caller != nil}
    /// Clears the value of `caller`. Subsequent reads from it will return its default value.
    mutating func clearCaller() {self._caller = nil}

    /// mk的密文，需要用自己私钥解密；
    var emk: Data {
      get {return _emk ?? Data()}
      set {_emk = newValue}
    }
    /// Returns true if `emk` has been explicitly set.
    var hasEmk: Bool {return self._emk != nil}
    /// Clears the value of `emk`. Subsequent reads from it will return its default value.
    mutating func clearEmk() {self._emk = nil}

    /// 临时的ecc公钥
    var publicKey: Data {
      get {return _publicKey ?? Data()}
      set {_publicKey = newValue}
    }
    /// Returns true if `publicKey` has been explicitly set.
    var hasPublicKey: Bool {return self._publicKey != nil}
    /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
    mutating func clearPublicKey() {self._publicKey = nil}

    /// 消息合并，是否接收端生成本地消息
    var createCallMsg: Bool {
      get {return _createCallMsg ?? false}
      set {_createCallMsg = newValue}
    }
    /// Returns true if `createCallMsg` has been explicitly set.
    var hasCreateCallMsg: Bool {return self._createCallMsg != nil}
    /// Clears the value of `createCallMsg`. Subsequent reads from it will return its default value.
    mutating func clearCreateCallMsg() {self._createCallMsg = nil}

    /// 区分start/invite call
    var controlType: String {
      get {return _controlType ?? String()}
      set {_controlType = newValue}
    }
    /// Returns true if `controlType` has been explicitly set.
    var hasControlType: Bool {return self._controlType != nil}
    /// Clears the value of `controlType`. Subsequent reads from it will return its default value.
    mutating func clearControlType() {self._controlType = nil}

    ///被邀请人的数据
    var callees: [String] = []

    ///发起会议的时间戳
    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _roomID: String? = nil
    fileprivate var _conversationID: DifftServiceProtos_ConversationId? = nil
    fileprivate var _roomName: String? = nil
    fileprivate var _caller: String? = nil
    fileprivate var _emk: Data? = nil
    fileprivate var _publicKey: Data? = nil
    fileprivate var _createCallMsg: Bool? = nil
    fileprivate var _controlType: String? = nil
    fileprivate var _timestamp: UInt64? = nil
  }

  /// callee成功入会时，同步给自己另一端(如果有)
  /// 如果只有一个端无需同步，用不上该消息
  /// 多人 Call时，caller不用发送该消息，因为多人 Call时收到Calling消息后，就可以显示MeetingBar
  struct Joined: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 1on1 Call, 主叫Joined将calling一起同步给自己另一端(如果有)；发起call时不要将calling投递给自己另一端；主叫Cancel时无需发Cancel给自己另外一端； 多人 Call 和 被叫 都无需携带 calling；
    /// optional Calling calling = 2;
    var roomID: String {
      get {return _roomID ?? String()}
      set {_roomID = newValue}
    }
    /// Returns true if `roomID` has been explicitly set.
    var hasRoomID: Bool {return self._roomID != nil}
    /// Clears the value of `roomID`. Subsequent reads from it will return its default value.
    mutating func clearRoomID() {self._roomID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _roomID: String? = nil
  }

  /// cancel : caller取消 Call
  /// 1on1 Call,同步给自己另一端(如果有)和对方；caller去及时清理数据，callee关闭弹窗
  /// 多人 Call无需该消息，使用Server推送的 Call结束notify消息即可
  struct Cancel: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String {
      get {return _roomID ?? String()}
      set {_roomID = newValue}
    }
    /// Returns true if `roomID` has been explicitly set.
    var hasRoomID: Bool {return self._roomID != nil}
    /// Clears the value of `roomID`. Subsequent reads from it will return its default value.
    mutating func clearRoomID() {self._roomID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _roomID: String? = nil
  }

  /// reject : callee拒绝加入 Call,
  /// 1on1 Call,同步给自己另一端(如果有)和caller；callee去关闭弹窗；caller(仅发起一端)关闭弹窗，caller两端清理数据
  /// 多人 Call,同步给自己另一端(如果有)
  struct Reject: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String {
      get {return _roomID ?? String()}
      set {_roomID = newValue}
    }
    /// Returns true if `roomID` has been explicitly set.
    var hasRoomID: Bool {return self._roomID != nil}
    /// Clears the value of `roomID`. Subsequent reads from it will return its default value.
    mutating func clearRoomID() {self._roomID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _roomID: String? = nil
  }

  /// hangup : 1on1 Call,挂断已经接通的 Call,将消息发给对方, 无需将hangup消息同步给自己另一端
  /// 原因： live sdk不能明确区分 remote participant是点击按钮主动leave call， 还是网络异常导致的participant disconnected
  /// leave多人 Call, 无需发送该消息
  struct Hangup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var roomID: String {
      get {return _roomID ?? String()}
      set {_roomID = newValue}
    }
    /// Returns true if `roomID` has been explicitly set.
    var hasRoomID: Bool {return self._roomID != nil}
    /// Clears the value of `roomID`. Subsequent reads from it will return its default value.
    mutating func clearRoomID() {self._roomID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _roomID: String? = nil
  }

  init() {}

  fileprivate var _calling: DifftServiceProtos_CallMessage.Calling? = nil
  fileprivate var _joined: DifftServiceProtos_CallMessage.Joined? = nil
  fileprivate var _cancel: DifftServiceProtos_CallMessage.Cancel? = nil
  fileprivate var _reject: DifftServiceProtos_CallMessage.Reject? = nil
  fileprivate var _hangup: DifftServiceProtos_CallMessage.Hangup? = nil
}

struct DifftServiceProtos_MsgExtra: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latestCard: DifftServiceProtos_Card {
    get {return _latestCard ?? DifftServiceProtos_Card()}
    set {_latestCard = newValue}
  }
  /// Returns true if `latestCard` has been explicitly set.
  var hasLatestCard: Bool {return self._latestCard != nil}
  /// Clears the value of `latestCard`. Subsequent reads from it will return its default value.
  mutating func clearLatestCard() {self._latestCard = nil}

  var conversationID: DifftServiceProtos_ConversationId {
    get {return _conversationID ?? DifftServiceProtos_ConversationId()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  mutating func clearConversationID() {self._conversationID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _latestCard: DifftServiceProtos_Card? = nil
  fileprivate var _conversationID: DifftServiceProtos_ConversationId? = nil
}

struct DifftServiceProtos_Card: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var appID: String {
    get {return _appID ?? String()}
    set {_appID = newValue}
  }
  /// Returns true if `appID` has been explicitly set.
  var hasAppID: Bool {return self._appID != nil}
  /// Clears the value of `appID`. Subsequent reads from it will return its default value.
  mutating func clearAppID() {self._appID = nil}

  var cardID: String {
    get {return _cardID ?? String()}
    set {_cardID = newValue}
  }
  /// Returns true if `cardID` has been explicitly set.
  var hasCardID: Bool {return self._cardID != nil}
  /// Clears the value of `cardID`. Subsequent reads from it will return its default value.
  mutating func clearCardID() {self._cardID = nil}

  var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var creator: String {
    get {return _creator ?? String()}
    set {_creator = newValue}
  }
  /// Returns true if `creator` has been explicitly set.
  var hasCreator: Bool {return self._creator != nil}
  /// Clears the value of `creator`. Subsequent reads from it will return its default value.
  mutating func clearCreator() {self._creator = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var content: String {
    get {return _content ?? String()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var contentType: UInt32 {
    get {return _contentType ?? 0}
    set {_contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  var hasContentType: Bool {return self._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  mutating func clearContentType() {self._contentType = nil}

  var type: UInt32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var fixedWidth: Bool {
    get {return _fixedWidth ?? false}
    set {_fixedWidth = newValue}
  }
  /// Returns true if `fixedWidth` has been explicitly set.
  var hasFixedWidth: Bool {return self._fixedWidth != nil}
  /// Clears the value of `fixedWidth`. Subsequent reads from it will return its default value.
  mutating func clearFixedWidth() {self._fixedWidth = nil}

  var height: UInt32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var uniqueID: String {
    get {return _uniqueID ?? String()}
    set {_uniqueID = newValue}
  }
  /// Returns true if `uniqueID` has been explicitly set.
  var hasUniqueID: Bool {return self._uniqueID != nil}
  /// Clears the value of `uniqueID`. Subsequent reads from it will return its default value.
  mutating func clearUniqueID() {self._uniqueID = nil}

  var source: String {
    get {return _source ?? String()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var conversationID: String {
    get {return _conversationID ?? String()}
    set {_conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  var hasConversationID: Bool {return self._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  mutating func clearConversationID() {self._conversationID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case insert = 0
    case update = 1

    init() {
      self = .insert
    }

  }

  enum ContentType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case markdown = 0
    case adaptivecard = 1

    init() {
      self = .markdown
    }

  }

  init() {}

  fileprivate var _appID: String? = nil
  fileprivate var _cardID: String? = nil
  fileprivate var _version: UInt32? = nil
  fileprivate var _creator: String? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _content: String? = nil
  fileprivate var _contentType: UInt32? = nil
  fileprivate var _type: UInt32? = nil
  fileprivate var _fixedWidth: Bool? = nil
  fileprivate var _height: UInt32? = nil
  fileprivate var _uniqueID: String? = nil
  fileprivate var _source: String? = nil
  fileprivate var _conversationID: String? = nil
}

struct DifftServiceProtos_RapidFile: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rapidHash: String {
    get {return _rapidHash ?? String()}
    set {_rapidHash = newValue}
  }
  /// Returns true if `rapidHash` has been explicitly set.
  var hasRapidHash: Bool {return self._rapidHash != nil}
  /// Clears the value of `rapidHash`. Subsequent reads from it will return its default value.
  mutating func clearRapidHash() {self._rapidHash = nil}

  var authorizedID: String {
    get {return _authorizedID ?? String()}
    set {_authorizedID = newValue}
  }
  /// Returns true if `authorizedID` has been explicitly set.
  var hasAuthorizedID: Bool {return self._authorizedID != nil}
  /// Clears the value of `authorizedID`. Subsequent reads from it will return its default value.
  mutating func clearAuthorizedID() {self._authorizedID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _rapidHash: String? = nil
  fileprivate var _authorizedID: String? = nil
}

struct DifftServiceProtos_RealSource: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: String {
    get {return _source ?? String()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var sourceDevice: UInt32 {
    get {return _sourceDevice ?? 0}
    set {_sourceDevice = newValue}
  }
  /// Returns true if `sourceDevice` has been explicitly set.
  var hasSourceDevice: Bool {return self._sourceDevice != nil}
  /// Clears the value of `sourceDevice`. Subsequent reads from it will return its default value.
  mutating func clearSourceDevice() {self._sourceDevice = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var serverTimestamp: UInt64 {
    get {return _serverTimestamp ?? 0}
    set {_serverTimestamp = newValue}
  }
  /// Returns true if `serverTimestamp` has been explicitly set.
  var hasServerTimestamp: Bool {return self._serverTimestamp != nil}
  /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearServerTimestamp() {self._serverTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: String? = nil
  fileprivate var _sourceDevice: UInt32? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _serverTimestamp: UInt64? = nil
}

struct DifftServiceProtos_TopicContext: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///纬度
  var type: DifftServiceProtos_TopicContext.TypeEnum {
    get {return _type ?? .user}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  ///群组类型
  var supportType: DifftServiceProtos_TopicContext.SupportType {
    get {return _supportType ?? .normal}
    set {_supportType = newValue}
  }
  /// Returns true if `supportType` has been explicitly set.
  var hasSupportType: Bool {return self._supportType != nil}
  /// Clears the value of `supportType`. Subsequent reads from it will return its default value.
  mutating func clearSupportType() {self._supportType = nil}

  var source: DifftServiceProtos_RealSource {
    get {return _source ?? DifftServiceProtos_RealSource()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  ///Topic简要
  var sourceBrief: String {
    get {return _sourceBrief ?? String()}
    set {_sourceBrief = newValue}
  }
  /// Returns true if `sourceBrief` has been explicitly set.
  var hasSourceBrief: Bool {return self._sourceBrief != nil}
  /// Clears the value of `sourceBrief`. Subsequent reads from it will return its default value.
  mutating func clearSourceBrief() {self._sourceBrief = nil}

  ///Topic发起人的displayName(截断的 部分展示的名字)
  var sourceDisplayName: String {
    get {return _sourceDisplayName ?? String()}
    set {_sourceDisplayName = newValue}
  }
  /// Returns true if `sourceDisplayName` has been explicitly set.
  var hasSourceDisplayName: Bool {return self._sourceDisplayName != nil}
  /// Clears the value of `sourceDisplayName`. Subsequent reads from it will return its default value.
  mutating func clearSourceDisplayName() {self._sourceDisplayName = nil}

  ///是否回复给用户
  var replyToUser: Bool {
    get {return _replyToUser ?? false}
    set {_replyToUser = newValue}
  }
  /// Returns true if `replyToUser` has been explicitly set.
  var hasReplyToUser: Bool {return self._replyToUser != nil}
  /// Clears the value of `replyToUser`. Subsequent reads from it will return its default value.
  mutating func clearReplyToUser() {self._replyToUser = nil}

  ///Topic发起方群组id
  var groupID: Data {
    get {return _groupID ?? Data()}
    set {_groupID = newValue}
  }
  /// Returns true if `groupID` has been explicitly set.
  var hasGroupID: Bool {return self._groupID != nil}
  /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
  mutating func clearGroupID() {self._groupID = nil}

  ///Topic发起方群组名称
  var groupName: String {
    get {return _groupName ?? String()}
    set {_groupName = newValue}
  }
  /// Returns true if `groupName` has been explicitly set.
  var hasGroupName: Bool {return self._groupName != nil}
  /// Clears the value of `groupName`. Subsequent reads from it will return its default value.
  mutating func clearGroupName() {self._groupName = nil}

  ///机器人id
  var botID: String {
    get {return _botID ?? String()}
    set {_botID = newValue}
  }
  /// Returns true if `botID` has been explicitly set.
  var hasBotID: Bool {return self._botID != nil}
  /// Clears the value of `botID`. Subsequent reads from it will return its default value.
  mutating func clearBotID() {self._botID = nil}

  ///Topic唯一id
  var topicID: String {
    get {return _topicID ?? String()}
    set {_topicID = newValue}
  }
  /// Returns true if `topicID` has been explicitly set.
  var hasTopicID: Bool {return self._topicID != nil}
  /// Clears the value of `topicID`. Subsequent reads from it will return its default value.
  mutating func clearTopicID() {self._topicID = nil}

  ///mark内容
  var content: DifftServiceProtos_TopicContext.MarkContent {
    get {return _content ?? DifftServiceProtos_TopicContext.MarkContent()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///纬度
  enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case user = 0
    case message = 1

    init() {
      self = .user
    }

  }

  ///群组类型
  enum SupportType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case normal = 0
    case support = 1

    init() {
      self = .normal
    }

  }

  struct MarkContent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var mark: String {
      get {return _mark ?? String()}
      set {_mark = newValue}
    }
    /// Returns true if `mark` has been explicitly set.
    var hasMark: Bool {return self._mark != nil}
    /// Clears the value of `mark`. Subsequent reads from it will return its default value.
    mutating func clearMark() {self._mark = nil}

    var sequenceID: UInt64 {
      get {return _sequenceID ?? 0}
      set {_sequenceID = newValue}
    }
    /// Returns true if `sequenceID` has been explicitly set.
    var hasSequenceID: Bool {return self._sequenceID != nil}
    /// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
    mutating func clearSequenceID() {self._sequenceID = nil}

    var serverTimestamp: UInt64 {
      get {return _serverTimestamp ?? 0}
      set {_serverTimestamp = newValue}
    }
    /// Returns true if `serverTimestamp` has been explicitly set.
    var hasServerTimestamp: Bool {return self._serverTimestamp != nil}
    /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearServerTimestamp() {self._serverTimestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _mark: String? = nil
    fileprivate var _sequenceID: UInt64? = nil
    fileprivate var _serverTimestamp: UInt64? = nil
  }

  init() {}

  fileprivate var _type: DifftServiceProtos_TopicContext.TypeEnum? = nil
  fileprivate var _supportType: DifftServiceProtos_TopicContext.SupportType? = nil
  fileprivate var _source: DifftServiceProtos_RealSource? = nil
  fileprivate var _sourceBrief: String? = nil
  fileprivate var _sourceDisplayName: String? = nil
  fileprivate var _replyToUser: Bool? = nil
  fileprivate var _groupID: Data? = nil
  fileprivate var _groupName: String? = nil
  fileprivate var _botID: String? = nil
  fileprivate var _topicID: String? = nil
  fileprivate var _content: DifftServiceProtos_TopicContext.MarkContent? = nil
}

struct DifftServiceProtos_DataMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: String {
    get {return _storage._body ?? String()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var attachments: [DifftServiceProtos_AttachmentPointer] {
    get {return _storage._attachments}
    set {_uniqueStorage()._attachments = newValue}
  }

  var group: DifftServiceProtos_GroupContext {
    get {return _storage._group ?? DifftServiceProtos_GroupContext()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {_uniqueStorage()._group = nil}

  var flags: UInt32 {
    get {return _storage._flags ?? 0}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {_uniqueStorage()._flags = nil}

  var expireTimer: UInt32 {
    get {return _storage._expireTimer ?? 0}
    set {_uniqueStorage()._expireTimer = newValue}
  }
  /// Returns true if `expireTimer` has been explicitly set.
  var hasExpireTimer: Bool {return _storage._expireTimer != nil}
  /// Clears the value of `expireTimer`. Subsequent reads from it will return its default value.
  mutating func clearExpireTimer() {_uniqueStorage()._expireTimer = nil}

  var profileKey: Data {
    get {return _storage._profileKey ?? Data()}
    set {_uniqueStorage()._profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return _storage._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {_uniqueStorage()._profileKey = nil}

  var timestamp: UInt64 {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var quote: DifftServiceProtos_DataMessage.Quote {
    get {return _storage._quote ?? DifftServiceProtos_DataMessage.Quote()}
    set {_uniqueStorage()._quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return _storage._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {_uniqueStorage()._quote = nil}

  ///reserved 9;
  var atPersons: String {
    get {return _storage._atPersons ?? String()}
    set {_uniqueStorage()._atPersons = newValue}
  }
  /// Returns true if `atPersons` has been explicitly set.
  var hasAtPersons: Bool {return _storage._atPersons != nil}
  /// Clears the value of `atPersons`. Subsequent reads from it will return its default value.
  mutating func clearAtPersons() {_uniqueStorage()._atPersons = nil}

  var forwardContext: DifftServiceProtos_DataMessage.ForwardContext {
    get {return _storage._forwardContext ?? DifftServiceProtos_DataMessage.ForwardContext()}
    set {_uniqueStorage()._forwardContext = newValue}
  }
  /// Returns true if `forwardContext` has been explicitly set.
  var hasForwardContext: Bool {return _storage._forwardContext != nil}
  /// Clears the value of `forwardContext`. Subsequent reads from it will return its default value.
  mutating func clearForwardContext() {_uniqueStorage()._forwardContext = nil}

  var requiredProtocolVersion: UInt32 {
    get {return _storage._requiredProtocolVersion ?? 0}
    set {_uniqueStorage()._requiredProtocolVersion = newValue}
  }
  /// Returns true if `requiredProtocolVersion` has been explicitly set.
  var hasRequiredProtocolVersion: Bool {return _storage._requiredProtocolVersion != nil}
  /// Clears the value of `requiredProtocolVersion`. Subsequent reads from it will return its default value.
  mutating func clearRequiredProtocolVersion() {_uniqueStorage()._requiredProtocolVersion = nil}

  var contact: [DifftServiceProtos_DataMessage.Contact] {
    get {return _storage._contact}
    set {_uniqueStorage()._contact = newValue}
  }

  var recall: DifftServiceProtos_DataMessage.Recall {
    get {return _storage._recall ?? DifftServiceProtos_DataMessage.Recall()}
    set {_uniqueStorage()._recall = newValue}
  }
  /// Returns true if `recall` has been explicitly set.
  var hasRecall: Bool {return _storage._recall != nil}
  /// Clears the value of `recall`. Subsequent reads from it will return its default value.
  mutating func clearRecall() {_uniqueStorage()._recall = nil}

  var task: DifftServiceProtos_DataMessage.Task {
    get {return _storage._task ?? DifftServiceProtos_DataMessage.Task()}
    set {_uniqueStorage()._task = newValue}
  }
  /// Returns true if `task` has been explicitly set.
  var hasTask: Bool {return _storage._task != nil}
  /// Clears the value of `task`. Subsequent reads from it will return its default value.
  mutating func clearTask() {_uniqueStorage()._task = nil}

  var vote: DifftServiceProtos_DataMessage.Vote {
    get {return _storage._vote ?? DifftServiceProtos_DataMessage.Vote()}
    set {_uniqueStorage()._vote = newValue}
  }
  /// Returns true if `vote` has been explicitly set.
  var hasVote: Bool {return _storage._vote != nil}
  /// Clears the value of `vote`. Subsequent reads from it will return its default value.
  mutating func clearVote() {_uniqueStorage()._vote = nil}

  var botContext: DifftServiceProtos_DataMessage.BotContext {
    get {return _storage._botContext ?? DifftServiceProtos_DataMessage.BotContext()}
    set {_uniqueStorage()._botContext = newValue}
  }
  /// Returns true if `botContext` has been explicitly set.
  var hasBotContext: Bool {return _storage._botContext != nil}
  /// Clears the value of `botContext`. Subsequent reads from it will return its default value.
  mutating func clearBotContext() {_uniqueStorage()._botContext = nil}

  var threadContext: DifftServiceProtos_DataMessage.ThreadContext {
    get {return _storage._threadContext ?? DifftServiceProtos_DataMessage.ThreadContext()}
    set {_uniqueStorage()._threadContext = newValue}
  }
  /// Returns true if `threadContext` has been explicitly set.
  var hasThreadContext: Bool {return _storage._threadContext != nil}
  /// Clears the value of `threadContext`. Subsequent reads from it will return its default value.
  mutating func clearThreadContext() {_uniqueStorage()._threadContext = nil}

  var topicContext: DifftServiceProtos_TopicContext {
    get {return _storage._topicContext ?? DifftServiceProtos_TopicContext()}
    set {_uniqueStorage()._topicContext = newValue}
  }
  /// Returns true if `topicContext` has been explicitly set.
  var hasTopicContext: Bool {return _storage._topicContext != nil}
  /// Clears the value of `topicContext`. Subsequent reads from it will return its default value.
  mutating func clearTopicContext() {_uniqueStorage()._topicContext = nil}

  var reaction: DifftServiceProtos_DataMessage.Reaction {
    get {return _storage._reaction ?? DifftServiceProtos_DataMessage.Reaction()}
    set {_uniqueStorage()._reaction = newValue}
  }
  /// Returns true if `reaction` has been explicitly set.
  var hasReaction: Bool {return _storage._reaction != nil}
  /// Clears the value of `reaction`. Subsequent reads from it will return its default value.
  mutating func clearReaction() {_uniqueStorage()._reaction = nil}

  var card: DifftServiceProtos_Card {
    get {return _storage._card ?? DifftServiceProtos_Card()}
    set {_uniqueStorage()._card = newValue}
  }
  /// Returns true if `card` has been explicitly set.
  var hasCard: Bool {return _storage._card != nil}
  /// Clears the value of `card`. Subsequent reads from it will return its default value.
  mutating func clearCard() {_uniqueStorage()._card = nil}

  var mentions: [DifftServiceProtos_DataMessage.Mention] {
    get {return _storage._mentions}
    set {_uniqueStorage()._mentions = newValue}
  }

  var messageMode: UInt32 {
    get {return _storage._messageMode ?? 0}
    set {_uniqueStorage()._messageMode = newValue}
  }
  /// Returns true if `messageMode` has been explicitly set.
  var hasMessageMode: Bool {return _storage._messageMode != nil}
  /// Clears the value of `messageMode`. Subsequent reads from it will return its default value.
  mutating func clearMessageMode() {_uniqueStorage()._messageMode = nil}

  var screenShot: DifftServiceProtos_DataMessage.ScreenShot {
    get {return _storage._screenShot ?? DifftServiceProtos_DataMessage.ScreenShot()}
    set {_uniqueStorage()._screenShot = newValue}
  }
  /// Returns true if `screenShot` has been explicitly set.
  var hasScreenShot: Bool {return _storage._screenShot != nil}
  /// Clears the value of `screenShot`. Subsequent reads from it will return its default value.
  mutating func clearScreenShot() {_uniqueStorage()._screenShot = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case endSession = 1
    case expirationTimerUpdate = 2
    case profileKeyUpdate = 4

    init() {
      self = .endSession
    }

  }

  enum ProtocolVersion: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case initial = 0
    case forward = 1
    case contact = 2
    case recall = 3
    case task = 4
    case vote = 5
    case reaction = 6
    case card = 7
    case confide = 8
    case screenShot = 9
    case verify = 10
    static let current = verify

    init() {
      self = .initial
    }

  }

  enum MessageMode: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case normal = 0
    case confidential = 1

    init() {
      self = .normal
    }

  }

  struct Quote: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var author: String {
      get {return _author ?? String()}
      set {_author = newValue}
    }
    /// Returns true if `author` has been explicitly set.
    var hasAuthor: Bool {return self._author != nil}
    /// Clears the value of `author`. Subsequent reads from it will return its default value.
    mutating func clearAuthor() {self._author = nil}

    var text: String {
      get {return _text ?? String()}
      set {_text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    var hasText: Bool {return self._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    mutating func clearText() {self._text = nil}

    var attachments: [DifftServiceProtos_DataMessage.Quote.QuotedAttachment] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct QuotedAttachment: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var contentType: String {
        get {return _contentType ?? String()}
        set {_contentType = newValue}
      }
      /// Returns true if `contentType` has been explicitly set.
      var hasContentType: Bool {return self._contentType != nil}
      /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
      mutating func clearContentType() {self._contentType = nil}

      var fileName: String {
        get {return _fileName ?? String()}
        set {_fileName = newValue}
      }
      /// Returns true if `fileName` has been explicitly set.
      var hasFileName: Bool {return self._fileName != nil}
      /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
      mutating func clearFileName() {self._fileName = nil}

      var thumbnail: DifftServiceProtos_AttachmentPointer {
        get {return _thumbnail ?? DifftServiceProtos_AttachmentPointer()}
        set {_thumbnail = newValue}
      }
      /// Returns true if `thumbnail` has been explicitly set.
      var hasThumbnail: Bool {return self._thumbnail != nil}
      /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
      mutating func clearThumbnail() {self._thumbnail = nil}

      var flags: UInt32 {
        get {return _flags ?? 0}
        set {_flags = newValue}
      }
      /// Returns true if `flags` has been explicitly set.
      var hasFlags: Bool {return self._flags != nil}
      /// Clears the value of `flags`. Subsequent reads from it will return its default value.
      mutating func clearFlags() {self._flags = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Flags: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
        case voiceMessage = 1

        init() {
          self = .voiceMessage
        }

      }

      init() {}

      fileprivate var _contentType: String? = nil
      fileprivate var _fileName: String? = nil
      fileprivate var _thumbnail: DifftServiceProtos_AttachmentPointer? = nil
      fileprivate var _flags: UInt32? = nil
    }

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _author: String? = nil
    fileprivate var _text: String? = nil
  }

  struct Forward: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: UInt64 {
      get {return _storage._id ?? 0}
      set {_uniqueStorage()._id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return _storage._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {_uniqueStorage()._id = nil}

    var type: UInt32 {
      get {return _storage._type ?? 0}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {_uniqueStorage()._type = nil}

    var isFromGroup: Bool {
      get {return _storage._isFromGroup ?? false}
      set {_uniqueStorage()._isFromGroup = newValue}
    }
    /// Returns true if `isFromGroup` has been explicitly set.
    var hasIsFromGroup: Bool {return _storage._isFromGroup != nil}
    /// Clears the value of `isFromGroup`. Subsequent reads from it will return its default value.
    mutating func clearIsFromGroup() {_uniqueStorage()._isFromGroup = nil}

    var author: String {
      get {return _storage._author ?? String()}
      set {_uniqueStorage()._author = newValue}
    }
    /// Returns true if `author` has been explicitly set.
    var hasAuthor: Bool {return _storage._author != nil}
    /// Clears the value of `author`. Subsequent reads from it will return its default value.
    mutating func clearAuthor() {_uniqueStorage()._author = nil}

    var text: String {
      get {return _storage._text ?? String()}
      set {_uniqueStorage()._text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    var hasText: Bool {return _storage._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    mutating func clearText() {_uniqueStorage()._text = nil}

    var attachments: [DifftServiceProtos_AttachmentPointer] {
      get {return _storage._attachments}
      set {_uniqueStorage()._attachments = newValue}
    }

    var forwards: [DifftServiceProtos_DataMessage.Forward] {
      get {return _storage._forwards}
      set {_uniqueStorage()._forwards = newValue}
    }

    var card: DifftServiceProtos_Card {
      get {return _storage._card ?? DifftServiceProtos_Card()}
      set {_uniqueStorage()._card = newValue}
    }
    /// Returns true if `card` has been explicitly set.
    var hasCard: Bool {return _storage._card != nil}
    /// Clears the value of `card`. Subsequent reads from it will return its default value.
    mutating func clearCard() {_uniqueStorage()._card = nil}

    var mentions: [DifftServiceProtos_DataMessage.Mention] {
      get {return _storage._mentions}
      set {_uniqueStorage()._mentions = newValue}
    }

    var serverTimestamp: UInt64 {
      get {return _storage._serverTimestamp ?? 0}
      set {_uniqueStorage()._serverTimestamp = newValue}
    }
    /// Returns true if `serverTimestamp` has been explicitly set.
    var hasServerTimestamp: Bool {return _storage._serverTimestamp != nil}
    /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearServerTimestamp() {_uniqueStorage()._serverTimestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case normal = 0
      case eof = 1

      init() {
        self = .normal
      }

    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct ForwardContext: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var forwards: [DifftServiceProtos_DataMessage.Forward] = []

    var rapidFiles: [DifftServiceProtos_RapidFile] = []

    var isFromGroup: Bool {
      get {return _isFromGroup ?? false}
      set {_isFromGroup = newValue}
    }
    /// Returns true if `isFromGroup` has been explicitly set.
    var hasIsFromGroup: Bool {return self._isFromGroup != nil}
    /// Clears the value of `isFromGroup`. Subsequent reads from it will return its default value.
    mutating func clearIsFromGroup() {self._isFromGroup = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _isFromGroup: Bool? = nil
  }

  struct Contact: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var name: DifftServiceProtos_DataMessage.Contact.Name {
      get {return _storage._name ?? DifftServiceProtos_DataMessage.Contact.Name()}
      set {_uniqueStorage()._name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return _storage._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {_uniqueStorage()._name = nil}

    var number: [DifftServiceProtos_DataMessage.Contact.Phone] {
      get {return _storage._number}
      set {_uniqueStorage()._number = newValue}
    }

    var email: [DifftServiceProtos_DataMessage.Contact.Email] {
      get {return _storage._email}
      set {_uniqueStorage()._email = newValue}
    }

    var address: [DifftServiceProtos_DataMessage.Contact.PostalAddress] {
      get {return _storage._address}
      set {_uniqueStorage()._address = newValue}
    }

    var avatar: DifftServiceProtos_DataMessage.Contact.Avatar {
      get {return _storage._avatar ?? DifftServiceProtos_DataMessage.Contact.Avatar()}
      set {_uniqueStorage()._avatar = newValue}
    }
    /// Returns true if `avatar` has been explicitly set.
    var hasAvatar: Bool {return _storage._avatar != nil}
    /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
    mutating func clearAvatar() {_uniqueStorage()._avatar = nil}

    var organization: String {
      get {return _storage._organization ?? String()}
      set {_uniqueStorage()._organization = newValue}
    }
    /// Returns true if `organization` has been explicitly set.
    var hasOrganization: Bool {return _storage._organization != nil}
    /// Clears the value of `organization`. Subsequent reads from it will return its default value.
    mutating func clearOrganization() {_uniqueStorage()._organization = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Name: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var givenName: String {
        get {return _givenName ?? String()}
        set {_givenName = newValue}
      }
      /// Returns true if `givenName` has been explicitly set.
      var hasGivenName: Bool {return self._givenName != nil}
      /// Clears the value of `givenName`. Subsequent reads from it will return its default value.
      mutating func clearGivenName() {self._givenName = nil}

      var familyName: String {
        get {return _familyName ?? String()}
        set {_familyName = newValue}
      }
      /// Returns true if `familyName` has been explicitly set.
      var hasFamilyName: Bool {return self._familyName != nil}
      /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
      mutating func clearFamilyName() {self._familyName = nil}

      var prefix: String {
        get {return _prefix ?? String()}
        set {_prefix = newValue}
      }
      /// Returns true if `prefix` has been explicitly set.
      var hasPrefix: Bool {return self._prefix != nil}
      /// Clears the value of `prefix`. Subsequent reads from it will return its default value.
      mutating func clearPrefix() {self._prefix = nil}

      var suffix: String {
        get {return _suffix ?? String()}
        set {_suffix = newValue}
      }
      /// Returns true if `suffix` has been explicitly set.
      var hasSuffix: Bool {return self._suffix != nil}
      /// Clears the value of `suffix`. Subsequent reads from it will return its default value.
      mutating func clearSuffix() {self._suffix = nil}

      var middleName: String {
        get {return _middleName ?? String()}
        set {_middleName = newValue}
      }
      /// Returns true if `middleName` has been explicitly set.
      var hasMiddleName: Bool {return self._middleName != nil}
      /// Clears the value of `middleName`. Subsequent reads from it will return its default value.
      mutating func clearMiddleName() {self._middleName = nil}

      var displayName: String {
        get {return _displayName ?? String()}
        set {_displayName = newValue}
      }
      /// Returns true if `displayName` has been explicitly set.
      var hasDisplayName: Bool {return self._displayName != nil}
      /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
      mutating func clearDisplayName() {self._displayName = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _givenName: String? = nil
      fileprivate var _familyName: String? = nil
      fileprivate var _prefix: String? = nil
      fileprivate var _suffix: String? = nil
      fileprivate var _middleName: String? = nil
      fileprivate var _displayName: String? = nil
    }

    struct Phone: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: String {
        get {return _value ?? String()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      mutating func clearValue() {self._value = nil}

      var type: DifftServiceProtos_DataMessage.Contact.Phone.TypeEnum {
        get {return _type ?? .home}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      mutating func clearType() {self._type = nil}

      var label: String {
        get {return _label ?? String()}
        set {_label = newValue}
      }
      /// Returns true if `label` has been explicitly set.
      var hasLabel: Bool {return self._label != nil}
      /// Clears the value of `label`. Subsequent reads from it will return its default value.
      mutating func clearLabel() {self._label = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
        case home = 1
        case mobile = 2
        case work = 3
        case custom = 4

        init() {
          self = .home
        }

      }

      init() {}

      fileprivate var _value: String? = nil
      fileprivate var _type: DifftServiceProtos_DataMessage.Contact.Phone.TypeEnum? = nil
      fileprivate var _label: String? = nil
    }

    struct Email: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var value: String {
        get {return _value ?? String()}
        set {_value = newValue}
      }
      /// Returns true if `value` has been explicitly set.
      var hasValue: Bool {return self._value != nil}
      /// Clears the value of `value`. Subsequent reads from it will return its default value.
      mutating func clearValue() {self._value = nil}

      var type: DifftServiceProtos_DataMessage.Contact.Email.TypeEnum {
        get {return _type ?? .home}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      mutating func clearType() {self._type = nil}

      var label: String {
        get {return _label ?? String()}
        set {_label = newValue}
      }
      /// Returns true if `label` has been explicitly set.
      var hasLabel: Bool {return self._label != nil}
      /// Clears the value of `label`. Subsequent reads from it will return its default value.
      mutating func clearLabel() {self._label = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
        case home = 1
        case mobile = 2
        case work = 3
        case custom = 4

        init() {
          self = .home
        }

      }

      init() {}

      fileprivate var _value: String? = nil
      fileprivate var _type: DifftServiceProtos_DataMessage.Contact.Email.TypeEnum? = nil
      fileprivate var _label: String? = nil
    }

    struct PostalAddress: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var type: DifftServiceProtos_DataMessage.Contact.PostalAddress.TypeEnum {
        get {return _type ?? .home}
        set {_type = newValue}
      }
      /// Returns true if `type` has been explicitly set.
      var hasType: Bool {return self._type != nil}
      /// Clears the value of `type`. Subsequent reads from it will return its default value.
      mutating func clearType() {self._type = nil}

      var label: String {
        get {return _label ?? String()}
        set {_label = newValue}
      }
      /// Returns true if `label` has been explicitly set.
      var hasLabel: Bool {return self._label != nil}
      /// Clears the value of `label`. Subsequent reads from it will return its default value.
      mutating func clearLabel() {self._label = nil}

      var street: String {
        get {return _street ?? String()}
        set {_street = newValue}
      }
      /// Returns true if `street` has been explicitly set.
      var hasStreet: Bool {return self._street != nil}
      /// Clears the value of `street`. Subsequent reads from it will return its default value.
      mutating func clearStreet() {self._street = nil}

      var pobox: String {
        get {return _pobox ?? String()}
        set {_pobox = newValue}
      }
      /// Returns true if `pobox` has been explicitly set.
      var hasPobox: Bool {return self._pobox != nil}
      /// Clears the value of `pobox`. Subsequent reads from it will return its default value.
      mutating func clearPobox() {self._pobox = nil}

      var neighborhood: String {
        get {return _neighborhood ?? String()}
        set {_neighborhood = newValue}
      }
      /// Returns true if `neighborhood` has been explicitly set.
      var hasNeighborhood: Bool {return self._neighborhood != nil}
      /// Clears the value of `neighborhood`. Subsequent reads from it will return its default value.
      mutating func clearNeighborhood() {self._neighborhood = nil}

      var city: String {
        get {return _city ?? String()}
        set {_city = newValue}
      }
      /// Returns true if `city` has been explicitly set.
      var hasCity: Bool {return self._city != nil}
      /// Clears the value of `city`. Subsequent reads from it will return its default value.
      mutating func clearCity() {self._city = nil}

      var region: String {
        get {return _region ?? String()}
        set {_region = newValue}
      }
      /// Returns true if `region` has been explicitly set.
      var hasRegion: Bool {return self._region != nil}
      /// Clears the value of `region`. Subsequent reads from it will return its default value.
      mutating func clearRegion() {self._region = nil}

      var postcode: String {
        get {return _postcode ?? String()}
        set {_postcode = newValue}
      }
      /// Returns true if `postcode` has been explicitly set.
      var hasPostcode: Bool {return self._postcode != nil}
      /// Clears the value of `postcode`. Subsequent reads from it will return its default value.
      mutating func clearPostcode() {self._postcode = nil}

      var country: String {
        get {return _country ?? String()}
        set {_country = newValue}
      }
      /// Returns true if `country` has been explicitly set.
      var hasCountry: Bool {return self._country != nil}
      /// Clears the value of `country`. Subsequent reads from it will return its default value.
      mutating func clearCountry() {self._country = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
        case home = 1
        case work = 2
        case custom = 3

        init() {
          self = .home
        }

      }

      init() {}

      fileprivate var _type: DifftServiceProtos_DataMessage.Contact.PostalAddress.TypeEnum? = nil
      fileprivate var _label: String? = nil
      fileprivate var _street: String? = nil
      fileprivate var _pobox: String? = nil
      fileprivate var _neighborhood: String? = nil
      fileprivate var _city: String? = nil
      fileprivate var _region: String? = nil
      fileprivate var _postcode: String? = nil
      fileprivate var _country: String? = nil
    }

    struct Avatar: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var avatar: DifftServiceProtos_AttachmentPointer {
        get {return _avatar ?? DifftServiceProtos_AttachmentPointer()}
        set {_avatar = newValue}
      }
      /// Returns true if `avatar` has been explicitly set.
      var hasAvatar: Bool {return self._avatar != nil}
      /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
      mutating func clearAvatar() {self._avatar = nil}

      var isProfile: Bool {
        get {return _isProfile ?? false}
        set {_isProfile = newValue}
      }
      /// Returns true if `isProfile` has been explicitly set.
      var hasIsProfile: Bool {return self._isProfile != nil}
      /// Clears the value of `isProfile`. Subsequent reads from it will return its default value.
      mutating func clearIsProfile() {self._isProfile = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _avatar: DifftServiceProtos_AttachmentPointer? = nil
      fileprivate var _isProfile: Bool? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Recall: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: DifftServiceProtos_RealSource {
      get {return _source ?? DifftServiceProtos_RealSource()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _source: DifftServiceProtos_RealSource? = nil
  }

  struct ScreenShot: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: DifftServiceProtos_RealSource {
      get {return _source ?? DifftServiceProtos_RealSource()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _source: DifftServiceProtos_RealSource? = nil
  }

  struct Task: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var taskID: String {
      get {return _taskID ?? String()}
      set {_taskID = newValue}
    }
    /// Returns true if `taskID` has been explicitly set.
    var hasTaskID: Bool {return self._taskID != nil}
    /// Clears the value of `taskID`. Subsequent reads from it will return its default value.
    mutating func clearTaskID() {self._taskID = nil}

    var version: UInt32 {
      get {return _version ?? 0}
      set {_version = newValue}
    }
    /// Returns true if `version` has been explicitly set.
    var hasVersion: Bool {return self._version != nil}
    /// Clears the value of `version`. Subsequent reads from it will return its default value.
    mutating func clearVersion() {self._version = nil}

    var creator: String {
      get {return _creator ?? String()}
      set {_creator = newValue}
    }
    /// Returns true if `creator` has been explicitly set.
    var hasCreator: Bool {return self._creator != nil}
    /// Clears the value of `creator`. Subsequent reads from it will return its default value.
    mutating func clearCreator() {self._creator = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var notes: String {
      get {return _notes ?? String()}
      set {_notes = newValue}
    }
    /// Returns true if `notes` has been explicitly set.
    var hasNotes: Bool {return self._notes != nil}
    /// Clears the value of `notes`. Subsequent reads from it will return its default value.
    mutating func clearNotes() {self._notes = nil}

    var assignees: [String] = []

    var dueTime: UInt64 {
      get {return _dueTime ?? 0}
      set {_dueTime = newValue}
    }
    /// Returns true if `dueTime` has been explicitly set.
    var hasDueTime: Bool {return self._dueTime != nil}
    /// Clears the value of `dueTime`. Subsequent reads from it will return its default value.
    mutating func clearDueTime() {self._dueTime = nil}

    var priority: UInt32 {
      get {return _priority ?? 0}
      set {_priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    var hasPriority: Bool {return self._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    mutating func clearPriority() {self._priority = nil}

    var followers: [String] = []

    var status: UInt32 {
      get {return _status ?? 0}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    mutating func clearStatus() {self._status = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Priority: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case p0 = 1
      case p1 = 2
      case p2 = 3

      init() {
        self = .p0
      }

    }

    enum Status: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case initial = 1
      case rejected = 11
      case completed = 12
      case canceled = 13

      init() {
        self = .initial
      }

    }

    init() {}

    fileprivate var _taskID: String? = nil
    fileprivate var _version: UInt32? = nil
    fileprivate var _creator: String? = nil
    fileprivate var _timestamp: UInt64? = nil
    fileprivate var _name: String? = nil
    fileprivate var _notes: String? = nil
    fileprivate var _dueTime: UInt64? = nil
    fileprivate var _priority: UInt32? = nil
    fileprivate var _status: UInt32? = nil
  }

  struct Vote: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var voteID: String {
      get {return _voteID ?? String()}
      set {_voteID = newValue}
    }
    /// Returns true if `voteID` has been explicitly set.
    var hasVoteID: Bool {return self._voteID != nil}
    /// Clears the value of `voteID`. Subsequent reads from it will return its default value.
    mutating func clearVoteID() {self._voteID = nil}

    var version: UInt32 {
      get {return _version ?? 0}
      set {_version = newValue}
    }
    /// Returns true if `version` has been explicitly set.
    var hasVersion: Bool {return self._version != nil}
    /// Clears the value of `version`. Subsequent reads from it will return its default value.
    mutating func clearVersion() {self._version = nil}

    var creator: String {
      get {return _creator ?? String()}
      set {_creator = newValue}
    }
    /// Returns true if `creator` has been explicitly set.
    var hasCreator: Bool {return self._creator != nil}
    /// Clears the value of `creator`. Subsequent reads from it will return its default value.
    mutating func clearCreator() {self._creator = nil}

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var options: [DifftServiceProtos_DataMessage.Vote.Option] = []

    var multiple: Bool {
      get {return _multiple ?? false}
      set {_multiple = newValue}
    }
    /// Returns true if `multiple` has been explicitly set.
    var hasMultiple: Bool {return self._multiple != nil}
    /// Clears the value of `multiple`. Subsequent reads from it will return its default value.
    mutating func clearMultiple() {self._multiple = nil}

    var dueTime: UInt64 {
      get {return _dueTime ?? 0}
      set {_dueTime = newValue}
    }
    /// Returns true if `dueTime` has been explicitly set.
    var hasDueTime: Bool {return self._dueTime != nil}
    /// Clears the value of `dueTime`. Subsequent reads from it will return its default value.
    mutating func clearDueTime() {self._dueTime = nil}

    var status: UInt32 {
      get {return _status ?? 0}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    mutating func clearStatus() {self._status = nil}

    var anonymous: UInt32 {
      get {return _anonymous ?? 0}
      set {_anonymous = newValue}
    }
    /// Returns true if `anonymous` has been explicitly set.
    var hasAnonymous: Bool {return self._anonymous != nil}
    /// Clears the value of `anonymous`. Subsequent reads from it will return its default value.
    mutating func clearAnonymous() {self._anonymous = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Status: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case initial = 1
      case closed = 2

      init() {
        self = .initial
      }

    }

    struct Option: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var id: UInt32 {
        get {return _id ?? 0}
        set {_id = newValue}
      }
      /// Returns true if `id` has been explicitly set.
      var hasID: Bool {return self._id != nil}
      /// Clears the value of `id`. Subsequent reads from it will return its default value.
      mutating func clearID() {self._id = nil}

      var name: String {
        get {return _name ?? String()}
        set {_name = newValue}
      }
      /// Returns true if `name` has been explicitly set.
      var hasName: Bool {return self._name != nil}
      /// Clears the value of `name`. Subsequent reads from it will return its default value.
      mutating func clearName() {self._name = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _id: UInt32? = nil
      fileprivate var _name: String? = nil
    }

    init() {}

    fileprivate var _voteID: String? = nil
    fileprivate var _version: UInt32? = nil
    fileprivate var _creator: String? = nil
    fileprivate var _name: String? = nil
    fileprivate var _multiple: Bool? = nil
    fileprivate var _dueTime: UInt64? = nil
    fileprivate var _status: UInt32? = nil
    fileprivate var _anonymous: UInt32? = nil
  }

  struct Reaction: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: DifftServiceProtos_RealSource {
      get {return _source ?? DifftServiceProtos_RealSource()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var emoji: String {
      get {return _emoji ?? String()}
      set {_emoji = newValue}
    }
    /// Returns true if `emoji` has been explicitly set.
    var hasEmoji: Bool {return self._emoji != nil}
    /// Clears the value of `emoji`. Subsequent reads from it will return its default value.
    mutating func clearEmoji() {self._emoji = nil}

    var remove: Bool {
      get {return _remove ?? false}
      set {_remove = newValue}
    }
    /// Returns true if `remove` has been explicitly set.
    var hasRemove: Bool {return self._remove != nil}
    /// Clears the value of `remove`. Subsequent reads from it will return its default value.
    mutating func clearRemove() {self._remove = nil}

    var originTimestamp: UInt64 {
      get {return _originTimestamp ?? 0}
      set {_originTimestamp = newValue}
    }
    /// Returns true if `originTimestamp` has been explicitly set.
    var hasOriginTimestamp: Bool {return self._originTimestamp != nil}
    /// Clears the value of `originTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearOriginTimestamp() {self._originTimestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _source: DifftServiceProtos_RealSource? = nil
    fileprivate var _emoji: String? = nil
    fileprivate var _remove: Bool? = nil
    fileprivate var _originTimestamp: UInt64? = nil
  }

  struct Mention: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var start: UInt32 {
      get {return _start ?? 0}
      set {_start = newValue}
    }
    /// Returns true if `start` has been explicitly set.
    var hasStart: Bool {return self._start != nil}
    /// Clears the value of `start`. Subsequent reads from it will return its default value.
    mutating func clearStart() {self._start = nil}

    var length: UInt32 {
      get {return _length ?? 0}
      set {_length = newValue}
    }
    /// Returns true if `length` has been explicitly set.
    var hasLength: Bool {return self._length != nil}
    /// Clears the value of `length`. Subsequent reads from it will return its default value.
    mutating func clearLength() {self._length = nil}

    var uid: String {
      get {return _uid ?? String()}
      set {_uid = newValue}
    }
    /// Returns true if `uid` has been explicitly set.
    var hasUid: Bool {return self._uid != nil}
    /// Clears the value of `uid`. Subsequent reads from it will return its default value.
    mutating func clearUid() {self._uid = nil}

    var type: DifftServiceProtos_DataMessage.Mention.TypeEnum {
      get {return _type ?? .internal}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

      ///群成员
      case `internal` = 0

      ///非群成员
      case external = 1

      init() {
        self = .internal
      }

    }

    init() {}

    fileprivate var _start: UInt32? = nil
    fileprivate var _length: UInt32? = nil
    fileprivate var _uid: String? = nil
    fileprivate var _type: DifftServiceProtos_DataMessage.Mention.TypeEnum? = nil
  }

  struct BotContext: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: DifftServiceProtos_DataMessage.BotContext.TypeEnum {
      get {return _type ?? .support}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var source: DifftServiceProtos_RealSource {
      get {return _source ?? DifftServiceProtos_RealSource()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var groupID: Data {
      get {return _groupID ?? Data()}
      set {_groupID = newValue}
    }
    /// Returns true if `groupID` has been explicitly set.
    var hasGroupID: Bool {return self._groupID != nil}
    /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
    mutating func clearGroupID() {self._groupID = nil}

    var header: String {
      get {return _header ?? String()}
      set {_header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    var hasHeader: Bool {return self._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    mutating func clearHeader() {self._header = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case support = 1
      case announcement = 2

      init() {
        self = .support
      }

    }

    init() {}

    fileprivate var _type: DifftServiceProtos_DataMessage.BotContext.TypeEnum? = nil
    fileprivate var _source: DifftServiceProtos_RealSource? = nil
    fileprivate var _groupID: Data? = nil
    fileprivate var _header: String? = nil
  }

  struct ThreadContext: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var source: DifftServiceProtos_RealSource {
      get {return _source ?? DifftServiceProtos_RealSource()}
      set {_source = newValue}
    }
    /// Returns true if `source` has been explicitly set.
    var hasSource: Bool {return self._source != nil}
    /// Clears the value of `source`. Subsequent reads from it will return its default value.
    mutating func clearSource() {self._source = nil}

    var replyToUser: Bool {
      get {return _replyToUser ?? false}
      set {_replyToUser = newValue}
    }
    /// Returns true if `replyToUser` has been explicitly set.
    var hasReplyToUser: Bool {return self._replyToUser != nil}
    /// Clears the value of `replyToUser`. Subsequent reads from it will return its default value.
    mutating func clearReplyToUser() {self._replyToUser = nil}

    var groupID: Data {
      get {return _groupID ?? Data()}
      set {_groupID = newValue}
    }
    /// Returns true if `groupID` has been explicitly set.
    var hasGroupID: Bool {return self._groupID != nil}
    /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
    mutating func clearGroupID() {self._groupID = nil}

    var botID: String {
      get {return _botID ?? String()}
      set {_botID = newValue}
    }
    /// Returns true if `botID` has been explicitly set.
    var hasBotID: Bool {return self._botID != nil}
    /// Clears the value of `botID`. Subsequent reads from it will return its default value.
    mutating func clearBotID() {self._botID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _source: DifftServiceProtos_RealSource? = nil
    fileprivate var _replyToUser: Bool? = nil
    fileprivate var _groupID: Data? = nil
    fileprivate var _botID: String? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DifftServiceProtos_NullMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var padding: Data {
    get {return _padding ?? Data()}
    set {_padding = newValue}
  }
  /// Returns true if `padding` has been explicitly set.
  var hasPadding: Bool {return self._padding != nil}
  /// Clears the value of `padding`. Subsequent reads from it will return its default value.
  mutating func clearPadding() {self._padding = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _padding: Data? = nil
}

struct DifftServiceProtos_ReceiptMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: DifftServiceProtos_ReceiptMessage.TypeEnum {
    get {return _type ?? .delivery}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var timestamp: [UInt64] = []

  var readPosition: DifftServiceProtos_ReadPosition {
    get {return _readPosition ?? DifftServiceProtos_ReadPosition()}
    set {_readPosition = newValue}
  }
  /// Returns true if `readPosition` has been explicitly set.
  var hasReadPosition: Bool {return self._readPosition != nil}
  /// Clears the value of `readPosition`. Subsequent reads from it will return its default value.
  mutating func clearReadPosition() {self._readPosition = nil}

  var messageMode: UInt32 {
    get {return _messageMode ?? 0}
    set {_messageMode = newValue}
  }
  /// Returns true if `messageMode` has been explicitly set.
  var hasMessageMode: Bool {return self._messageMode != nil}
  /// Clears the value of `messageMode`. Subsequent reads from it will return its default value.
  mutating func clearMessageMode() {self._messageMode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case delivery = 0
    case read = 1

    init() {
      self = .delivery
    }

  }

  init() {}

  fileprivate var _type: DifftServiceProtos_ReceiptMessage.TypeEnum? = nil
  fileprivate var _readPosition: DifftServiceProtos_ReadPosition? = nil
  fileprivate var _messageMode: UInt32? = nil
}

struct DifftServiceProtos_TopicMark: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conversation: DifftServiceProtos_ConversationId {
    get {return _conversation ?? DifftServiceProtos_ConversationId()}
    set {_conversation = newValue}
  }
  /// Returns true if `conversation` has been explicitly set.
  var hasConversation: Bool {return self._conversation != nil}
  /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
  mutating func clearConversation() {self._conversation = nil}

  var topicID: String {
    get {return _topicID ?? String()}
    set {_topicID = newValue}
  }
  /// Returns true if `topicID` has been explicitly set.
  var hasTopicID: Bool {return self._topicID != nil}
  /// Clears the value of `topicID`. Subsequent reads from it will return its default value.
  mutating func clearTopicID() {self._topicID = nil}

  var mark: String {
    get {return _mark ?? String()}
    set {_mark = newValue}
  }
  /// Returns true if `mark` has been explicitly set.
  var hasMark: Bool {return self._mark != nil}
  /// Clears the value of `mark`. Subsequent reads from it will return its default value.
  mutating func clearMark() {self._mark = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _conversation: DifftServiceProtos_ConversationId? = nil
  fileprivate var _topicID: String? = nil
  fileprivate var _mark: String? = nil
}

struct DifftServiceProtos_TopicAction: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var actionType: DifftServiceProtos_TopicAction.ActionType {
    get {return _storage._actionType ?? .remove}
    set {_uniqueStorage()._actionType = newValue}
  }
  /// Returns true if `actionType` has been explicitly set.
  var hasActionType: Bool {return _storage._actionType != nil}
  /// Clears the value of `actionType`. Subsequent reads from it will return its default value.
  mutating func clearActionType() {_uniqueStorage()._actionType = nil}

  var conversationID: DifftServiceProtos_ConversationId {
    get {return _storage._conversationID ?? DifftServiceProtos_ConversationId()}
    set {_uniqueStorage()._conversationID = newValue}
  }
  /// Returns true if `conversationID` has been explicitly set.
  var hasConversationID: Bool {return _storage._conversationID != nil}
  /// Clears the value of `conversationID`. Subsequent reads from it will return its default value.
  mutating func clearConversationID() {_uniqueStorage()._conversationID = nil}

  /// 目標Topic Context信息
  var targetContext: DifftServiceProtos_TopicContext {
    get {return _storage._targetContext ?? DifftServiceProtos_TopicContext()}
    set {_uniqueStorage()._targetContext = newValue}
  }
  /// Returns true if `targetContext` has been explicitly set.
  var hasTargetContext: Bool {return _storage._targetContext != nil}
  /// Clears the value of `targetContext`. Subsequent reads from it will return its default value.
  mutating func clearTargetContext() {_uniqueStorage()._targetContext = nil}

  /// source Topic ID
  var sourceTopicID: String {
    get {return _storage._sourceTopicID ?? String()}
    set {_uniqueStorage()._sourceTopicID = newValue}
  }
  /// Returns true if `sourceTopicID` has been explicitly set.
  var hasSourceTopicID: Bool {return _storage._sourceTopicID != nil}
  /// Clears the value of `sourceTopicID`. Subsequent reads from it will return its default value.
  mutating func clearSourceTopicID() {_uniqueStorage()._sourceTopicID = nil}

  /// 消息 realSource
  var realSource: DifftServiceProtos_RealSource {
    get {return _storage._realSource ?? DifftServiceProtos_RealSource()}
    set {_uniqueStorage()._realSource = newValue}
  }
  /// Returns true if `realSource` has been explicitly set.
  var hasRealSource: Bool {return _storage._realSource != nil}
  /// Clears the value of `realSource`. Subsequent reads from it will return its default value.
  mutating func clearRealSource() {_uniqueStorage()._realSource = nil}

  /// 目標消息 realSource
  var targetRealSource: DifftServiceProtos_RealSource {
    get {return _storage._targetRealSource ?? DifftServiceProtos_RealSource()}
    set {_uniqueStorage()._targetRealSource = newValue}
  }
  /// Returns true if `targetRealSource` has been explicitly set.
  var hasTargetRealSource: Bool {return _storage._targetRealSource != nil}
  /// Clears the value of `targetRealSource`. Subsequent reads from it will return its default value.
  mutating func clearTargetRealSource() {_uniqueStorage()._targetRealSource = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ActionType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// 移出Topic, Topic A → nil
    case remove = 1

    /// 移入Topic, Topic nil → A or nil
    case add = 2

    /// 移動Topic, Topic A → B
    case move = 3

    init() {
      self = .remove
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///客户端通知类型的消息
struct DifftServiceProtos_NotifyMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topicMark: DifftServiceProtos_TopicMark {
    get {return _topicMark ?? DifftServiceProtos_TopicMark()}
    set {_topicMark = newValue}
  }
  /// Returns true if `topicMark` has been explicitly set.
  var hasTopicMark: Bool {return self._topicMark != nil}
  /// Clears the value of `topicMark`. Subsequent reads from it will return its default value.
  mutating func clearTopicMark() {self._topicMark = nil}

  var topicAction: DifftServiceProtos_TopicAction {
    get {return _topicAction ?? DifftServiceProtos_TopicAction()}
    set {_topicAction = newValue}
  }
  /// Returns true if `topicAction` has been explicitly set.
  var hasTopicAction: Bool {return self._topicAction != nil}
  /// Clears the value of `topicAction`. Subsequent reads from it will return its default value.
  mutating func clearTopicAction() {self._topicAction = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _topicMark: DifftServiceProtos_TopicMark? = nil
  fileprivate var _topicAction: DifftServiceProtos_TopicAction? = nil
}

struct DifftServiceProtos_ReadPosition: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var groupID: Data {
    get {return _groupID ?? Data()}
    set {_groupID = newValue}
  }
  /// Returns true if `groupID` has been explicitly set.
  var hasGroupID: Bool {return self._groupID != nil}
  /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
  mutating func clearGroupID() {self._groupID = nil}

  var readAt: UInt64 {
    get {return _readAt ?? 0}
    set {_readAt = newValue}
  }
  /// Returns true if `readAt` has been explicitly set.
  var hasReadAt: Bool {return self._readAt != nil}
  /// Clears the value of `readAt`. Subsequent reads from it will return its default value.
  mutating func clearReadAt() {self._readAt = nil}

  var maxServerTime: UInt64 {
    get {return _maxServerTime ?? 0}
    set {_maxServerTime = newValue}
  }
  /// Returns true if `maxServerTime` has been explicitly set.
  var hasMaxServerTime: Bool {return self._maxServerTime != nil}
  /// Clears the value of `maxServerTime`. Subsequent reads from it will return its default value.
  mutating func clearMaxServerTime() {self._maxServerTime = nil}

  var maxNotifySequenceID: UInt64 {
    get {return _maxNotifySequenceID ?? 0}
    set {_maxNotifySequenceID = newValue}
  }
  /// Returns true if `maxNotifySequenceID` has been explicitly set.
  var hasMaxNotifySequenceID: Bool {return self._maxNotifySequenceID != nil}
  /// Clears the value of `maxNotifySequenceID`. Subsequent reads from it will return its default value.
  mutating func clearMaxNotifySequenceID() {self._maxNotifySequenceID = nil}

  /// 新增
  var maxSequenceID: UInt64 {
    get {return _maxSequenceID ?? 0}
    set {_maxSequenceID = newValue}
  }
  /// Returns true if `maxSequenceID` has been explicitly set.
  var hasMaxSequenceID: Bool {return self._maxSequenceID != nil}
  /// Clears the value of `maxSequenceID`. Subsequent reads from it will return its default value.
  mutating func clearMaxSequenceID() {self._maxSequenceID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _groupID: Data? = nil
  fileprivate var _readAt: UInt64? = nil
  fileprivate var _maxServerTime: UInt64? = nil
  fileprivate var _maxNotifySequenceID: UInt64? = nil
  fileprivate var _maxSequenceID: UInt64? = nil
}

struct DifftServiceProtos_TypingMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var action: DifftServiceProtos_TypingMessage.Action {
    get {return _action ?? .started}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var groupID: Data {
    get {return _groupID ?? Data()}
    set {_groupID = newValue}
  }
  /// Returns true if `groupID` has been explicitly set.
  var hasGroupID: Bool {return self._groupID != nil}
  /// Clears the value of `groupID`. Subsequent reads from it will return its default value.
  mutating func clearGroupID() {self._groupID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Action: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case started = 0
    case stopped = 1

    init() {
      self = .started
    }

  }

  init() {}

  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _action: DifftServiceProtos_TypingMessage.Action? = nil
  fileprivate var _groupID: Data? = nil
}

struct DifftServiceProtos_Verified: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var destination: String {
    get {return _destination ?? String()}
    set {_destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  var hasDestination: Bool {return self._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  mutating func clearDestination() {self._destination = nil}

  var identityKey: Data {
    get {return _identityKey ?? Data()}
    set {_identityKey = newValue}
  }
  /// Returns true if `identityKey` has been explicitly set.
  var hasIdentityKey: Bool {return self._identityKey != nil}
  /// Clears the value of `identityKey`. Subsequent reads from it will return its default value.
  mutating func clearIdentityKey() {self._identityKey = nil}

  var state: DifftServiceProtos_Verified.State {
    get {return _state ?? .default}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var nullMessage: Data {
    get {return _nullMessage ?? Data()}
    set {_nullMessage = newValue}
  }
  /// Returns true if `nullMessage` has been explicitly set.
  var hasNullMessage: Bool {return self._nullMessage != nil}
  /// Clears the value of `nullMessage`. Subsequent reads from it will return its default value.
  mutating func clearNullMessage() {self._nullMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum State: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case `default` = 0
    case verified = 1
    case unverified = 2

    init() {
      self = .default
    }

  }

  init() {}

  fileprivate var _destination: String? = nil
  fileprivate var _identityKey: Data? = nil
  fileprivate var _state: DifftServiceProtos_Verified.State? = nil
  fileprivate var _nullMessage: Data? = nil
}

struct DifftServiceProtos_SyncMessage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sent: DifftServiceProtos_SyncMessage.Sent {
    get {return _storage._sent ?? DifftServiceProtos_SyncMessage.Sent()}
    set {_uniqueStorage()._sent = newValue}
  }
  /// Returns true if `sent` has been explicitly set.
  var hasSent: Bool {return _storage._sent != nil}
  /// Clears the value of `sent`. Subsequent reads from it will return its default value.
  mutating func clearSent() {_uniqueStorage()._sent = nil}

  var contacts: DifftServiceProtos_SyncMessage.Contacts {
    get {return _storage._contacts ?? DifftServiceProtos_SyncMessage.Contacts()}
    set {_uniqueStorage()._contacts = newValue}
  }
  /// Returns true if `contacts` has been explicitly set.
  var hasContacts: Bool {return _storage._contacts != nil}
  /// Clears the value of `contacts`. Subsequent reads from it will return its default value.
  mutating func clearContacts() {_uniqueStorage()._contacts = nil}

  var groups: DifftServiceProtos_SyncMessage.Groups {
    get {return _storage._groups ?? DifftServiceProtos_SyncMessage.Groups()}
    set {_uniqueStorage()._groups = newValue}
  }
  /// Returns true if `groups` has been explicitly set.
  var hasGroups: Bool {return _storage._groups != nil}
  /// Clears the value of `groups`. Subsequent reads from it will return its default value.
  mutating func clearGroups() {_uniqueStorage()._groups = nil}

  var request: DifftServiceProtos_SyncMessage.Request {
    get {return _storage._request ?? DifftServiceProtos_SyncMessage.Request()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {_uniqueStorage()._request = nil}

  var read: [DifftServiceProtos_SyncMessage.Read] {
    get {return _storage._read}
    set {_uniqueStorage()._read = newValue}
  }

  var blocked: DifftServiceProtos_SyncMessage.Blocked {
    get {return _storage._blocked ?? DifftServiceProtos_SyncMessage.Blocked()}
    set {_uniqueStorage()._blocked = newValue}
  }
  /// Returns true if `blocked` has been explicitly set.
  var hasBlocked: Bool {return _storage._blocked != nil}
  /// Clears the value of `blocked`. Subsequent reads from it will return its default value.
  mutating func clearBlocked() {_uniqueStorage()._blocked = nil}

  var verified: DifftServiceProtos_Verified {
    get {return _storage._verified ?? DifftServiceProtos_Verified()}
    set {_uniqueStorage()._verified = newValue}
  }
  /// Returns true if `verified` has been explicitly set.
  var hasVerified: Bool {return _storage._verified != nil}
  /// Clears the value of `verified`. Subsequent reads from it will return its default value.
  mutating func clearVerified() {_uniqueStorage()._verified = nil}

  var configuration: DifftServiceProtos_SyncMessage.Configuration {
    get {return _storage._configuration ?? DifftServiceProtos_SyncMessage.Configuration()}
    set {_uniqueStorage()._configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return _storage._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

  var padding: Data {
    get {return _storage._padding ?? Data()}
    set {_uniqueStorage()._padding = newValue}
  }
  /// Returns true if `padding` has been explicitly set.
  var hasPadding: Bool {return _storage._padding != nil}
  /// Clears the value of `padding`. Subsequent reads from it will return its default value.
  mutating func clearPadding() {_uniqueStorage()._padding = nil}

  var tasks: [DifftServiceProtos_SyncMessage.Task] {
    get {return _storage._tasks}
    set {_uniqueStorage()._tasks = newValue}
  }

  var markAsUnread: DifftServiceProtos_SyncMessage.MarkAsUnread {
    get {return _storage._markAsUnread ?? DifftServiceProtos_SyncMessage.MarkAsUnread()}
    set {_uniqueStorage()._markAsUnread = newValue}
  }
  /// Returns true if `markAsUnread` has been explicitly set.
  var hasMarkAsUnread: Bool {return _storage._markAsUnread != nil}
  /// Clears the value of `markAsUnread`. Subsequent reads from it will return its default value.
  mutating func clearMarkAsUnread() {_uniqueStorage()._markAsUnread = nil}

  var conversationArchive: DifftServiceProtos_SyncMessage.ConversationArchive {
    get {return _storage._conversationArchive ?? DifftServiceProtos_SyncMessage.ConversationArchive()}
    set {_uniqueStorage()._conversationArchive = newValue}
  }
  /// Returns true if `conversationArchive` has been explicitly set.
  var hasConversationArchive: Bool {return _storage._conversationArchive != nil}
  /// Clears the value of `conversationArchive`. Subsequent reads from it will return its default value.
  mutating func clearConversationArchive() {_uniqueStorage()._conversationArchive = nil}

  var markTopicAsTrack: DifftServiceProtos_SyncMessage.MarkTopicAsTrack {
    get {return _storage._markTopicAsTrack ?? DifftServiceProtos_SyncMessage.MarkTopicAsTrack()}
    set {_uniqueStorage()._markTopicAsTrack = newValue}
  }
  /// Returns true if `markTopicAsTrack` has been explicitly set.
  var hasMarkTopicAsTrack: Bool {return _storage._markTopicAsTrack != nil}
  /// Clears the value of `markTopicAsTrack`. Subsequent reads from it will return its default value.
  mutating func clearMarkTopicAsTrack() {_uniqueStorage()._markTopicAsTrack = nil}

  var topicMark: DifftServiceProtos_TopicMark {
    get {return _storage._topicMark ?? DifftServiceProtos_TopicMark()}
    set {_uniqueStorage()._topicMark = newValue}
  }
  /// Returns true if `topicMark` has been explicitly set.
  var hasTopicMark: Bool {return _storage._topicMark != nil}
  /// Clears the value of `topicMark`. Subsequent reads from it will return its default value.
  mutating func clearTopicMark() {_uniqueStorage()._topicMark = nil}

  var topicAction: DifftServiceProtos_TopicAction {
    get {return _storage._topicAction ?? DifftServiceProtos_TopicAction()}
    set {_uniqueStorage()._topicAction = newValue}
  }
  /// Returns true if `topicAction` has been explicitly set.
  var hasTopicAction: Bool {return _storage._topicAction != nil}
  /// Clears the value of `topicAction`. Subsequent reads from it will return its default value.
  mutating func clearTopicAction() {_uniqueStorage()._topicAction = nil}

  /// 操作時間
  var serverTimestamp: UInt64 {
    get {return _storage._serverTimestamp ?? 0}
    set {_uniqueStorage()._serverTimestamp = newValue}
  }
  /// Returns true if `serverTimestamp` has been explicitly set.
  var hasServerTimestamp: Bool {return _storage._serverTimestamp != nil}
  /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearServerTimestamp() {_uniqueStorage()._serverTimestamp = nil}

  var criticalRead: [DifftServiceProtos_SyncMessage.Read] {
    get {return _storage._criticalRead}
    set {_uniqueStorage()._criticalRead = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Sent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var destination: String {
      get {return _destination ?? String()}
      set {_destination = newValue}
    }
    /// Returns true if `destination` has been explicitly set.
    var hasDestination: Bool {return self._destination != nil}
    /// Clears the value of `destination`. Subsequent reads from it will return its default value.
    mutating func clearDestination() {self._destination = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var message: DifftServiceProtos_DataMessage {
      get {return _message ?? DifftServiceProtos_DataMessage()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var expirationStartTimestamp: UInt64 {
      get {return _expirationStartTimestamp ?? 0}
      set {_expirationStartTimestamp = newValue}
    }
    /// Returns true if `expirationStartTimestamp` has been explicitly set.
    var hasExpirationStartTimestamp: Bool {return self._expirationStartTimestamp != nil}
    /// Clears the value of `expirationStartTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearExpirationStartTimestamp() {self._expirationStartTimestamp = nil}

    var rapidFiles: [DifftServiceProtos_RapidFile] = []

    var serverTimestamp: UInt64 {
      get {return _serverTimestamp ?? 0}
      set {_serverTimestamp = newValue}
    }
    /// Returns true if `serverTimestamp` has been explicitly set.
    var hasServerTimestamp: Bool {return self._serverTimestamp != nil}
    /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
    mutating func clearServerTimestamp() {self._serverTimestamp = nil}

    var sequenceID: UInt64 {
      get {return _sequenceID ?? 0}
      set {_sequenceID = newValue}
    }
    /// Returns true if `sequenceID` has been explicitly set.
    var hasSequenceID: Bool {return self._sequenceID != nil}
    /// Clears the value of `sequenceID`. Subsequent reads from it will return its default value.
    mutating func clearSequenceID() {self._sequenceID = nil}

    var notifySequenceID: UInt64 {
      get {return _notifySequenceID ?? 0}
      set {_notifySequenceID = newValue}
    }
    /// Returns true if `notifySequenceID` has been explicitly set.
    var hasNotifySequenceID: Bool {return self._notifySequenceID != nil}
    /// Clears the value of `notifySequenceID`. Subsequent reads from it will return its default value.
    mutating func clearNotifySequenceID() {self._notifySequenceID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _destination: String? = nil
    fileprivate var _timestamp: UInt64? = nil
    fileprivate var _message: DifftServiceProtos_DataMessage? = nil
    fileprivate var _expirationStartTimestamp: UInt64? = nil
    fileprivate var _serverTimestamp: UInt64? = nil
    fileprivate var _sequenceID: UInt64? = nil
    fileprivate var _notifySequenceID: UInt64? = nil
  }

  struct Contacts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var blob: DifftServiceProtos_AttachmentPointer {
      get {return _blob ?? DifftServiceProtos_AttachmentPointer()}
      set {_blob = newValue}
    }
    /// Returns true if `blob` has been explicitly set.
    var hasBlob: Bool {return self._blob != nil}
    /// Clears the value of `blob`. Subsequent reads from it will return its default value.
    mutating func clearBlob() {self._blob = nil}

    /// Signal-iOS renamed this property.
    var isComplete: Bool {
      get {return _isComplete ?? false}
      set {_isComplete = newValue}
    }
    /// Returns true if `isComplete` has been explicitly set.
    var hasIsComplete: Bool {return self._isComplete != nil}
    /// Clears the value of `isComplete`. Subsequent reads from it will return its default value.
    mutating func clearIsComplete() {self._isComplete = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _blob: DifftServiceProtos_AttachmentPointer? = nil
    fileprivate var _isComplete: Bool? = nil
  }

  struct Groups: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var blob: DifftServiceProtos_AttachmentPointer {
      get {return _blob ?? DifftServiceProtos_AttachmentPointer()}
      set {_blob = newValue}
    }
    /// Returns true if `blob` has been explicitly set.
    var hasBlob: Bool {return self._blob != nil}
    /// Clears the value of `blob`. Subsequent reads from it will return its default value.
    mutating func clearBlob() {self._blob = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _blob: DifftServiceProtos_AttachmentPointer? = nil
  }

  struct Blocked: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var numbers: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Request: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: DifftServiceProtos_SyncMessage.Request.TypeEnum {
      get {return _type ?? .unknown}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case unknown = 0
      case contacts = 1
      case groups = 2
      case blocked = 3
      case configuration = 4

      init() {
        self = .unknown
      }

    }

    init() {}

    fileprivate var _type: DifftServiceProtos_SyncMessage.Request.TypeEnum? = nil
  }

  struct Read: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sender: String {
      get {return _sender ?? String()}
      set {_sender = newValue}
    }
    /// Returns true if `sender` has been explicitly set.
    var hasSender: Bool {return self._sender != nil}
    /// Clears the value of `sender`. Subsequent reads from it will return its default value.
    mutating func clearSender() {self._sender = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var readPosition: DifftServiceProtos_ReadPosition {
      get {return _readPosition ?? DifftServiceProtos_ReadPosition()}
      set {_readPosition = newValue}
    }
    /// Returns true if `readPosition` has been explicitly set.
    var hasReadPosition: Bool {return self._readPosition != nil}
    /// Clears the value of `readPosition`. Subsequent reads from it will return its default value.
    mutating func clearReadPosition() {self._readPosition = nil}

    var messageMode: UInt32 {
      get {return _messageMode ?? 0}
      set {_messageMode = newValue}
    }
    /// Returns true if `messageMode` has been explicitly set.
    var hasMessageMode: Bool {return self._messageMode != nil}
    /// Clears the value of `messageMode`. Subsequent reads from it will return its default value.
    mutating func clearMessageMode() {self._messageMode = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sender: String? = nil
    fileprivate var _timestamp: UInt64? = nil
    fileprivate var _readPosition: DifftServiceProtos_ReadPosition? = nil
    fileprivate var _messageMode: UInt32? = nil
  }

  struct Configuration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var readReceipts: Bool {
      get {return _readReceipts ?? false}
      set {_readReceipts = newValue}
    }
    /// Returns true if `readReceipts` has been explicitly set.
    var hasReadReceipts: Bool {return self._readReceipts != nil}
    /// Clears the value of `readReceipts`. Subsequent reads from it will return its default value.
    mutating func clearReadReceipts() {self._readReceipts = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _readReceipts: Bool? = nil
  }

  struct Task: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var taskID: String {
      get {return _taskID ?? String()}
      set {_taskID = newValue}
    }
    /// Returns true if `taskID` has been explicitly set.
    var hasTaskID: Bool {return self._taskID != nil}
    /// Clears the value of `taskID`. Subsequent reads from it will return its default value.
    mutating func clearTaskID() {self._taskID = nil}

    var version: UInt32 {
      get {return _version ?? 0}
      set {_version = newValue}
    }
    /// Returns true if `version` has been explicitly set.
    var hasVersion: Bool {return self._version != nil}
    /// Clears the value of `version`. Subsequent reads from it will return its default value.
    mutating func clearVersion() {self._version = nil}

    var type: UInt32 {
      get {return _type ?? 0}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var timestamp: UInt64 {
      get {return _timestamp ?? 0}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    mutating func clearTimestamp() {self._timestamp = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case read = 0

      init() {
        self = .read
      }

    }

    init() {}

    fileprivate var _taskID: String? = nil
    fileprivate var _version: UInt32? = nil
    fileprivate var _type: UInt32? = nil
    fileprivate var _timestamp: UInt64? = nil
  }

  struct MarkTopicAsTrack: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var conversation: DifftServiceProtos_ConversationId {
      get {return _conversation ?? DifftServiceProtos_ConversationId()}
      set {_conversation = newValue}
    }
    /// Returns true if `conversation` has been explicitly set.
    var hasConversation: Bool {return self._conversation != nil}
    /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
    mutating func clearConversation() {self._conversation = nil}

    var topicID: String {
      get {return _topicID ?? String()}
      set {_topicID = newValue}
    }
    /// Returns true if `topicID` has been explicitly set.
    var hasTopicID: Bool {return self._topicID != nil}
    /// Clears the value of `topicID`. Subsequent reads from it will return its default value.
    mutating func clearTopicID() {self._topicID = nil}

    var flag: DifftServiceProtos_SyncMessage.MarkTopicAsTrack.Flag {
      get {return _flag ?? .track}
      set {_flag = newValue}
    }
    /// Returns true if `flag` has been explicitly set.
    var hasFlag: Bool {return self._flag != nil}
    /// Clears the value of `flag`. Subsequent reads from it will return its default value.
    mutating func clearFlag() {self._flag = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Flag: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case track = 1
      case untrack = 2

      init() {
        self = .track
      }

    }

    init() {}

    fileprivate var _conversation: DifftServiceProtos_ConversationId? = nil
    fileprivate var _topicID: String? = nil
    fileprivate var _flag: DifftServiceProtos_SyncMessage.MarkTopicAsTrack.Flag? = nil
  }

  struct MarkAsUnread: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var conversation: DifftServiceProtos_ConversationId {
      get {return _conversation ?? DifftServiceProtos_ConversationId()}
      set {_conversation = newValue}
    }
    /// Returns true if `conversation` has been explicitly set.
    var hasConversation: Bool {return self._conversation != nil}
    /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
    mutating func clearConversation() {self._conversation = nil}

    ///0、清除设定的未读状态 1、 置未读 2、置全部已读
    var flag: DifftServiceProtos_SyncMessage.MarkAsUnread.Flag {
      get {return _flag ?? .clear}
      set {_flag = newValue}
    }
    /// Returns true if `flag` has been explicitly set.
    var hasFlag: Bool {return self._flag != nil}
    /// Clears the value of `flag`. Subsequent reads from it will return its default value.
    mutating func clearFlag() {self._flag = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Flag: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
      case clear = 0
      case unread = 1
      case read = 2

      init() {
        self = .clear
      }

    }

    init() {}

    fileprivate var _conversation: DifftServiceProtos_ConversationId? = nil
    fileprivate var _flag: DifftServiceProtos_SyncMessage.MarkAsUnread.Flag? = nil
  }

  struct ConversationArchive: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var conversation: DifftServiceProtos_ConversationId {
      get {return _conversation ?? DifftServiceProtos_ConversationId()}
      set {_conversation = newValue}
    }
    /// Returns true if `conversation` has been explicitly set.
    var hasConversation: Bool {return self._conversation != nil}
    /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
    mutating func clearConversation() {self._conversation = nil}

    ///0 解档 1、 归档
    var flag: DifftServiceProtos_SyncMessage.ConversationArchive.Flag {
      get {return _flag ?? .unarchive}
      set {_flag = newValue}
    }
    /// Returns true if `flag` has been explicitly set.
    var hasFlag: Bool {return self._flag != nil}
    /// Clears the value of `flag`. Subsequent reads from it will return its default value.
    mutating func clearFlag() {self._flag = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum Flag: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

      ///解档
      case unarchive = 0

      ///归档
      case archive = 1

      init() {
        self = .unarchive
      }

    }

    init() {}

    fileprivate var _conversation: DifftServiceProtos_ConversationId? = nil
    fileprivate var _flag: DifftServiceProtos_SyncMessage.ConversationArchive.Flag? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct DifftServiceProtos_AttachmentPointer: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var contentType: String {
    get {return _contentType ?? String()}
    set {_contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  var hasContentType: Bool {return self._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  mutating func clearContentType() {self._contentType = nil}

  var key: Data {
    get {return _key ?? Data()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var size: UInt32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var thumbnail: Data {
    get {return _thumbnail ?? Data()}
    set {_thumbnail = newValue}
  }
  /// Returns true if `thumbnail` has been explicitly set.
  var hasThumbnail: Bool {return self._thumbnail != nil}
  /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
  mutating func clearThumbnail() {self._thumbnail = nil}

  var digest: Data {
    get {return _digest ?? Data()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  mutating func clearDigest() {self._digest = nil}

  var fileName: String {
    get {return _fileName ?? String()}
    set {_fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return self._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {self._fileName = nil}

  var flags: UInt32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  var width: UInt32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: UInt32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case voiceMessage = 1

    init() {
      self = .voiceMessage
    }

  }

  init() {}

  fileprivate var _id: UInt64? = nil
  fileprivate var _contentType: String? = nil
  fileprivate var _key: Data? = nil
  fileprivate var _size: UInt32? = nil
  fileprivate var _thumbnail: Data? = nil
  fileprivate var _digest: Data? = nil
  fileprivate var _fileName: String? = nil
  fileprivate var _flags: UInt32? = nil
  fileprivate var _width: UInt32? = nil
  fileprivate var _height: UInt32? = nil
}

struct DifftServiceProtos_GroupContext: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data {
    get {return _id ?? Data()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var type: DifftServiceProtos_GroupContext.TypeEnum {
    get {return _type ?? .unknown}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var members: [String] = []

  var avatar: DifftServiceProtos_AttachmentPointer {
    get {return _avatar ?? DifftServiceProtos_AttachmentPointer()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {self._avatar = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case unknown = 0
    case update = 1
    case deliver = 2
    case quit = 3
    case requestInfo = 4

    init() {
      self = .unknown
    }

  }

  init() {}

  fileprivate var _id: Data? = nil
  fileprivate var _type: DifftServiceProtos_GroupContext.TypeEnum? = nil
  fileprivate var _name: String? = nil
  fileprivate var _avatar: DifftServiceProtos_AttachmentPointer? = nil
}

struct DifftServiceProtos_ContactDetails: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var number: String {
    get {return _number ?? String()}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  mutating func clearNumber() {self._number = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var avatar: DifftServiceProtos_ContactDetails.Avatar {
    get {return _avatar ?? DifftServiceProtos_ContactDetails.Avatar()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {self._avatar = nil}

  var color: String {
    get {return _color ?? String()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var verified: DifftServiceProtos_Verified {
    get {return _verified ?? DifftServiceProtos_Verified()}
    set {_verified = newValue}
  }
  /// Returns true if `verified` has been explicitly set.
  var hasVerified: Bool {return self._verified != nil}
  /// Clears the value of `verified`. Subsequent reads from it will return its default value.
  mutating func clearVerified() {self._verified = nil}

  var profileKey: Data {
    get {return _profileKey ?? Data()}
    set {_profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return self._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {self._profileKey = nil}

  var blocked: Bool {
    get {return _blocked ?? false}
    set {_blocked = newValue}
  }
  /// Returns true if `blocked` has been explicitly set.
  var hasBlocked: Bool {return self._blocked != nil}
  /// Clears the value of `blocked`. Subsequent reads from it will return its default value.
  mutating func clearBlocked() {self._blocked = nil}

  var expireTimer: UInt32 {
    get {return _expireTimer ?? 0}
    set {_expireTimer = newValue}
  }
  /// Returns true if `expireTimer` has been explicitly set.
  var hasExpireTimer: Bool {return self._expireTimer != nil}
  /// Clears the value of `expireTimer`. Subsequent reads from it will return its default value.
  mutating func clearExpireTimer() {self._expireTimer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Avatar: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contentType: String {
      get {return _contentType ?? String()}
      set {_contentType = newValue}
    }
    /// Returns true if `contentType` has been explicitly set.
    var hasContentType: Bool {return self._contentType != nil}
    /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
    mutating func clearContentType() {self._contentType = nil}

    var length: UInt32 {
      get {return _length ?? 0}
      set {_length = newValue}
    }
    /// Returns true if `length` has been explicitly set.
    var hasLength: Bool {return self._length != nil}
    /// Clears the value of `length`. Subsequent reads from it will return its default value.
    mutating func clearLength() {self._length = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _contentType: String? = nil
    fileprivate var _length: UInt32? = nil
  }

  init() {}

  fileprivate var _number: String? = nil
  fileprivate var _name: String? = nil
  fileprivate var _avatar: DifftServiceProtos_ContactDetails.Avatar? = nil
  fileprivate var _color: String? = nil
  fileprivate var _verified: DifftServiceProtos_Verified? = nil
  fileprivate var _profileKey: Data? = nil
  fileprivate var _blocked: Bool? = nil
  fileprivate var _expireTimer: UInt32? = nil
}

struct DifftServiceProtos_GroupDetails: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: Data {
    get {return _id ?? Data()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  var members: [String] = []

  var avatar: DifftServiceProtos_GroupDetails.Avatar {
    get {return _avatar ?? DifftServiceProtos_GroupDetails.Avatar()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {self._avatar = nil}

  var active: Bool {
    get {return _active ?? true}
    set {_active = newValue}
  }
  /// Returns true if `active` has been explicitly set.
  var hasActive: Bool {return self._active != nil}
  /// Clears the value of `active`. Subsequent reads from it will return its default value.
  mutating func clearActive() {self._active = nil}

  var expireTimer: UInt32 {
    get {return _expireTimer ?? 0}
    set {_expireTimer = newValue}
  }
  /// Returns true if `expireTimer` has been explicitly set.
  var hasExpireTimer: Bool {return self._expireTimer != nil}
  /// Clears the value of `expireTimer`. Subsequent reads from it will return its default value.
  mutating func clearExpireTimer() {self._expireTimer = nil}

  var color: String {
    get {return _color ?? String()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Avatar: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contentType: String {
      get {return _contentType ?? String()}
      set {_contentType = newValue}
    }
    /// Returns true if `contentType` has been explicitly set.
    var hasContentType: Bool {return self._contentType != nil}
    /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
    mutating func clearContentType() {self._contentType = nil}

    var length: UInt32 {
      get {return _length ?? 0}
      set {_length = newValue}
    }
    /// Returns true if `length` has been explicitly set.
    var hasLength: Bool {return self._length != nil}
    /// Clears the value of `length`. Subsequent reads from it will return its default value.
    mutating func clearLength() {self._length = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _contentType: String? = nil
    fileprivate var _length: UInt32? = nil
  }

  init() {}

  fileprivate var _id: Data? = nil
  fileprivate var _name: String? = nil
  fileprivate var _avatar: DifftServiceProtos_GroupDetails.Avatar? = nil
  fileprivate var _active: Bool? = nil
  fileprivate var _expireTimer: UInt32? = nil
  fileprivate var _color: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "DifftServiceProtos"

extension DifftServiceProtos_ConversationMsgInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConversationMsgInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversationPreview"),
    2: .same(proto: "oldestMsgSId"),
    3: .same(proto: "oldestMsgNsId"),
    4: .same(proto: "lastestMsgSId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversationPreview) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._oldestMsgSid) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._oldestMsgNsID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._lastestMsgSid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversationPreview {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._oldestMsgSid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._oldestMsgNsID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lastestMsgSid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_ConversationMsgInfo, rhs: DifftServiceProtos_ConversationMsgInfo) -> Bool {
    if lhs._conversationPreview != rhs._conversationPreview {return false}
    if lhs._oldestMsgSid != rhs._oldestMsgSid {return false}
    if lhs._oldestMsgNsID != rhs._oldestMsgNsID {return false}
    if lhs._lastestMsgSid != rhs._lastestMsgSid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_ConversationPreview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConversationPreview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversationId"),
    2: .same(proto: "readPosition"),
    3: .same(proto: "unreadCorrection"),
    4: .same(proto: "lastestMsg"),
    5: .same(proto: "onePageMsgs"),
    6: .same(proto: "lastestMsgNsId"),
    7: .same(proto: "maxOutgoingNsId"),
    8: .same(proto: "maxOutgoingSId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._readPosition) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._unreadCorrection) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastestMsg) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.onePageMsgs) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._lastestMsgNsID) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._maxOutgoingNsID) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._maxOutgoingSid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._readPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._unreadCorrection {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lastestMsg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.onePageMsgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.onePageMsgs, fieldNumber: 5)
    }
    try { if let v = self._lastestMsgNsID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._maxOutgoingNsID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._maxOutgoingSid {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_ConversationPreview, rhs: DifftServiceProtos_ConversationPreview) -> Bool {
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._readPosition != rhs._readPosition {return false}
    if lhs._unreadCorrection != rhs._unreadCorrection {return false}
    if lhs._lastestMsg != rhs._lastestMsg {return false}
    if lhs.onePageMsgs != rhs.onePageMsgs {return false}
    if lhs._lastestMsgNsID != rhs._lastestMsgNsID {return false}
    if lhs._maxOutgoingNsID != rhs._maxOutgoingNsID {return false}
    if lhs._maxOutgoingSid != rhs._maxOutgoingSid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_ConversationId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConversationId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "groupId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._number) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._groupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._number {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._groupID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_ConversationId, rhs: DifftServiceProtos_ConversationId) -> Bool {
    if lhs._number != rhs._number {return false}
    if lhs._groupID != rhs._groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Envelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "source"),
    7: .same(proto: "sourceDevice"),
    3: .same(proto: "relay"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "legacyMessage"),
    8: .same(proto: "content"),
    9: .same(proto: "lastestMsgFlag"),
    11: .same(proto: "sequenceId"),
    12: .same(proto: "systemShowTimestamp"),
    13: .same(proto: "msgType"),
    14: .same(proto: "notifySequenceId"),
    15: .same(proto: "identityKey"),
    16: .same(proto: "peerContext"),
    17: .same(proto: "msgExtra"),
    18: .same(proto: "criticalLevel"),
    19: .same(proto: "pushTimestamp"),
    20: .same(proto: "roomId"),
  ]

  fileprivate class _StorageClass {
    var _type: DifftServiceProtos_Envelope.TypeEnum? = nil
    var _source: String? = nil
    var _sourceDevice: UInt32? = nil
    var _relay: String? = nil
    var _timestamp: UInt64? = nil
    var _legacyMessage: Data? = nil
    var _content: Data? = nil
    var _lastestMsgFlag: Bool? = nil
    var _sequenceID: UInt64? = nil
    var _systemShowTimestamp: UInt64? = nil
    var _msgType: DifftServiceProtos_Envelope.MsgType? = nil
    var _notifySequenceID: UInt64? = nil
    var _identityKey: String? = nil
    var _peerContext: String? = nil
    var _msgExtra: DifftServiceProtos_MsgExtra? = nil
    var _criticalLevel: DifftServiceProtos_Envelope.CriticalLevel? = nil
    var _pushTimestamp: UInt64? = nil
    var _roomID: String? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _source = source._source
      _sourceDevice = source._sourceDevice
      _relay = source._relay
      _timestamp = source._timestamp
      _legacyMessage = source._legacyMessage
      _content = source._content
      _lastestMsgFlag = source._lastestMsgFlag
      _sequenceID = source._sequenceID
      _systemShowTimestamp = source._systemShowTimestamp
      _msgType = source._msgType
      _notifySequenceID = source._notifySequenceID
      _identityKey = source._identityKey
      _peerContext = source._peerContext
      _msgExtra = source._msgExtra
      _criticalLevel = source._criticalLevel
      _pushTimestamp = source._pushTimestamp
      _roomID = source._roomID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._source) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._relay) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._legacyMessage) }()
        case 7: try { try decoder.decodeSingularUInt32Field(value: &_storage._sourceDevice) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._content) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._lastestMsgFlag) }()
        case 11: try { try decoder.decodeSingularUInt64Field(value: &_storage._sequenceID) }()
        case 12: try { try decoder.decodeSingularUInt64Field(value: &_storage._systemShowTimestamp) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._msgType) }()
        case 14: try { try decoder.decodeSingularUInt64Field(value: &_storage._notifySequenceID) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._identityKey) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._peerContext) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._msgExtra) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._criticalLevel) }()
        case 19: try { try decoder.decodeSingularUInt64Field(value: &_storage._pushTimestamp) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._roomID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._source {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._relay {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._legacyMessage {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._sourceDevice {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._content {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._lastestMsgFlag {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._sequenceID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._systemShowTimestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._msgType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._notifySequenceID {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._identityKey {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._peerContext {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._msgExtra {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._criticalLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._pushTimestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._roomID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_Envelope, rhs: DifftServiceProtos_Envelope) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._sourceDevice != rhs_storage._sourceDevice {return false}
        if _storage._relay != rhs_storage._relay {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._legacyMessage != rhs_storage._legacyMessage {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._lastestMsgFlag != rhs_storage._lastestMsgFlag {return false}
        if _storage._sequenceID != rhs_storage._sequenceID {return false}
        if _storage._systemShowTimestamp != rhs_storage._systemShowTimestamp {return false}
        if _storage._msgType != rhs_storage._msgType {return false}
        if _storage._notifySequenceID != rhs_storage._notifySequenceID {return false}
        if _storage._identityKey != rhs_storage._identityKey {return false}
        if _storage._peerContext != rhs_storage._peerContext {return false}
        if _storage._msgExtra != rhs_storage._msgExtra {return false}
        if _storage._criticalLevel != rhs_storage._criticalLevel {return false}
        if _storage._pushTimestamp != rhs_storage._pushTimestamp {return false}
        if _storage._roomID != rhs_storage._roomID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_Envelope.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CIPHERTEXT"),
    2: .same(proto: "KEY_EXCHANGE"),
    3: .same(proto: "PREKEY_BUNDLE"),
    5: .same(proto: "RECEIPT"),
    6: .same(proto: "NOTIFY"),
    7: .same(proto: "PLAINTEXT"),
    8: .same(proto: "ETOEE"),
  ]
}

extension DifftServiceProtos_Envelope.MsgType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MSG_UNKNOWN"),
    1: .same(proto: "MSG_NORMAL"),
    2: .same(proto: "MSG_SYNC"),
    3: .same(proto: "MSG_READ_RECEIPT"),
    4: .same(proto: "MSG_SYNC_READ_RECEIPT"),
    5: .same(proto: "MSG_DELIVERY_RECEIPT"),
    6: .same(proto: "MSG_NOTIFY"),
    7: .same(proto: "MSG_RECALL"),
    8: .same(proto: "MSG_RECALLED"),
    9: .same(proto: "MSG_SYNC_PREVIEWABLE"),
    10: .same(proto: "MSG_CLIENT_NOTIFY"),
    11: .same(proto: "MSG_SCHEDULE_NORMAL"),
    12: .same(proto: "MSG_ENC_CALL"),
  ]
}

extension DifftServiceProtos_Envelope.CriticalLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEVEL_UNKNOWN"),
    1000: .same(proto: "LEVEL_CRITICAL"),
  ]
}

extension DifftServiceProtos_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataMessage"),
    2: .same(proto: "syncMessage"),
    4: .same(proto: "nullMessage"),
    5: .same(proto: "receiptMessage"),
    6: .same(proto: "typingMessage"),
    7: .same(proto: "notifyMessage"),
    8: .same(proto: "callMessage"),
  ]

  fileprivate class _StorageClass {
    var _dataMessage: DifftServiceProtos_DataMessage? = nil
    var _syncMessage: DifftServiceProtos_SyncMessage? = nil
    var _nullMessage: DifftServiceProtos_NullMessage? = nil
    var _receiptMessage: DifftServiceProtos_ReceiptMessage? = nil
    var _typingMessage: DifftServiceProtos_TypingMessage? = nil
    var _notifyMessage: DifftServiceProtos_NotifyMessage? = nil
    var _callMessage: DifftServiceProtos_CallMessage? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _dataMessage = source._dataMessage
      _syncMessage = source._syncMessage
      _nullMessage = source._nullMessage
      _receiptMessage = source._receiptMessage
      _typingMessage = source._typingMessage
      _notifyMessage = source._notifyMessage
      _callMessage = source._callMessage
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._dataMessage) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._syncMessage) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._nullMessage) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._receiptMessage) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._typingMessage) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._notifyMessage) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._callMessage) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._dataMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._syncMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._nullMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._receiptMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._typingMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._notifyMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._callMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_Content, rhs: DifftServiceProtos_Content) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dataMessage != rhs_storage._dataMessage {return false}
        if _storage._syncMessage != rhs_storage._syncMessage {return false}
        if _storage._nullMessage != rhs_storage._nullMessage {return false}
        if _storage._receiptMessage != rhs_storage._receiptMessage {return false}
        if _storage._typingMessage != rhs_storage._typingMessage {return false}
        if _storage._notifyMessage != rhs_storage._notifyMessage {return false}
        if _storage._callMessage != rhs_storage._callMessage {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_CallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "calling"),
    2: .same(proto: "joined"),
    3: .same(proto: "cancel"),
    4: .same(proto: "reject"),
    5: .same(proto: "hangup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._calling) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._joined) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cancel) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._reject) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._hangup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._calling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._joined {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cancel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._reject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._hangup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_CallMessage, rhs: DifftServiceProtos_CallMessage) -> Bool {
    if lhs._calling != rhs._calling {return false}
    if lhs._joined != rhs._joined {return false}
    if lhs._cancel != rhs._cancel {return false}
    if lhs._reject != rhs._reject {return false}
    if lhs._hangup != rhs._hangup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_CallMessage.Calling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_CallMessage.protoMessageName + ".Calling"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roomId"),
    2: .same(proto: "conversationId"),
    3: .same(proto: "roomName"),
    4: .same(proto: "caller"),
    5: .same(proto: "emk"),
    6: .same(proto: "publicKey"),
    7: .same(proto: "createCallMsg"),
    8: .same(proto: "controlType"),
    9: .same(proto: "callees"),
    10: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._roomID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._conversationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._roomName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._caller) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._emk) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._createCallMsg) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._controlType) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.callees) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._roomID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._conversationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._roomName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._caller {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._emk {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._createCallMsg {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._controlType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    if !self.callees.isEmpty {
      try visitor.visitRepeatedStringField(value: self.callees, fieldNumber: 9)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_CallMessage.Calling, rhs: DifftServiceProtos_CallMessage.Calling) -> Bool {
    if lhs._roomID != rhs._roomID {return false}
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs._roomName != rhs._roomName {return false}
    if lhs._caller != rhs._caller {return false}
    if lhs._emk != rhs._emk {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._createCallMsg != rhs._createCallMsg {return false}
    if lhs._controlType != rhs._controlType {return false}
    if lhs.callees != rhs.callees {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_CallMessage.Joined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_CallMessage.protoMessageName + ".Joined"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roomId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._roomID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._roomID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_CallMessage.Joined, rhs: DifftServiceProtos_CallMessage.Joined) -> Bool {
    if lhs._roomID != rhs._roomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_CallMessage.Cancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_CallMessage.protoMessageName + ".Cancel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roomId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._roomID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._roomID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_CallMessage.Cancel, rhs: DifftServiceProtos_CallMessage.Cancel) -> Bool {
    if lhs._roomID != rhs._roomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_CallMessage.Reject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_CallMessage.protoMessageName + ".Reject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roomId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._roomID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._roomID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_CallMessage.Reject, rhs: DifftServiceProtos_CallMessage.Reject) -> Bool {
    if lhs._roomID != rhs._roomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_CallMessage.Hangup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_CallMessage.protoMessageName + ".Hangup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roomId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._roomID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._roomID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_CallMessage.Hangup, rhs: DifftServiceProtos_CallMessage.Hangup) -> Bool {
    if lhs._roomID != rhs._roomID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_MsgExtra: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgExtra"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latestCard"),
    3: .same(proto: "conversationId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._latestCard) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._conversationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._latestCard {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._conversationID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_MsgExtra, rhs: DifftServiceProtos_MsgExtra) -> Bool {
    if lhs._latestCard != rhs._latestCard {return false}
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_Card: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Card"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "appId"),
    2: .same(proto: "cardId"),
    3: .same(proto: "version"),
    4: .same(proto: "creator"),
    5: .same(proto: "timestamp"),
    6: .same(proto: "content"),
    7: .same(proto: "contentType"),
    8: .same(proto: "type"),
    9: .same(proto: "fixedWidth"),
    10: .same(proto: "height"),
    11: .same(proto: "uniqueId"),
    12: .same(proto: "source"),
    13: .same(proto: "conversationId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._appID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._cardID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._creator) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._content) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._contentType) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._type) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self._fixedWidth) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._height) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._uniqueID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._source) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._conversationID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._appID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cardID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._creator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._content {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._contentType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._fixedWidth {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._uniqueID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._conversationID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_Card, rhs: DifftServiceProtos_Card) -> Bool {
    if lhs._appID != rhs._appID {return false}
    if lhs._cardID != rhs._cardID {return false}
    if lhs._version != rhs._version {return false}
    if lhs._creator != rhs._creator {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._content != rhs._content {return false}
    if lhs._contentType != rhs._contentType {return false}
    if lhs._type != rhs._type {return false}
    if lhs._fixedWidth != rhs._fixedWidth {return false}
    if lhs._height != rhs._height {return false}
    if lhs._uniqueID != rhs._uniqueID {return false}
    if lhs._source != rhs._source {return false}
    if lhs._conversationID != rhs._conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_Card.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSERT"),
    1: .same(proto: "UPDATE"),
  ]
}

extension DifftServiceProtos_Card.ContentType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MARKDOWN"),
    1: .same(proto: "ADAPTIVECARD"),
  ]
}

extension DifftServiceProtos_RapidFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RapidFile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rapidHash"),
    2: .same(proto: "authorizedId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._rapidHash) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._authorizedID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rapidHash {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authorizedID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_RapidFile, rhs: DifftServiceProtos_RapidFile) -> Bool {
    if lhs._rapidHash != rhs._rapidHash {return false}
    if lhs._authorizedID != rhs._authorizedID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_RealSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RealSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "sourceDevice"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "serverTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._sourceDevice) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._serverTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sourceDevice {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._serverTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_RealSource, rhs: DifftServiceProtos_RealSource) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._sourceDevice != rhs._sourceDevice {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._serverTimestamp != rhs._serverTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_TopicContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "supportType"),
    3: .same(proto: "source"),
    4: .same(proto: "sourceBrief"),
    5: .same(proto: "sourceDisplayName"),
    6: .same(proto: "replyToUser"),
    7: .same(proto: "groupId"),
    8: .same(proto: "groupName"),
    9: .same(proto: "botId"),
    10: .same(proto: "topicId"),
    11: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._supportType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._sourceBrief) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._sourceDisplayName) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._replyToUser) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._groupID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._groupName) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._botID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._topicID) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._supportType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._sourceBrief {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sourceDisplayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._replyToUser {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._groupID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._groupName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._botID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._topicID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_TopicContext, rhs: DifftServiceProtos_TopicContext) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._supportType != rhs._supportType {return false}
    if lhs._source != rhs._source {return false}
    if lhs._sourceBrief != rhs._sourceBrief {return false}
    if lhs._sourceDisplayName != rhs._sourceDisplayName {return false}
    if lhs._replyToUser != rhs._replyToUser {return false}
    if lhs._groupID != rhs._groupID {return false}
    if lhs._groupName != rhs._groupName {return false}
    if lhs._botID != rhs._botID {return false}
    if lhs._topicID != rhs._topicID {return false}
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_TopicContext.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER"),
    1: .same(proto: "MESSAGE"),
  ]
}

extension DifftServiceProtos_TopicContext.SupportType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "SUPPORT"),
  ]
}

extension DifftServiceProtos_TopicContext.MarkContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_TopicContext.protoMessageName + ".MarkContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mark"),
    2: .same(proto: "sequenceId"),
    3: .same(proto: "serverTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._mark) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._sequenceID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._serverTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mark {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._serverTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_TopicContext.MarkContent, rhs: DifftServiceProtos_TopicContext.MarkContent) -> Bool {
    if lhs._mark != rhs._mark {return false}
    if lhs._sequenceID != rhs._sequenceID {return false}
    if lhs._serverTimestamp != rhs._serverTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "attachments"),
    3: .same(proto: "group"),
    4: .same(proto: "flags"),
    5: .same(proto: "expireTimer"),
    6: .same(proto: "profileKey"),
    7: .same(proto: "timestamp"),
    8: .same(proto: "quote"),
    10: .same(proto: "atPersons"),
    11: .same(proto: "forwardContext"),
    12: .same(proto: "requiredProtocolVersion"),
    13: .same(proto: "contact"),
    14: .same(proto: "recall"),
    15: .same(proto: "task"),
    16: .same(proto: "vote"),
    17: .same(proto: "botContext"),
    18: .same(proto: "threadContext"),
    19: .same(proto: "topicContext"),
    20: .same(proto: "reaction"),
    21: .same(proto: "card"),
    22: .same(proto: "mentions"),
    23: .same(proto: "messageMode"),
    24: .same(proto: "screenShot"),
  ]

  fileprivate class _StorageClass {
    var _body: String? = nil
    var _attachments: [DifftServiceProtos_AttachmentPointer] = []
    var _group: DifftServiceProtos_GroupContext? = nil
    var _flags: UInt32? = nil
    var _expireTimer: UInt32? = nil
    var _profileKey: Data? = nil
    var _timestamp: UInt64? = nil
    var _quote: DifftServiceProtos_DataMessage.Quote? = nil
    var _atPersons: String? = nil
    var _forwardContext: DifftServiceProtos_DataMessage.ForwardContext? = nil
    var _requiredProtocolVersion: UInt32? = nil
    var _contact: [DifftServiceProtos_DataMessage.Contact] = []
    var _recall: DifftServiceProtos_DataMessage.Recall? = nil
    var _task: DifftServiceProtos_DataMessage.Task? = nil
    var _vote: DifftServiceProtos_DataMessage.Vote? = nil
    var _botContext: DifftServiceProtos_DataMessage.BotContext? = nil
    var _threadContext: DifftServiceProtos_DataMessage.ThreadContext? = nil
    var _topicContext: DifftServiceProtos_TopicContext? = nil
    var _reaction: DifftServiceProtos_DataMessage.Reaction? = nil
    var _card: DifftServiceProtos_Card? = nil
    var _mentions: [DifftServiceProtos_DataMessage.Mention] = []
    var _messageMode: UInt32? = nil
    var _screenShot: DifftServiceProtos_DataMessage.ScreenShot? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _body = source._body
      _attachments = source._attachments
      _group = source._group
      _flags = source._flags
      _expireTimer = source._expireTimer
      _profileKey = source._profileKey
      _timestamp = source._timestamp
      _quote = source._quote
      _atPersons = source._atPersons
      _forwardContext = source._forwardContext
      _requiredProtocolVersion = source._requiredProtocolVersion
      _contact = source._contact
      _recall = source._recall
      _task = source._task
      _vote = source._vote
      _botContext = source._botContext
      _threadContext = source._threadContext
      _topicContext = source._topicContext
      _reaction = source._reaction
      _card = source._card
      _mentions = source._mentions
      _messageMode = source._messageMode
      _screenShot = source._screenShot
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._body) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._attachments) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._expireTimer) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._quote) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._atPersons) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._forwardContext) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._requiredProtocolVersion) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._contact) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._recall) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._task) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._vote) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._botContext) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._threadContext) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._topicContext) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._reaction) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._card) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._mentions) }()
        case 23: try { try decoder.decodeSingularUInt32Field(value: &_storage._messageMode) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._screenShot) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._body {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      if !_storage._attachments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attachments, fieldNumber: 2)
      }
      try { if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._flags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._expireTimer {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._profileKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._quote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._atPersons {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._forwardContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._requiredProtocolVersion {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 12)
      } }()
      if !_storage._contact.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._contact, fieldNumber: 13)
      }
      try { if let v = _storage._recall {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._task {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._vote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._botContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._threadContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._topicContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._reaction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      if !_storage._mentions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mentions, fieldNumber: 22)
      }
      try { if let v = _storage._messageMode {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._screenShot {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage, rhs: DifftServiceProtos_DataMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._body != rhs_storage._body {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._expireTimer != rhs_storage._expireTimer {return false}
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._atPersons != rhs_storage._atPersons {return false}
        if _storage._forwardContext != rhs_storage._forwardContext {return false}
        if _storage._requiredProtocolVersion != rhs_storage._requiredProtocolVersion {return false}
        if _storage._contact != rhs_storage._contact {return false}
        if _storage._recall != rhs_storage._recall {return false}
        if _storage._task != rhs_storage._task {return false}
        if _storage._vote != rhs_storage._vote {return false}
        if _storage._botContext != rhs_storage._botContext {return false}
        if _storage._threadContext != rhs_storage._threadContext {return false}
        if _storage._topicContext != rhs_storage._topicContext {return false}
        if _storage._reaction != rhs_storage._reaction {return false}
        if _storage._card != rhs_storage._card {return false}
        if _storage._mentions != rhs_storage._mentions {return false}
        if _storage._messageMode != rhs_storage._messageMode {return false}
        if _storage._screenShot != rhs_storage._screenShot {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "END_SESSION"),
    2: .same(proto: "EXPIRATION_TIMER_UPDATE"),
    4: .same(proto: "PROFILE_KEY_UPDATE"),
  ]
}

extension DifftServiceProtos_DataMessage.ProtocolVersion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INITIAL"),
    1: .same(proto: "FORWARD"),
    2: .same(proto: "CONTACT"),
    3: .same(proto: "RECALL"),
    4: .same(proto: "TASK"),
    5: .same(proto: "VOTE"),
    6: .same(proto: "REACTION"),
    7: .same(proto: "CARD"),
    8: .same(proto: "CONFIDE"),
    9: .same(proto: "SCREEN_SHOT"),
    10: .aliased(proto: "VERIFY", aliases: ["CURRENT"]),
  ]
}

extension DifftServiceProtos_DataMessage.MessageMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "CONFIDENTIAL"),
  ]
}

extension DifftServiceProtos_DataMessage.Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".Quote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "author"),
    3: .same(proto: "text"),
    4: .same(proto: "attachments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Quote, rhs: DifftServiceProtos_DataMessage.Quote) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._author != rhs._author {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Quote.QuotedAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.Quote.protoMessageName + ".QuotedAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "fileName"),
    3: .same(proto: "thumbnail"),
    4: .same(proto: "flags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._thumbnail) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._thumbnail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Quote.QuotedAttachment, rhs: DifftServiceProtos_DataMessage.Quote.QuotedAttachment) -> Bool {
    if lhs._contentType != rhs._contentType {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Quote.QuotedAttachment.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VOICE_MESSAGE"),
  ]
}

extension DifftServiceProtos_DataMessage.Forward: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".Forward"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "isFromGroup"),
    4: .same(proto: "author"),
    5: .same(proto: "text"),
    6: .same(proto: "attachments"),
    7: .same(proto: "forwards"),
    8: .same(proto: "card"),
    9: .same(proto: "mentions"),
    10: .same(proto: "serverTimestamp"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64? = nil
    var _type: UInt32? = nil
    var _isFromGroup: Bool? = nil
    var _author: String? = nil
    var _text: String? = nil
    var _attachments: [DifftServiceProtos_AttachmentPointer] = []
    var _forwards: [DifftServiceProtos_DataMessage.Forward] = []
    var _card: DifftServiceProtos_Card? = nil
    var _mentions: [DifftServiceProtos_DataMessage.Mention] = []
    var _serverTimestamp: UInt64? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _isFromGroup = source._isFromGroup
      _author = source._author
      _text = source._text
      _attachments = source._attachments
      _forwards = source._forwards
      _card = source._card
      _mentions = source._mentions
      _serverTimestamp = source._serverTimestamp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._isFromGroup) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._author) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._text) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._attachments) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._forwards) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._card) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._mentions) }()
        case 10: try { try decoder.decodeSingularUInt64Field(value: &_storage._serverTimestamp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._isFromGroup {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._author {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._text {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      if !_storage._attachments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attachments, fieldNumber: 6)
      }
      if !_storage._forwards.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._forwards, fieldNumber: 7)
      }
      try { if let v = _storage._card {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._mentions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._mentions, fieldNumber: 9)
      }
      try { if let v = _storage._serverTimestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Forward, rhs: DifftServiceProtos_DataMessage.Forward) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._isFromGroup != rhs_storage._isFromGroup {return false}
        if _storage._author != rhs_storage._author {return false}
        if _storage._text != rhs_storage._text {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        if _storage._forwards != rhs_storage._forwards {return false}
        if _storage._card != rhs_storage._card {return false}
        if _storage._mentions != rhs_storage._mentions {return false}
        if _storage._serverTimestamp != rhs_storage._serverTimestamp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Forward.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "EOF"),
  ]
}

extension DifftServiceProtos_DataMessage.ForwardContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".ForwardContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "forwards"),
    2: .same(proto: "rapidFiles"),
    3: .same(proto: "isFromGroup"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.forwards) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rapidFiles) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isFromGroup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.forwards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.forwards, fieldNumber: 1)
    }
    if !self.rapidFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rapidFiles, fieldNumber: 2)
    }
    try { if let v = self._isFromGroup {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.ForwardContext, rhs: DifftServiceProtos_DataMessage.ForwardContext) -> Bool {
    if lhs.forwards != rhs.forwards {return false}
    if lhs.rapidFiles != rhs.rapidFiles {return false}
    if lhs._isFromGroup != rhs._isFromGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "number"),
    4: .same(proto: "email"),
    5: .same(proto: "address"),
    6: .same(proto: "avatar"),
    7: .same(proto: "organization"),
  ]

  fileprivate class _StorageClass {
    var _name: DifftServiceProtos_DataMessage.Contact.Name? = nil
    var _number: [DifftServiceProtos_DataMessage.Contact.Phone] = []
    var _email: [DifftServiceProtos_DataMessage.Contact.Email] = []
    var _address: [DifftServiceProtos_DataMessage.Contact.PostalAddress] = []
    var _avatar: DifftServiceProtos_DataMessage.Contact.Avatar? = nil
    var _organization: String? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _number = source._number
      _email = source._email
      _address = source._address
      _avatar = source._avatar
      _organization = source._organization
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._name) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._number) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._email) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._address) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._avatar) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._organization) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._number.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._number, fieldNumber: 3)
      }
      if !_storage._email.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._email, fieldNumber: 4)
      }
      if !_storage._address.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._address, fieldNumber: 5)
      }
      try { if let v = _storage._avatar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._organization {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Contact, rhs: DifftServiceProtos_DataMessage.Contact) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._number != rhs_storage._number {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._organization != rhs_storage._organization {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Contact.Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.Contact.protoMessageName + ".Name"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "givenName"),
    2: .same(proto: "familyName"),
    3: .same(proto: "prefix"),
    4: .same(proto: "suffix"),
    5: .same(proto: "middleName"),
    6: .same(proto: "displayName"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._givenName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._familyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._prefix) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._suffix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._middleName) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._givenName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._familyName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._prefix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._suffix {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._middleName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Contact.Name, rhs: DifftServiceProtos_DataMessage.Contact.Name) -> Bool {
    if lhs._givenName != rhs._givenName {return false}
    if lhs._familyName != rhs._familyName {return false}
    if lhs._prefix != rhs._prefix {return false}
    if lhs._suffix != rhs._suffix {return false}
    if lhs._middleName != rhs._middleName {return false}
    if lhs._displayName != rhs._displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Contact.Phone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.Contact.protoMessageName + ".Phone"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Contact.Phone, rhs: DifftServiceProtos_DataMessage.Contact.Phone) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Contact.Phone.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension DifftServiceProtos_DataMessage.Contact.Email: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.Contact.protoMessageName + ".Email"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "type"),
    3: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._value) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Contact.Email, rhs: DifftServiceProtos_DataMessage.Contact.Email) -> Bool {
    if lhs._value != rhs._value {return false}
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Contact.Email.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HOME"),
    2: .same(proto: "MOBILE"),
    3: .same(proto: "WORK"),
    4: .same(proto: "CUSTOM"),
  ]
}

extension DifftServiceProtos_DataMessage.Contact.PostalAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.Contact.protoMessageName + ".PostalAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "label"),
    3: .same(proto: "street"),
    4: .same(proto: "pobox"),
    5: .same(proto: "neighborhood"),
    6: .same(proto: "city"),
    7: .same(proto: "region"),
    8: .same(proto: "postcode"),
    9: .same(proto: "country"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._street) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._pobox) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._neighborhood) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._city) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._region) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._postcode) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._country) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._street {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pobox {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._neighborhood {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._city {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._region {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._postcode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._country {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Contact.PostalAddress, rhs: DifftServiceProtos_DataMessage.Contact.PostalAddress) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._label != rhs._label {return false}
    if lhs._street != rhs._street {return false}
    if lhs._pobox != rhs._pobox {return false}
    if lhs._neighborhood != rhs._neighborhood {return false}
    if lhs._city != rhs._city {return false}
    if lhs._region != rhs._region {return false}
    if lhs._postcode != rhs._postcode {return false}
    if lhs._country != rhs._country {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Contact.PostalAddress.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "HOME"),
    2: .same(proto: "WORK"),
    3: .same(proto: "CUSTOM"),
  ]
}

extension DifftServiceProtos_DataMessage.Contact.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.Contact.protoMessageName + ".Avatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "avatar"),
    2: .same(proto: "isProfile"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isProfile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isProfile {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Contact.Avatar, rhs: DifftServiceProtos_DataMessage.Contact.Avatar) -> Bool {
    if lhs._avatar != rhs._avatar {return false}
    if lhs._isProfile != rhs._isProfile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Recall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".Recall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Recall, rhs: DifftServiceProtos_DataMessage.Recall) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.ScreenShot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".ScreenShot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.ScreenShot, rhs: DifftServiceProtos_DataMessage.ScreenShot) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Task: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".Task"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "taskId"),
    2: .same(proto: "version"),
    3: .same(proto: "creator"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "name"),
    6: .same(proto: "notes"),
    7: .same(proto: "assignees"),
    8: .same(proto: "dueTime"),
    9: .same(proto: "priority"),
    10: .same(proto: "followers"),
    11: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._taskID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._creator) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._notes) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.assignees) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._dueTime) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._priority) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.followers) }()
      case 11: try { try decoder.decodeSingularUInt32Field(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._taskID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._creator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._notes {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    if !self.assignees.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assignees, fieldNumber: 7)
    }
    try { if let v = self._dueTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._priority {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    if !self.followers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.followers, fieldNumber: 10)
    }
    try { if let v = self._status {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Task, rhs: DifftServiceProtos_DataMessage.Task) -> Bool {
    if lhs._taskID != rhs._taskID {return false}
    if lhs._version != rhs._version {return false}
    if lhs._creator != rhs._creator {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._name != rhs._name {return false}
    if lhs._notes != rhs._notes {return false}
    if lhs.assignees != rhs.assignees {return false}
    if lhs._dueTime != rhs._dueTime {return false}
    if lhs._priority != rhs._priority {return false}
    if lhs.followers != rhs.followers {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Task.Priority: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "P0"),
    2: .same(proto: "P1"),
    3: .same(proto: "P2"),
  ]
}

extension DifftServiceProtos_DataMessage.Task.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "INITIAL"),
    11: .same(proto: "REJECTED"),
    12: .same(proto: "COMPLETED"),
    13: .same(proto: "CANCELED"),
  ]
}

extension DifftServiceProtos_DataMessage.Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".Vote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "voteId"),
    2: .same(proto: "version"),
    3: .same(proto: "creator"),
    4: .same(proto: "name"),
    5: .same(proto: "options"),
    6: .same(proto: "multiple"),
    7: .same(proto: "dueTime"),
    8: .same(proto: "status"),
    9: .same(proto: "anonymous"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._voteID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._creator) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._multiple) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._dueTime) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._status) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._anonymous) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._voteID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._creator {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 5)
    }
    try { if let v = self._multiple {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._dueTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._anonymous {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Vote, rhs: DifftServiceProtos_DataMessage.Vote) -> Bool {
    if lhs._voteID != rhs._voteID {return false}
    if lhs._version != rhs._version {return false}
    if lhs._creator != rhs._creator {return false}
    if lhs._name != rhs._name {return false}
    if lhs.options != rhs.options {return false}
    if lhs._multiple != rhs._multiple {return false}
    if lhs._dueTime != rhs._dueTime {return false}
    if lhs._status != rhs._status {return false}
    if lhs._anonymous != rhs._anonymous {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Vote.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "INITIAL"),
    2: .same(proto: "CLOSED"),
  ]
}

extension DifftServiceProtos_DataMessage.Vote.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.Vote.protoMessageName + ".Option"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Vote.Option, rhs: DifftServiceProtos_DataMessage.Vote.Option) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".Reaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "emoji"),
    3: .same(proto: "remove"),
    4: .same(proto: "originTimestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._emoji) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._remove) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._originTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._emoji {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._remove {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._originTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Reaction, rhs: DifftServiceProtos_DataMessage.Reaction) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._emoji != rhs._emoji {return false}
    if lhs._remove != rhs._remove {return false}
    if lhs._originTimestamp != rhs._originTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Mention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".Mention"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .same(proto: "uid"),
    4: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._uid) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._uid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.Mention, rhs: DifftServiceProtos_DataMessage.Mention) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._length != rhs._length {return false}
    if lhs._uid != rhs._uid {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.Mention.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERNAL"),
    1: .same(proto: "EXTERNAL"),
  ]
}

extension DifftServiceProtos_DataMessage.BotContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".BotContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "source"),
    3: .same(proto: "groupId"),
    4: .same(proto: "header"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._groupID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._header) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._header {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.BotContext, rhs: DifftServiceProtos_DataMessage.BotContext) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._source != rhs._source {return false}
    if lhs._groupID != rhs._groupID {return false}
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_DataMessage.BotContext.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SUPPORT"),
    2: .same(proto: "ANNOUNCEMENT"),
  ]
}

extension DifftServiceProtos_DataMessage.ThreadContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_DataMessage.protoMessageName + ".ThreadContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "replyToUser"),
    3: .same(proto: "groupId"),
    4: .same(proto: "botId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._replyToUser) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._groupID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._botID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._replyToUser {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._botID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_DataMessage.ThreadContext, rhs: DifftServiceProtos_DataMessage.ThreadContext) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._replyToUser != rhs._replyToUser {return false}
    if lhs._groupID != rhs._groupID {return false}
    if lhs._botID != rhs._botID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_NullMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NullMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._padding) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._padding {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_NullMessage, rhs: DifftServiceProtos_NullMessage) -> Bool {
    if lhs._padding != rhs._padding {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_ReceiptMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceiptMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "readPosition"),
    4: .same(proto: "messageMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestamp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._readPosition) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._messageMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.timestamp.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try { if let v = self._readPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._messageMode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_ReceiptMessage, rhs: DifftServiceProtos_ReceiptMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._readPosition != rhs._readPosition {return false}
    if lhs._messageMode != rhs._messageMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_ReceiptMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELIVERY"),
    1: .same(proto: "READ"),
  ]
}

extension DifftServiceProtos_TopicMark: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicMark"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .same(proto: "topicId"),
    3: .same(proto: "mark"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._topicID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._mark) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topicID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mark {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_TopicMark, rhs: DifftServiceProtos_TopicMark) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs._topicID != rhs._topicID {return false}
    if lhs._mark != rhs._mark {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_TopicAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TopicAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actionType"),
    2: .same(proto: "conversationId"),
    3: .same(proto: "targetContext"),
    4: .same(proto: "sourceTopicId"),
    5: .same(proto: "realSource"),
    6: .same(proto: "targetRealSource"),
  ]

  fileprivate class _StorageClass {
    var _actionType: DifftServiceProtos_TopicAction.ActionType? = nil
    var _conversationID: DifftServiceProtos_ConversationId? = nil
    var _targetContext: DifftServiceProtos_TopicContext? = nil
    var _sourceTopicID: String? = nil
    var _realSource: DifftServiceProtos_RealSource? = nil
    var _targetRealSource: DifftServiceProtos_RealSource? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _actionType = source._actionType
      _conversationID = source._conversationID
      _targetContext = source._targetContext
      _sourceTopicID = source._sourceTopicID
      _realSource = source._realSource
      _targetRealSource = source._targetRealSource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._actionType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._conversationID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._targetContext) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._sourceTopicID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._realSource) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._targetRealSource) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._actionType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._conversationID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._targetContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._sourceTopicID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._realSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._targetRealSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_TopicAction, rhs: DifftServiceProtos_TopicAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._actionType != rhs_storage._actionType {return false}
        if _storage._conversationID != rhs_storage._conversationID {return false}
        if _storage._targetContext != rhs_storage._targetContext {return false}
        if _storage._sourceTopicID != rhs_storage._sourceTopicID {return false}
        if _storage._realSource != rhs_storage._realSource {return false}
        if _storage._targetRealSource != rhs_storage._targetRealSource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_TopicAction.ActionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "REMOVE"),
    2: .same(proto: "ADD"),
    3: .same(proto: "MOVE"),
  ]
}

extension DifftServiceProtos_NotifyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NotifyMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topicMark"),
    2: .same(proto: "topicAction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._topicMark) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._topicAction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topicMark {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topicAction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_NotifyMessage, rhs: DifftServiceProtos_NotifyMessage) -> Bool {
    if lhs._topicMark != rhs._topicMark {return false}
    if lhs._topicAction != rhs._topicAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_ReadPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReadPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupId"),
    2: .same(proto: "readAt"),
    3: .same(proto: "maxServerTime"),
    4: .same(proto: "maxNotifySequenceId"),
    5: .same(proto: "maxSequenceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._groupID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._readAt) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._maxServerTime) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._maxNotifySequenceID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._maxSequenceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._groupID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._readAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._maxServerTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._maxNotifySequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._maxSequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_ReadPosition, rhs: DifftServiceProtos_ReadPosition) -> Bool {
    if lhs._groupID != rhs._groupID {return false}
    if lhs._readAt != rhs._readAt {return false}
    if lhs._maxServerTime != rhs._maxServerTime {return false}
    if lhs._maxNotifySequenceID != rhs._maxNotifySequenceID {return false}
    if lhs._maxSequenceID != rhs._maxSequenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_TypingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "action"),
    3: .same(proto: "groupId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._groupID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._groupID {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_TypingMessage, rhs: DifftServiceProtos_TypingMessage) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._action != rhs._action {return false}
    if lhs._groupID != rhs._groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_TypingMessage.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STARTED"),
    1: .same(proto: "STOPPED"),
  ]
}

extension DifftServiceProtos_Verified: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Verified"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "identityKey"),
    3: .same(proto: "state"),
    4: .same(proto: "nullMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._identityKey) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._state) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._nullMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._identityKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._state {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nullMessage {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_Verified, rhs: DifftServiceProtos_Verified) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs._identityKey != rhs._identityKey {return false}
    if lhs._state != rhs._state {return false}
    if lhs._nullMessage != rhs._nullMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_Verified.State: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "VERIFIED"),
    2: .same(proto: "UNVERIFIED"),
  ]
}

extension DifftServiceProtos_SyncMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SyncMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sent"),
    2: .same(proto: "contacts"),
    3: .same(proto: "groups"),
    4: .same(proto: "request"),
    5: .same(proto: "read"),
    6: .same(proto: "blocked"),
    7: .same(proto: "verified"),
    9: .same(proto: "configuration"),
    8: .same(proto: "padding"),
    10: .same(proto: "tasks"),
    11: .same(proto: "markAsUnread"),
    12: .same(proto: "conversationArchive"),
    13: .same(proto: "markTopicAsTrack"),
    14: .same(proto: "topicMark"),
    15: .same(proto: "topicAction"),
    16: .same(proto: "serverTimestamp"),
    17: .same(proto: "criticalRead"),
  ]

  fileprivate class _StorageClass {
    var _sent: DifftServiceProtos_SyncMessage.Sent? = nil
    var _contacts: DifftServiceProtos_SyncMessage.Contacts? = nil
    var _groups: DifftServiceProtos_SyncMessage.Groups? = nil
    var _request: DifftServiceProtos_SyncMessage.Request? = nil
    var _read: [DifftServiceProtos_SyncMessage.Read] = []
    var _blocked: DifftServiceProtos_SyncMessage.Blocked? = nil
    var _verified: DifftServiceProtos_Verified? = nil
    var _configuration: DifftServiceProtos_SyncMessage.Configuration? = nil
    var _padding: Data? = nil
    var _tasks: [DifftServiceProtos_SyncMessage.Task] = []
    var _markAsUnread: DifftServiceProtos_SyncMessage.MarkAsUnread? = nil
    var _conversationArchive: DifftServiceProtos_SyncMessage.ConversationArchive? = nil
    var _markTopicAsTrack: DifftServiceProtos_SyncMessage.MarkTopicAsTrack? = nil
    var _topicMark: DifftServiceProtos_TopicMark? = nil
    var _topicAction: DifftServiceProtos_TopicAction? = nil
    var _serverTimestamp: UInt64? = nil
    var _criticalRead: [DifftServiceProtos_SyncMessage.Read] = []

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _sent = source._sent
      _contacts = source._contacts
      _groups = source._groups
      _request = source._request
      _read = source._read
      _blocked = source._blocked
      _verified = source._verified
      _configuration = source._configuration
      _padding = source._padding
      _tasks = source._tasks
      _markAsUnread = source._markAsUnread
      _conversationArchive = source._conversationArchive
      _markTopicAsTrack = source._markTopicAsTrack
      _topicMark = source._topicMark
      _topicAction = source._topicAction
      _serverTimestamp = source._serverTimestamp
      _criticalRead = source._criticalRead
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._sent) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._contacts) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._groups) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._read) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._blocked) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._verified) }()
        case 8: try { try decoder.decodeSingularBytesField(value: &_storage._padding) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._configuration) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._tasks) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._markAsUnread) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._conversationArchive) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._markTopicAsTrack) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._topicMark) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._topicAction) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._serverTimestamp) }()
        case 17: try { try decoder.decodeRepeatedMessageField(value: &_storage._criticalRead) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._sent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._contacts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._groups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._read.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._read, fieldNumber: 5)
      }
      try { if let v = _storage._blocked {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._verified {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._padding {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._tasks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tasks, fieldNumber: 10)
      }
      try { if let v = _storage._markAsUnread {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._conversationArchive {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._markTopicAsTrack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._topicMark {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._topicAction {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._serverTimestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 16)
      } }()
      if !_storage._criticalRead.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._criticalRead, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage, rhs: DifftServiceProtos_SyncMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sent != rhs_storage._sent {return false}
        if _storage._contacts != rhs_storage._contacts {return false}
        if _storage._groups != rhs_storage._groups {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._read != rhs_storage._read {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        if _storage._verified != rhs_storage._verified {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._padding != rhs_storage._padding {return false}
        if _storage._tasks != rhs_storage._tasks {return false}
        if _storage._markAsUnread != rhs_storage._markAsUnread {return false}
        if _storage._conversationArchive != rhs_storage._conversationArchive {return false}
        if _storage._markTopicAsTrack != rhs_storage._markTopicAsTrack {return false}
        if _storage._topicMark != rhs_storage._topicMark {return false}
        if _storage._topicAction != rhs_storage._topicAction {return false}
        if _storage._serverTimestamp != rhs_storage._serverTimestamp {return false}
        if _storage._criticalRead != rhs_storage._criticalRead {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.Sent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".Sent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "destination"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "message"),
    4: .same(proto: "expirationStartTimestamp"),
    5: .same(proto: "rapidFiles"),
    6: .same(proto: "serverTimestamp"),
    7: .same(proto: "sequenceId"),
    8: .same(proto: "notifySequenceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._destination) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._expirationStartTimestamp) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.rapidFiles) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._serverTimestamp) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._sequenceID) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self._notifySequenceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._destination {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._expirationStartTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    if !self.rapidFiles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rapidFiles, fieldNumber: 5)
    }
    try { if let v = self._serverTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._sequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._notifySequenceID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.Sent, rhs: DifftServiceProtos_SyncMessage.Sent) -> Bool {
    if lhs._destination != rhs._destination {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._message != rhs._message {return false}
    if lhs._expirationStartTimestamp != rhs._expirationStartTimestamp {return false}
    if lhs.rapidFiles != rhs.rapidFiles {return false}
    if lhs._serverTimestamp != rhs._serverTimestamp {return false}
    if lhs._sequenceID != rhs._sequenceID {return false}
    if lhs._notifySequenceID != rhs._notifySequenceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.Contacts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".Contacts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blob"),
    2: .same(proto: "isComplete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blob) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isComplete) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isComplete {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.Contacts, rhs: DifftServiceProtos_SyncMessage.Contacts) -> Bool {
    if lhs._blob != rhs._blob {return false}
    if lhs._isComplete != rhs._isComplete {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.Groups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".Groups"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._blob) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._blob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.Groups, rhs: DifftServiceProtos_SyncMessage.Groups) -> Bool {
    if lhs._blob != rhs._blob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.Blocked: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".Blocked"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numbers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.numbers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.numbers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.numbers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.Blocked, rhs: DifftServiceProtos_SyncMessage.Blocked) -> Bool {
    if lhs.numbers != rhs.numbers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.Request, rhs: DifftServiceProtos_SyncMessage.Request) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.Request.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "CONTACTS"),
    2: .same(proto: "GROUPS"),
    3: .same(proto: "BLOCKED"),
    4: .same(proto: "CONFIGURATION"),
  ]
}

extension DifftServiceProtos_SyncMessage.Read: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".Read"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "readPosition"),
    4: .same(proto: "messageMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sender) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._readPosition) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._messageMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sender {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._readPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._messageMode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.Read, rhs: DifftServiceProtos_SyncMessage.Read) -> Bool {
    if lhs._sender != rhs._sender {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._readPosition != rhs._readPosition {return false}
    if lhs._messageMode != rhs._messageMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.Configuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".Configuration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "readReceipts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._readReceipts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._readReceipts {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.Configuration, rhs: DifftServiceProtos_SyncMessage.Configuration) -> Bool {
    if lhs._readReceipts != rhs._readReceipts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.Task: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".Task"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "taskId"),
    2: .same(proto: "version"),
    3: .same(proto: "type"),
    4: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._taskID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._version) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._type) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._taskID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.Task, rhs: DifftServiceProtos_SyncMessage.Task) -> Bool {
    if lhs._taskID != rhs._taskID {return false}
    if lhs._version != rhs._version {return false}
    if lhs._type != rhs._type {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.Task.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "READ"),
  ]
}

extension DifftServiceProtos_SyncMessage.MarkTopicAsTrack: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".MarkTopicAsTrack"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .same(proto: "topicId"),
    3: .same(proto: "flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._topicID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._flag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._topicID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._flag {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.MarkTopicAsTrack, rhs: DifftServiceProtos_SyncMessage.MarkTopicAsTrack) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs._topicID != rhs._topicID {return false}
    if lhs._flag != rhs._flag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.MarkTopicAsTrack.Flag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "TRACK"),
    2: .same(proto: "UNTRACK"),
  ]
}

extension DifftServiceProtos_SyncMessage.MarkAsUnread: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".MarkAsUnread"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .same(proto: "flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._flag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._flag {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.MarkAsUnread, rhs: DifftServiceProtos_SyncMessage.MarkAsUnread) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs._flag != rhs._flag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.MarkAsUnread.Flag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLEAR"),
    1: .same(proto: "UNREAD"),
    2: .same(proto: "READ"),
  ]
}

extension DifftServiceProtos_SyncMessage.ConversationArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_SyncMessage.protoMessageName + ".ConversationArchive"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conversation"),
    2: .same(proto: "flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._flag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._flag {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_SyncMessage.ConversationArchive, rhs: DifftServiceProtos_SyncMessage.ConversationArchive) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs._flag != rhs._flag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_SyncMessage.ConversationArchive.Flag: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNARCHIVE"),
    1: .same(proto: "ARCHIVE"),
  ]
}

extension DifftServiceProtos_AttachmentPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachmentPointer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "contentType"),
    3: .same(proto: "key"),
    4: .same(proto: "size"),
    5: .same(proto: "thumbnail"),
    6: .same(proto: "digest"),
    7: .same(proto: "fileName"),
    8: .same(proto: "flags"),
    9: .same(proto: "width"),
    10: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._size) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._thumbnail) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._digest) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._width) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._thumbnail {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._digest {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._width {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_AttachmentPointer, rhs: DifftServiceProtos_AttachmentPointer) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._contentType != rhs._contentType {return false}
    if lhs._key != rhs._key {return false}
    if lhs._size != rhs._size {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_AttachmentPointer.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VOICE_MESSAGE"),
  ]
}

extension DifftServiceProtos_GroupContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "members"),
    5: .same(proto: "avatar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 4)
    }
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_GroupContext, rhs: DifftServiceProtos_GroupContext) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._type != rhs._type {return false}
    if lhs._name != rhs._name {return false}
    if lhs.members != rhs.members {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_GroupContext.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "UPDATE"),
    2: .same(proto: "DELIVER"),
    3: .same(proto: "QUIT"),
    4: .same(proto: "REQUEST_INFO"),
  ]
}

extension DifftServiceProtos_ContactDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "name"),
    3: .same(proto: "avatar"),
    4: .same(proto: "color"),
    5: .same(proto: "verified"),
    6: .same(proto: "profileKey"),
    7: .same(proto: "blocked"),
    8: .same(proto: "expireTimer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._number) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._color) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._verified) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._blocked) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._expireTimer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._number {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._verified {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._blocked {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._expireTimer {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_ContactDetails, rhs: DifftServiceProtos_ContactDetails) -> Bool {
    if lhs._number != rhs._number {return false}
    if lhs._name != rhs._name {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs._color != rhs._color {return false}
    if lhs._verified != rhs._verified {return false}
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs._blocked != rhs._blocked {return false}
    if lhs._expireTimer != rhs._expireTimer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_ContactDetails.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_ContactDetails.protoMessageName + ".Avatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_ContactDetails.Avatar, rhs: DifftServiceProtos_ContactDetails.Avatar) -> Bool {
    if lhs._contentType != rhs._contentType {return false}
    if lhs._length != rhs._length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_GroupDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupDetails"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "members"),
    4: .same(proto: "avatar"),
    5: .same(proto: "active"),
    6: .same(proto: "expireTimer"),
    7: .same(proto: "color"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._avatar) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._active) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._expireTimer) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 3)
    }
    try { if let v = self._avatar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._active {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._expireTimer {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_GroupDetails, rhs: DifftServiceProtos_GroupDetails) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._name != rhs._name {return false}
    if lhs.members != rhs.members {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs._active != rhs._active {return false}
    if lhs._expireTimer != rhs._expireTimer {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DifftServiceProtos_GroupDetails.Avatar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DifftServiceProtos_GroupDetails.protoMessageName + ".Avatar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "length"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._length) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._length {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DifftServiceProtos_GroupDetails.Avatar, rhs: DifftServiceProtos_GroupDetails.Avatar) -> Bool {
    if lhs._contentType != rhs._contentType {return false}
    if lhs._length != rhs._length {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
