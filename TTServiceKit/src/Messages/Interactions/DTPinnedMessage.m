//
//  DTPinnedMessage.m
//  Wea
//
//  Created by Ethan on 2022/3/19.
//

#import "DTPinnedMessage.h"
#import "TSIncomingMessage.h"
#import "TSOutgoingMessage.h"
//
#import "TSAccountManager.h"
#import "OWSDevice.h"
#import "TSAttachmentPointer.h"
#import "TSAttachmentStream.h"
#import "TSGroupThread.h"
#import "TSQuotedMessage.h"
#import "OWSContact.h"
#import "DTCombinedForwardingMessage.h"
#import "OWSAttachmentsProcessor.h"
#import <TTServiceKit/TTServiceKit-Swift.h>
#import "DTCardMessageEntity.h"
#import "DTMention.h"
#import "DTPinnedMessageEntity.h"

@interface DTPinnedMessage ()

@end

@implementation DTPinnedMessage

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
                         groupId:(NSString *)groupId
                 incomingMessage:(nullable TSIncomingMessage *)incomingMessage
                 outgoingMessage:(nullable TSOutgoingMessage *)outgoingMessage
                           pinId:(nullable NSString *)pinId
                      realSource:(DTRealSourceEntity *)realSource
             timestampForSorting:(uint64_t)timestampForSorting
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId];

    if (!self) {
        return self;
    }

    _groupId = groupId;
    _incomingMessage = incomingMessage;
    _outgoingMessage = outgoingMessage;
    _pinId = pinId;
    _realSource = realSource;
    _timestampForSorting = timestampForSorting;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

//MARK: database

#pragma mark - Any Transaction Hooks

- (void)updateAssociatedRecordsWithTransaction:(SDSAnyWriteTransaction *)transaction{
    
    self.uniqueId = self.pinId;
    if (self.outgoingMessage) {
        self.outgoingMessage.pinId = self.pinId;
        self.outgoingMessage.uniqueId = self.pinId;
        self.outgoingMessage.isPinnedMessage = YES;
    } else if (self.incomingMessage) {
        self.incomingMessage.pinId = self.pinId;
        self.incomingMessage.uniqueId = self.pinId;
        self.incomingMessage.isPinnedMessage = YES;
    }
}

- (void)didUpdateAssociatedRecordsWithTransaction:(SDSAnyWriteTransaction *)transaction{
    [self updateOriginMessageWithTransaction:transaction];
}

- (void)anyWillInsertWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyWillInsertWithTransaction:transaction];

    [self updateAssociatedRecordsWithTransaction:transaction];

}

- (void)anyWillUpdateWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyWillUpdateWithTransaction:transaction];
    
    [self updateAssociatedRecordsWithTransaction:transaction];
}

- (void)anyDidInsertWithTransaction:(SDSAnyWriteTransaction *)transaction{
    [super anyDidInsertWithTransaction:transaction];
    [self didUpdateAssociatedRecordsWithTransaction:transaction];
}

- (void)anyDidUpdateWithTransaction:(SDSAnyWriteTransaction *)transaction{
    [super anyDidUpdateWithTransaction:transaction];
    [self didUpdateAssociatedRecordsWithTransaction:transaction];
}

- (void)anyWillRemoveWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyWillRemoveWithTransaction:transaction];
    
    DTPinnedMessage *localPinnedMessage = [DTPinnedMessage anyFetchWithUniqueId:self.pinId transaction:transaction];
    if (!localPinnedMessage) {
        return;
    }
    self.pinId = nil;
    [self updateOriginMessageWithTransaction:transaction];
}

- (void)updateOriginMessageWithTransaction:(SDSAnyWriteTransaction *)transaction {
    
    TSMessage *message = (TSMessage *)[self origionMessageWithTransaction:transaction];
    
    if (!message) return;
    [message anyUpdateMessageWithTransaction:transaction
                                       block:^(TSMessage * msg) {
        msg.pinId = self.pinId;
    }];
    
}

- (TSMessage *)origionMessageWithTransaction:(SDSAnyWriteTransaction *)transaction {
    
    __block TSMessage *releatedMessage = nil;
    
    NSError *error;
    NSArray<TSMessage *> *messages = (NSArray<TSMessage *> *)[InteractionFinder
        interactionsWithTimestamp:self.realSource.timestamp
                           filter:^(TSInteraction *interaction) {
                               return [interaction isKindOfClass:[TSMessage class]];
                           }
                      transaction:transaction
                            error:&error];
    [messages enumerateObjectsUsingBlock:^(TSMessage * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        TSMessage *tempMessage = obj;
        if ([tempMessage isKindOfClass:TSIncomingMessage.class] && self.incomingMessage) {
            TSIncomingMessage *incomingMessage = (TSIncomingMessage *)tempMessage;
            if ([self.realSource.source isEqualToString:incomingMessage.authorId]) {
                releatedMessage = tempMessage;
                *stop = YES;
            }
        } else if ([tempMessage isKindOfClass:TSOutgoingMessage.class] && self.outgoingMessage) {
            releatedMessage = tempMessage;
            *stop = YES;
        }
    }];
    
    return releatedMessage;
}

//MARK: TSMessage -> DTPinnedMessage
+ (DTPinnedMessage *)pinnedMessageFromMessage:(TSMessage *)message {
    
    DTPinnedMessage *pinnedMessage = [DTPinnedMessage new];
    DTRealSourceEntity *realSource = [DTRealSourceEntity new];
    realSource.timestamp = message.timestamp;

    if ([message isKindOfClass:TSOutgoingMessage.class]) {
        TSOutgoingMessage *outgoingMessage = (TSOutgoingMessage *)message.copy;
        
        outgoingMessage.isPinnedMessage = YES;
        pinnedMessage.outgoingMessage = outgoingMessage;
        realSource.source = [TSAccountManager localNumber];
        realSource.sourceDevice = outgoingMessage.sourceDeviceId ?: [OWSDevice currentDeviceId];
        pinnedMessage.timestampForSorting = outgoingMessage.timestampForSorting;
    }
    if ([message isKindOfClass:TSIncomingMessage.class]) {
        TSIncomingMessage *incomingMessage = (TSIncomingMessage *)message.copy;
        incomingMessage.isPinnedMessage = YES;
        pinnedMessage.incomingMessage = incomingMessage;
        realSource.source = incomingMessage.authorId;
        realSource.sourceDevice = incomingMessage.sourceDeviceId;
        pinnedMessage.timestampForSorting = incomingMessage.timestampForSorting;
    }
    pinnedMessage.realSource = realSource;
    
    return pinnedMessage;
}

//- (void)copyAttachmentsWithTransaction:(SDSAnyWriteTransaction *)transaction {
//    
//    TSMessage *contentMessage = self.contentMessage;
//    
//    NSString *(^copyHandler)(NSString *) = ^(NSString *attachmentId) {
//        
//        TSAttachment *originAttachment = [TSAttachment fetchObjectWithUniqueID:attachmentId transaction:transaction];
//        TSAttachment *copiedAttachment = nil;
//        if ([originAttachment isKindOfClass:TSAttachmentStream.class]) {
//            TSAttachmentStream *originStream = (TSAttachmentStream *)originAttachment;
//            copiedAttachment = [[TSAttachmentStream alloc] initWithContentType:originStream.contentType byteCount:originStream.byteCount sourceFilename:originStream.sourceFilename];
//            NSError *error;
//            BOOL copyResult = [[NSFileManager defaultManager] copyItemAtPath:originStream.filePath toPath:((TSAttachmentStream *)copiedAttachment).filePath error:&error];
//            if (error || !copyResult) {
//                NSString *errorLog = [NSString stringWithFormat:@"%@ copy error: %@", self.logTag, error.description];
//                OWSProdError(errorLog);
//            }
//            if (copiedAttachment) {
//                [copiedAttachment saveWithTransaction:transaction];
//            }
//        }
//        
//        return copiedAttachment.uniqueId;
//    };
//    
//    if (contentMessage.attachmentIds && contentMessage.attachmentIds.count > 0) {
//        NSMutableArray <NSString *> *attachmentIds = @[].mutableCopy;
//        [contentMessage.attachmentIds enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
//            NSString *copiedAttachmentId = copyHandler(obj);
//            [attachmentIds addObject:copiedAttachmentId];
//        }];
//        contentMessage.attachmentIds = attachmentIds;
//    }
//}

//MARK: base64 ->DTPinnedMessage/TSMessage
+ (DTPinnedMessage *)parseBase64StringToPinnedMessage:(DTPinnedMessageEntity*)messageEntity groupId:(NSString *)groupId transaction:(SDSAnyWriteTransaction *)transaction {
    
    NSString *base64String = messageEntity.content;
    
    OWSAssertDebug(base64String.length > 0);
    NSData *envelopeData = [[NSData alloc] initWithBase64EncodedString:base64String options:0];
    DSKProtoEnvelope *envelope = [[DSKProtoEnvelope alloc] initWithSerializedData:envelopeData error:nil];
    
    DTRealSourceEntity *realSource = [DTRealSourceEntity new];
    realSource.timestamp = envelope.timestamp;
    realSource.source = envelope.source;
    realSource.sourceDevice = envelope.sourceDevice;
    
    DSKProtoContent *content = [[DSKProtoContent alloc] initWithSerializedData:envelope.content error:nil];
    DSKProtoDataMessage *dataMessage =  content.dataMessage;
//    if (dataMessage.timestamp != envelope.timestamp) {
//        OWSLogError(
//            @"Ignoring message with non-matching data message timestamp: %@", envelope.source);
//        return nil;
//    }
    
    NSString *body = dataMessage.body;
    uint64_t timestamp = envelope.timestamp;
    NSString *atPersons = dataMessage.atPersons;
    NSArray <DTMention *> *mentions = [DTMention mentionsWithProto:dataMessage];
    
//    DSKProtoGroupContext *groupContext = dataMessage.group;
    NSData *data = [TSGroupThread transformToLocalGroupIdWithServerGroupId:groupId];
    TSGroupThread *groupThread = [TSGroupThread getOrCreateThreadWithGroupId:data transaction:transaction];
    
    // pin 消息单独存储一份，unpin 时直接删除
    NSString *messageId = nil;
//    [TSInteraction generateUniqueIdWithAuthorId:envelope.source
//                                                             deviceId:envelope.sourceDevice
//                                                            timestamp:envelope.timestamp];
    
    TSQuotedMessage *quotedMessage = nil;
    if (dataMessage.quote) {
        quotedMessage = [TSQuotedMessage quotedMessageForQuoteProto:dataMessage.quote
                                                             thread:groupThread
                                                          messageId:messageId
                                                              relay:nil
                                                        transaction:transaction];
    }
    
    DTCombinedForwardingMessage *forwardMessage = nil;
    if (dataMessage.forwardContext) {
        DSKProtoDataMessageForward *forward = [DTCombinedForwardingMessage
                                               buildRootForwardProtoWithForwardContextProto:dataMessage.forwardContext
                                               timestamp:timestamp
                                               serverTimestamp:envelope.systemShowTimestamp
                                               author:envelope.source
                                               body:body];
        
        forwardMessage = [DTCombinedForwardingMessage
                          forwardingMessageForDataMessage:forward
                          threadId:groupThread.uniqueId
                          messageId:messageId
                          relay:envelope.relay
                          transaction:transaction];
    }
    
    DTCardMessageEntity *cardMessage = nil;
    if (dataMessage.card) {
        cardMessage = [DTCardMessageEntity cardEntityWithProto:dataMessage.card];
        NSString *cardUniqueId = [cardMessage generateUniqueIdWithSource:envelope.source conversationId:groupId];
        DTCardMessageEntity *refreshedCard = messageEntity.businessInfo;
        if(refreshedCard){
            NSString *refreshedCardId = [refreshedCard generateUniqueIdWithSource:refreshedCard.source conversationId:refreshedCard.conversationId];
            if(DTParamsUtils.validateString(refreshedCardId) &&
               DTParamsUtils.validateString(refreshedCard.content)){
                if([cardUniqueId isEqualToString:refreshedCardId]){
                    if(refreshedCard.version > cardMessage.version) {
                        [messageEntity.businessInfo updateDataWithCardUniqueId:cardUniqueId receivedCardType:DTReceivedCardTypePinRefreshed transaction:transaction updateAction:nil];
                    } else {
                        [cardMessage updateDataWithCardUniqueId:cardUniqueId receivedCardType:DTReceivedCardTypePin transaction:transaction updateAction:nil];
                        DDLogInfo(@"refreshedCard: Ignore lower version card!");
                    }
                } else {
                    DDLogInfo(@"refreshedCard: Ignore different cardUniqueId card!");
                }
            } else {
                DDLogError(@"refreshedCardId or content is empty!");
            }
        } else {
            [cardMessage updateDataWithCardUniqueId:cardUniqueId receivedCardType:DTReceivedCardTypePin transaction:transaction updateAction:nil];
        }
        
    }
    
    __block DTPinnedMessage *pinnedMessage = [DTPinnedMessage new];
    pinnedMessage.groupId = groupId;
    pinnedMessage.realSource = realSource;
    
    void (^attachmentHandler)(NSArray <NSString *> *) = ^(NSArray <NSString *> *attachmentIds) {
        if ([realSource.source isEqualToString:[TSAccountManager localNumber]]) {
            TSOutgoingMessage *outgoingMessage = [[TSOutgoingMessage alloc] initOutgoingMessageWithTimestamp:timestamp
                                                                                                    inThread:groupThread
                                                                                                 messageBody:body
                                                                                                   atPersons:atPersons
                                                                                                    mentions:mentions
                                                                                               attachmentIds:attachmentIds.mutableCopy
                                                                                            expiresInSeconds:0
                                                                                             expireStartedAt:0
                                                                                              isVoiceMessage:NO
                                                                                            groupMetaMessage:TSGroupMessageUnspecified
                                                                                               quotedMessage:quotedMessage
                                                                                           forwardingMessage:forwardMessage
                                                                                                contactShare:nil];
            outgoingMessage.card = cardMessage;
            pinnedMessage.outgoingMessage = outgoingMessage;
            pinnedMessage.timestampForSorting = outgoingMessage.timestampForSorting;
        } else {
            // TODO: servertimestamp
            TSIncomingMessage *incomingMessage = [[TSIncomingMessage alloc] initIncomingMessageWithTimestamp:timestamp
                                                                                             serverTimestamp:timestamp
                                                                                                  sequenceId:0
                                                                                            notifySequenceId:0
                                                                                                    inThread:groupThread
                                                                                                    authorId:realSource.source
                                                                                              sourceDeviceId:realSource.sourceDevice
                                                                                                 messageBody:body
                                                                                                   atPersons:atPersons
                                                                                                    mentions:mentions
                                                                                               attachmentIds:attachmentIds
                                                                                            expiresInSeconds:0
                                                                                               quotedMessage:quotedMessage
                                                                                           forwardingMessage:forwardMessage
                                                                                                contactShare:nil];
            incomingMessage.card = cardMessage;
            pinnedMessage.incomingMessage = incomingMessage;
            pinnedMessage.timestampForSorting = incomingMessage.timestampForSorting;
        }
    };
    
    if (dataMessage.attachments.count > 0) {
        
        NSArray<TSAttachmentPointer *> *pointers = [TSAttachmentPointer
                                                    attachmentPointersFromProtos:dataMessage.attachments
                                                    relay:envelope.relay
                                                    albumMessageId:messageId
                                                    albumId:groupThread.uniqueId];
        
        OWSAttachmentsProcessor *attachmentsProcessor =
            [[OWSAttachmentsProcessor alloc] initWithAttachmentPointers:pointers transaction:transaction];
        if (attachmentsProcessor.hasSupportedAttachments) {
            NSArray *attachmentIds = attachmentsProcessor.attachmentIds;
            attachmentHandler(attachmentIds);
        }
    } else {
        attachmentHandler(@[]);
    }
    
    return pinnedMessage;
}

- (void)downloadAllAttachmentWithTransaction:(SDSAnyWriteTransaction *)transaction
                                     success:(void(^)(TSAttachmentStream *attachmentStream))success
                                     failure:(void(^)(NSError *error))failure {
    
    TSMessage *contentMessage = self.contentMessage;
    
    if (contentMessage.attachmentIds && contentMessage.attachmentIds.count > 0) {
        NSString *attachmentId = contentMessage.attachmentIds.firstObject;
        [self downloadAttachment:attachmentId transaction:transaction success:^(TSAttachmentStream *attachmentStream) {
        } failure:^(NSError *error) {
        }];
    }
    
    DTCombinedForwardingMessage *forwardingMessage = contentMessage.combinedForwardingMessage;
    if (forwardingMessage && forwardingMessage.subForwardingMessages.count > 0) {
        [forwardingMessage handleForwardingAttachmentsWithOrigionMessage:self.contentMessage transaction:transaction completion:nil];
    }
    
    TSQuotedMessage *quotedMessage = contentMessage.quotedMessage;
    if (quotedMessage && quotedMessage.thumbnailAttachmentPointerId) {
        NSString *quoteAttachmentId = contentMessage.quotedMessage.thumbnailAttachmentPointerId;
        [self downloadAttachment:quoteAttachmentId transaction:transaction success:^(TSAttachmentStream *attachmentStream) {
            DatabaseStorageAsyncWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *successTransaction) {
                [contentMessage setQuotedMessageThumbnailAttachmentStream:attachmentStream];
                [self anyInsertWithTransaction:successTransaction];
            });
        } failure:^(NSError *error) {
        }];
    }
}

- (void)downloadAttachment:(NSString *)attachmentId
               transaction:(SDSAnyWriteTransaction *)transaction success:(void(^)(TSAttachmentStream *attachmentStream))success
                   failure:(void(^)(NSError *error))failure {
    
    TSAttachmentPointer *attachmentPointer =
        [TSAttachmentPointer anyFetchAttachmentPointerWithUniqueId:attachmentId
                                         transaction:transaction];

    if ([attachmentPointer isKindOfClass:[TSAttachmentPointer class]]) {
        OWSAttachmentsProcessor *attachmentProcessor =
            [[OWSAttachmentsProcessor alloc] initWithAttachmentPointer:attachmentPointer];

        [attachmentProcessor fetchAttachmentsForMessage:self.contentMessage forceDownload:NO
            transaction:transaction
            success:^(TSAttachmentStream *_Nonnull attachmentStream) {
                DDLogInfo(@"%@ success to download forwarding attachment!" ,self.logTag);
                success(attachmentStream);
            }
            failure:^(NSError *_Nonnull error) {
                DDLogWarn(@"%@ failed to fetch forwarding attachment for message: %lu with error: %@",
                    self.logTag,
                    (unsigned long)self.realSource.timestamp,
                    error);
                failure(error);
            }];
    } else {
        if (success) success(nil);
    }
}

//MARK: TSMessage -> base64
+ (NSString *)pinMessageEnvelopeBase64String:(TSMessage *)message {
    
    NSData *envelopePlainTextData = [[self envelopeBuilderWithMessage:message] buildSerializedDataAndReturnError:nil];
    NSString *base64String = [envelopePlainTextData base64EncodedStringWithOptions:0];
    if (base64String.length == 0) {
        return nil;
    }
    return base64String;
}

+ (DSKProtoEnvelopeBuilder *)envelopeBuilderWithMessage:(TSMessage *)message {
    
    DSKProtoEnvelopeBuilder *builder = [DSKProtoEnvelope builder];
    builder.type = DSKProtoEnvelopeTypePlaintext;
    builder.timestamp = message.timestamp;
    if ([message isKindOfClass:TSOutgoingMessage.class]) {
        TSOutgoingMessage *outgoingMessage = (TSOutgoingMessage *)message;
        builder.source = [TSAccountManager localNumber];
        builder.sourceDevice = outgoingMessage.sourceDeviceId ?: [OWSDevice currentDeviceId];
    }
    if ([message isKindOfClass:TSIncomingMessage.class]) {
        TSIncomingMessage *incomingMessage = (TSIncomingMessage *)message;
        builder.source = incomingMessage.authorId;
        builder.sourceDevice = incomingMessage.sourceDeviceId;
    }
    
    builder.content = [self buildPlainTextDataWithMessage:message];
    
    return builder;
}

+ (nullable NSData *)buildPlainTextDataWithMessage:(TSMessage *)message {
    
    DSKProtoContentBuilder *contentBuilder = [DSKProtoContent builder];
    contentBuilder.dataMessage = [[self dataMessageBuilderWithMessage:message] buildAndReturnError:nil];
    return [contentBuilder buildSerializedDataAndReturnError:nil];
}

+ (DSKProtoDataMessageBuilder *)dataMessageBuilderWithMessage:(TSMessage *)message {
   
    OWSAssertDebug(message);
    TSThread *thread = message.threadWithSneakyTransaction;
    
    DSKProtoDataMessageBuilder *builder = [DSKProtoDataMessage builder];
    
    builder.timestamp = message.timestamp;
    builder.body = message.body;
    builder.atPersons = message.atPersons;
    builder.expireTimer = message.expiresInSeconds;
    
    if (message.mentions && message.mentions.count > 0) {
        [builder setMentions:[DTMention mentionsProtoWithMentions:message.mentions]];
    }
    
    // Group Messages
    if ([thread isKindOfClass:[TSGroupThread class]]) {
        TSGroupThread *gThread = (TSGroupThread *)thread;
        DSKProtoGroupContextBuilder *groupBuilder = [DSKProtoGroupContext builder];
        
        [groupBuilder setType:DSKProtoGroupContextTypeDeliver];
        [groupBuilder setId:gThread.groupModel.groupId];
        [builder setGroup:[groupBuilder buildAndReturnError:nil]];
    }
    
    if (message.attachmentIds && message.attachmentIds.count > 0) {
        NSMutableArray *attachments = [NSMutableArray new];
        for (NSString *attachmentId in message.attachmentIds) {
            [attachments addObject:[TSAttachmentStream buildProtoForAttachmentId:attachmentId]];
        }
        [builder setAttachments:attachments];
    }

    // Quoted Reply
    if (message.quotedMessage) {
        DSKProtoDataMessageQuoteBuilder *_Nullable quotedMessageBuilder = [DTPinnedMessage quotedMessageBuilderWith:message.quotedMessage];
        if (quotedMessageBuilder) {
            [builder setQuote:[quotedMessageBuilder buildAndReturnError:nil]];
        }
    }
    
    // combine forwarding
    if (message.combinedForwardingMessage) {
        DSKProtoDataMessageForwardContext *_Nullable forwardingContextProto = [DTPinnedMessage combinedForwardingContextProtoWith:message.combinedForwardingMessage];
        
        if (forwardingContextProto) {
            [builder setForwardContext:forwardingContextProto];
            builder.requiredProtocolVersion = DSKProtoDataMessageProtocolVersionForward;
        }
    }
    
    // card
    if (message.card) {
        DSKProtoCard *_Nullable cardProto = [DTCardMessageEntity cardProtoWithEntity:message.card]; //self.combinedForwardingContextProto;
        if (cardProto) {
            [builder setCard:cardProto];
            builder.requiredProtocolVersion = DSKProtoDataMessageProtocolVersionCard;
        }
    }

//    // Contact Share
//    if (message.contactShare) {
//        DSKProtoDataMessageContact *_Nullable contactProto =
//            [OWSContacts protoForContact:message.contactShare];
//        if (contactProto) {
//            builder.requiredProtocolVersion = DSKProtoDataMessageProtocolVersionContact;
//            [builder addContact:contactProto];
//        } else {
//            OWSFailDebug(@"%@ in %s contactProto was unexpectedly nil", self.logTag, __PRETTY_FUNCTION__);
//        }
//    }

    return builder;
}


+ (nullable DSKProtoDataMessageQuoteBuilder *)quotedMessageBuilderWith:(TSQuotedMessage *)quotedMessage {
    
    if (!quotedMessage) {
        return nil;
    }

    DSKProtoDataMessageQuoteBuilder *quoteBuilder = [DSKProtoDataMessageQuote builder];
    [quoteBuilder setId:quotedMessage.timestamp];
    [quoteBuilder setAuthor:quotedMessage.authorId];

    BOOL hasQuotedText = NO;
    BOOL hasQuotedAttachment = NO;
    if (quotedMessage.body.length > 0) {
        hasQuotedText = YES;
        [quoteBuilder setText:quotedMessage.body];
    }

    if (quotedMessage.quotedAttachments) {
        for (OWSAttachmentInfo *attachment in quotedMessage.quotedAttachments) {
            hasQuotedAttachment = YES;

            DSKProtoDataMessageQuoteQuotedAttachmentBuilder *quotedAttachmentBuilder =
                [DSKProtoDataMessageQuoteQuotedAttachment builder];

            quotedAttachmentBuilder.contentType = attachment.contentType;
            quotedAttachmentBuilder.fileName = attachment.sourceFilename;
            if (attachment.thumbnailAttachmentStreamId) {
                quotedAttachmentBuilder.thumbnail =
                    [TSAttachmentStream buildProtoForAttachmentId:attachment.thumbnailAttachmentStreamId];
            }

            DSKProtoDataMessageQuoteQuotedAttachment *quotedAttachment = [quotedAttachmentBuilder buildAndReturnError:nil];
            if (quotedAttachment) {
                [quoteBuilder addAttachments:quotedAttachment];
            }
        }
    }

    if (hasQuotedText || hasQuotedAttachment) {
        return quoteBuilder;
    } else {
        OWSFailDebug(@"Invalid quoted message data.");
        return nil;
    }
}

+ (nullable DSKProtoDataMessageForwardContext *)combinedForwardingContextProtoWith:(DTCombinedForwardingMessage *)combinedForwardingMessage {
    
    if (!combinedForwardingMessage) {
        return nil;
    }
    DSKProtoDataMessageForwardContextBuilder *forwardingContextBuilder = [DSKProtoDataMessageForwardContext builder];
    
    DSKProtoDataMessageForwardBuilder *forwardingBuilder = [DSKProtoDataMessageForward builder];
    
    NSMutableArray *rapidFiles = @[].mutableCopy;
    [combinedForwardingMessage.rapidFiles enumerateObjectsUsingBlock:^(DTRapidFile * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        DSKProtoRapidFileBuilder *rapidFileBuilder = [DSKProtoRapidFile builder];
        rapidFileBuilder.rapidHash = obj.rapidHash;
        [rapidFileBuilder setAuthorizedID:obj.authorizedId];
        DSKProtoRapidFile *rapidFileProto = [rapidFileBuilder buildAndReturnError:nil];
        [rapidFiles addObject:rapidFileProto];
    }];
    
    NSArray<DSKProtoDataMessageForward *> * forwards = [self handleCombinedForwardingMessageBuilder:forwardingBuilder forwardingMessage:combinedForwardingMessage].forwards;
    
    if (forwards && forwards.count) {
        [forwardingContextBuilder setForwards:forwards];
    }
    
    if(rapidFiles.count){
        [forwardingContextBuilder setRapidFiles:rapidFiles.copy];
    }
    
    return [forwardingContextBuilder buildAndReturnError:nil];
}

+ (nullable DSKProtoDataMessageForward *)handleCombinedForwardingMessageBuilder:(DSKProtoDataMessageForwardBuilder *)forwardingBuilder forwardingMessage:(DTCombinedForwardingMessage *)forwardingMessage {
    
    if (!forwardingMessage) {
        return nil;
    }
    
    [forwardingBuilder setId:forwardingMessage.timestamp];
    [forwardingBuilder setServerTimestamp:forwardingMessage.serverTimestamp];
    [forwardingBuilder setType:forwardingMessage.messageType];
    [forwardingBuilder setIsFromGroup:forwardingMessage.isFromGroup];
    [forwardingBuilder setAuthor:forwardingMessage.authorId];
    
    if (forwardingMessage.body.length > 0) {
        [forwardingBuilder setText:forwardingMessage.body];
    }
    
    if (forwardingMessage.card) {
        DSKProtoCard *cardProto = [DTCardMessageEntity cardProtoWithEntity:forwardingMessage.card];
        [forwardingBuilder setCard:cardProto];
    }
    
    NSMutableArray *attachments = @[].mutableCopy;
    for (NSString *attachmentId in forwardingMessage.forwardingAttachmentIds) {
        DSKProtoAttachmentPointer *pointer = [TSAttachmentStream buildProtoForAttachmentId:attachmentId];
        if(pointer){
            DDLogInfo(@"%@ pointer = %@ not exists",self.logTag ,attachmentId);
            OWSProdError(@"pointer not exists");
            [attachments addObject:pointer];
        }
    }
    [forwardingBuilder setAttachments:attachments.copy];
    
    [forwardingMessage.subForwardingMessages enumerateObjectsUsingBlock:^(DTCombinedForwardingMessage * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        DSKProtoDataMessageForwardBuilder *subForwardingBuilder = [DSKProtoDataMessageForward builder];
        DSKProtoDataMessageForward *subForwardProto = [self handleCombinedForwardingMessageBuilder:subForwardingBuilder forwardingMessage:obj];
        
        if (subForwardProto) {
            [forwardingBuilder addForwards:subForwardProto];
        }
    }];
    
    DSKProtoDataMessageForward *forwardProto = [forwardingBuilder buildAndReturnError:nil];
    
    return forwardProto;
}

- (TSMessage *)contentMessage {
    
    if (self.outgoingMessage) {
        return self.outgoingMessage;
    }
    
    if (self.incomingMessage) {
        return self.incomingMessage;
    }
    
    return nil;
}

- (TSGroupThread *)threadWithTransaction:(SDSAnyWriteTransaction *)transaction {
    
    NSData *data = [TSGroupThread transformToLocalGroupIdWithServerGroupId:self.groupId];
    TSGroupThread *thread = [TSGroupThread getOrCreateThreadWithGroupId:data transaction:transaction];
    
    return thread;
}

- (void)removePinMessageWithTransaction:(SDSAnyWriteTransaction *)transaction {
    // 判断原始消息是否已归档，若已归档，取消 pin 后，删除原始消息中的附件（pin 消息和原始消息共用同一份附件），若未归档则不能删除
    TSMessage *originalMessage = [self origionMessageWithTransaction:transaction];
    if (!originalMessage) {
        [self removeAttachmentsWithTransaction:transaction];
    }
    
    [self anyRemoveWithTransaction:transaction];
}

- (void)removeAttachmentsWithTransaction:(SDSAnyWriteTransaction *)transaction {
    TSMessage *message = self.contentMessage;
    NSMutableSet<NSString *> *messageAttachmentIds = [NSMutableSet new];
    
    if (message.attachmentIds.count > 0) {
        [messageAttachmentIds addObjectsFromArray:message.attachmentIds];
    }
    
    TSQuotedMessage *_Nullable quotedMessage = message.quotedMessage;
    if (quotedMessage && DTParamsUtils.validateArray(quotedMessage.thumbnailAttachmentStreamIds)) {
        [messageAttachmentIds addObjectsFromArray:quotedMessage.thumbnailAttachmentStreamIds];
    }
    
    DTCombinedForwardingMessage *forwardMessage = message.combinedForwardingMessage;
    if (forwardMessage) {
        [messageAttachmentIds addObjectsFromArray:[forwardMessage allForwardingAttachmentIds]];
    }
    
    NSMutableSet<NSString *> *attachmentPaths = [NSMutableSet new];
    for (NSString *attachmentId in messageAttachmentIds) {
        TSAttachment *attachment = [TSAttachment anyFetchWithUniqueId:attachmentId transaction:transaction];
        
        if ([attachment isKindOfClass:TSAttachmentStream.class]) {
            TSAttachmentStream *stream = (TSAttachmentStream *)attachment;
            
            if (DTParamsUtils.validateString(stream.filePath)) {
                [attachmentPaths addObject:stream.filePath];
            }
            if (DTParamsUtils.validateString(stream.thumbnailPath)) {
                [attachmentPaths addObject:stream.thumbnailPath];
            }
        }
        
        [attachment anyRemoveWithTransaction:transaction];
    }
    
    for (NSString *filePath in attachmentPaths) {
        NSError *error;
        OWSLogInfo(@"%@ Deleting orphan attachment file: %@", self.logTag, filePath);
        [[NSFileManager defaultManager] removeItemAtPath:filePath error:&error];
        if (error) {
            OWSFailDebug(@"%@ Could not remove orphan file at: %@", self.logTag, filePath);
        }
    }
}

@end
