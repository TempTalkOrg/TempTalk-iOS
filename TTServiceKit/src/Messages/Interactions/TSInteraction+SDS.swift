//
//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
//

import Foundation
import GRDB
import SignalCoreKit

// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
// Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// MARK: - Record

public struct InteractionRecord: SDSRecord {
    public weak var delegate: SDSRecordDelegate?

    public var tableMetadata: SDSTableMetadata {
        TSInteractionSerializer.table
    }

    public static var databaseTableName: String {
        TSInteractionSerializer.table.tableName
    }

    public var id: Int64?

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    public let recordType: SDSRecordType
    public let uniqueId: String

    // Properties
    public let associatedUniqueThreadId: String
    public let atPersons: String?
    public let attachmentIds: Data?
    public let authorId: String?
    public let body: String?
    public let card: Data?
    public let combinedForwardingMessage: Data?
    public let contactShare: Data?
    public let customAttributedMessage: Data?
    public let customMessage: String?
    public let editable: Bool?
    public let errorType: TSErrorMessageType?
    public let expireStartedAt: UInt64?
    public let expiresAt: UInt64?
    public let expiresInSeconds: UInt32?
    public let groupChatMode: TSGroupChatMode?
    public let groupMetaMessage: TSGroupMetaMessage?
    public let hasSyncedTranscript: Bool?
    public let inviteCode: String?
    public let isFromLinkedDevice: Bool?
    public let isPinnedMessage: Bool?
    public let isVoiceMessage: Bool?
    public let meetingDetailUrl: String?
    public let meetingName: String?
    public let meetingReminderType: DTMeetingReminderType?
    public let messageType: TSInfoMessageType?
    public let mostRecentFailureText: String?
    public let notifySequenceId: UInt64
    public let pinId: String?
    public let quotedMessage: Data?
    public let rapidFiles: Data?
    public let reactionMap: Data?
    public let reactionMessage: Data?
    public let read: Bool?
    public let realSource: Data?
    public let recall: Data?
    public let recallPreview: String?
    public let receivedAtTimestamp: UInt64
    public let recipientId: String?
    public let recipientStateMap: Data?
    public let sequenceId: UInt64
    public let serverTimestamp: UInt64
    public let sourceDeviceId: UInt32?
    public let timestamp: UInt64
    public let translateMessage: Data?
    public let threadUniqueId: String
    public let unregisteredRecipientId: String?
    public let whisperMessageType: TSWhisperMessageType?
    public let storedShouldStartExpireTimer: Bool?
    public let mentionedMsgType: OWSMentionedMsgType?
    public let configurationDurationSeconds: UInt32?
    public let shouldAffectThreadSorting: Bool?
    public let mentions: Data?
    public let storedMessageState: TSOutgoingMessageState?
    public let envelopSource: String?
    public let cardUniqueId: String?
    public let cardVersion: UInt32?
    public let messageModeType: TSMessageModeType?

    public enum CodingKeys: String, CodingKey, ColumnExpression, CaseIterable {
        case id
        case recordType
        case uniqueId
        case associatedUniqueThreadId
        case atPersons
        case attachmentIds
        case authorId
        case body
        case card
        case combinedForwardingMessage
        case contactShare
        case customAttributedMessage
        case customMessage
        case editable
        case errorType
        case expireStartedAt
        case expiresAt
        case expiresInSeconds
        case groupChatMode
        case groupMetaMessage
        case hasSyncedTranscript
        case inviteCode
        case isFromLinkedDevice
        case isPinnedMessage
        case isVoiceMessage
        case meetingDetailUrl
        case meetingName
        case meetingReminderType
        case messageType
        case mostRecentFailureText
        case notifySequenceId
        case pinId
        case quotedMessage
        case rapidFiles
        case reactionMap
        case reactionMessage
        case read
        case realSource
        case recall
        case recallPreview
        case receivedAtTimestamp
        case recipientId
        case recipientStateMap
        case sequenceId
        case serverTimestamp
        case sourceDeviceId
        case timestamp
        case translateMessage
        case threadUniqueId = "uniqueThreadId"
        case unregisteredRecipientId
        case whisperMessageType
        case storedShouldStartExpireTimer
        case mentionedMsgType
        case configurationDurationSeconds
        case shouldAffectThreadSorting
        case mentions
        case storedMessageState
        case envelopSource
        case cardUniqueId
        case cardVersion
        case messageModeType
    }

    public static func columnName(_ column: InteractionRecord.CodingKeys, fullyQualified: Bool = false) -> String {
        fullyQualified ? "\(databaseTableName).\(column.rawValue)" : column.rawValue
    }

    public func didInsert(with rowID: Int64, for column: String?) {
        guard let delegate = delegate else {
            owsFailDebug("Missing delegate.")
            return
        }
        delegate.updateRowId(rowID)
    }
}

// MARK: - Row Initializer

public extension InteractionRecord {
    static var databaseSelection: [SQLSelectable] {
        CodingKeys.allCases
    }

    init(row: Row) {
        id = row[0]
        recordType = row[1]
        uniqueId = row[2]
        associatedUniqueThreadId = row[3]
        atPersons = row[4]
        attachmentIds = row[5]
        authorId = row[6]
        body = row[7]
        card = row[8]
        combinedForwardingMessage = row[9]
        contactShare = row[10]
        customAttributedMessage = row[11]
        customMessage = row[12]
        editable = row[13]
        errorType = row[14]
        expireStartedAt = row[15]
        expiresAt = row[16]
        expiresInSeconds = row[17]
        groupChatMode = row[18]
        groupMetaMessage = row[19]
        hasSyncedTranscript = row[20]
        inviteCode = row[21]
        isFromLinkedDevice = row[22]
        isPinnedMessage = row[23]
        isVoiceMessage = row[24]
        meetingDetailUrl = row[25]
        meetingName = row[26]
        meetingReminderType = row[27]
        messageType = row[28]
        mostRecentFailureText = row[29]
        notifySequenceId = row[30]
        pinId = row[31]
        quotedMessage = row[32]
        rapidFiles = row[33]
        reactionMap = row[34]
        reactionMessage = row[35]
        read = row[36]
        realSource = row[37]
        recall = row[38]
        recallPreview = row[39]
        receivedAtTimestamp = row[40]
        recipientId = row[41]
        recipientStateMap = row[42]
        sequenceId = row[43]
        serverTimestamp = row[44]
        sourceDeviceId = row[45]
        timestamp = row[46]
        threadUniqueId = row[47]
        unregisteredRecipientId = row[48]
        whisperMessageType = row[49]
        storedShouldStartExpireTimer = row[50]
        mentionedMsgType = row[51]
        configurationDurationSeconds = row[52]
        shouldAffectThreadSorting = row[53]
        mentions = row[54]
        storedMessageState = row[55]
        envelopSource = row[56]
        cardUniqueId = row[57]
        cardVersion = row[58]
        messageModeType = row[59]
        translateMessage = row[60]
    }
}

// MARK: - StringInterpolation

public extension String.StringInterpolation {
    mutating func appendInterpolation(interactionColumn column: InteractionRecord.CodingKeys) {
        appendLiteral(InteractionRecord.columnName(column))
    }
    mutating func appendInterpolation(interactionColumnFullyQualified column: InteractionRecord.CodingKeys) {
        appendLiteral(InteractionRecord.columnName(column, fullyQualified: true))
    }
}

// MARK: - Deserialization

// TODO: Rework metadata to not include, for example, columns, column indices.
extension TSInteraction {
    // This method defines how to deserialize a model, given a
    // database row.  The recordType column is used to determine
    // the corresponding model class.
    class func fromRecord(_ record: InteractionRecord) throws -> TSInteraction {

        guard let recordId = record.id else {
            throw SDSError.invalidValue
        }

        switch record.recordType {
        case .dTCardOutgoingMessage:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }
            let customMessage: String = try SDSDeserialization.required(record.customMessage, name: "customMessage")
            guard let groupChatMode: TSGroupChatMode = record.groupChatMode else {
               throw SDSError.missingRequiredField
            }
            guard let groupMetaMessage: TSGroupMetaMessage = record.groupMetaMessage else {
               throw SDSError.missingRequiredField
            }
            let hasSyncedTranscript: Bool = try SDSDeserialization.required(record.hasSyncedTranscript, name: "hasSyncedTranscript")
            let isFromLinkedDevice: Bool = try SDSDeserialization.required(record.isFromLinkedDevice, name: "isFromLinkedDevice")
            let isVoiceMessage: Bool = try SDSDeserialization.required(record.isVoiceMessage, name: "isVoiceMessage")
            let mostRecentFailureText: String = try SDSDeserialization.required(record.mostRecentFailureText, name: "mostRecentFailureText")
            let rapidFilesSerialized: Data? = record.rapidFiles
            let rapidFiles: [DTRapidFile] = try SDSDeserialization.unarchive(rapidFilesSerialized, name: "rapidFiles")
            let recipientStateMapSerialized: Data? = record.recipientStateMap
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]? = try SDSDeserialization.optionalUnarchive(recipientStateMapSerialized, name: "recipientStateMap")
            let sourceDeviceId: UInt32 = try SDSDeserialization.required(record.sourceDeviceId, name: "sourceDeviceId")
            guard let storedMessageState: TSOutgoingMessageState = record.storedMessageState else {
               throw SDSError.missingRequiredField
            }

            return DTCardOutgoingMessage(grdbId: recordId,
                                         uniqueId: uniqueId,
                                         associatedUniqueThreadId: associatedUniqueThreadId,
                                         notifySequenceId: notifySequenceId,
                                         receivedAtTimestamp: receivedAtTimestamp,
                                         sequenceId: sequenceId,
                                         serverTimestamp: serverTimestamp,
                                         timestamp: timestamp,
                                         uniqueThreadId: uniqueThreadId,
                                         atPersons: atPersons,
                                         attachmentIds: attachmentIds,
                                         body: body,
                                         card: card,
                                         cardUniqueId: cardUniqueId,
                                         cardVersion: cardVersion,
                                         combinedForwardingMessage: combinedForwardingMessage,
                                         contactShare: contactShare,
                                         editable: editable,
                                         envelopSource: envelopSource,
                                         expireStartedAt: expireStartedAt,
                                         expiresAt: expiresAt,
                                         expiresInSeconds: expiresInSeconds,
                                         isPinnedMessage: isPinnedMessage,
                                         mentions: mentions,
                                         messageModeType: messageModeType,
                                         pinId: pinId,
                                         quotedMessage: quotedMessage,
                                         reactionMap: reactionMap,
                                         reactionMessage: reactionMessage,
                                         recall: recall,
                                         storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                         translateMessage: translateMessage,
                                         whisperMessageType: whisperMessageType,
                                         customMessage: customMessage,
                                         groupChatMode: groupChatMode,
                                         groupMetaMessage: groupMetaMessage,
                                         hasSyncedTranscript: hasSyncedTranscript,
                                         isFromLinkedDevice: isFromLinkedDevice,
                                         isVoiceMessage: isVoiceMessage,
                                         mostRecentFailureText: mostRecentFailureText,
                                         rapidFiles: rapidFiles,
                                         recipientStateMap: recipientStateMap,
                                         sourceDeviceId: sourceDeviceId,
                                         storedMessageState: storedMessageState)

        case .dTHyperlinkOutgoingMessage:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }
            let customMessage: String = try SDSDeserialization.required(record.customMessage, name: "customMessage")
            guard let groupChatMode: TSGroupChatMode = record.groupChatMode else {
               throw SDSError.missingRequiredField
            }
            guard let groupMetaMessage: TSGroupMetaMessage = record.groupMetaMessage else {
               throw SDSError.missingRequiredField
            }
            let hasSyncedTranscript: Bool = try SDSDeserialization.required(record.hasSyncedTranscript, name: "hasSyncedTranscript")
            let isFromLinkedDevice: Bool = try SDSDeserialization.required(record.isFromLinkedDevice, name: "isFromLinkedDevice")
            let isVoiceMessage: Bool = try SDSDeserialization.required(record.isVoiceMessage, name: "isVoiceMessage")
            let mostRecentFailureText: String = try SDSDeserialization.required(record.mostRecentFailureText, name: "mostRecentFailureText")
            let rapidFilesSerialized: Data? = record.rapidFiles
            let rapidFiles: [DTRapidFile] = try SDSDeserialization.unarchive(rapidFilesSerialized, name: "rapidFiles")
            let recipientStateMapSerialized: Data? = record.recipientStateMap
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]? = try SDSDeserialization.optionalUnarchive(recipientStateMapSerialized, name: "recipientStateMap")
            let sourceDeviceId: UInt32 = try SDSDeserialization.required(record.sourceDeviceId, name: "sourceDeviceId")
            guard let storedMessageState: TSOutgoingMessageState = record.storedMessageState else {
               throw SDSError.missingRequiredField
            }

            return DTHyperlinkOutgoingMessage(grdbId: recordId,
                                              uniqueId: uniqueId,
                                              associatedUniqueThreadId: associatedUniqueThreadId,
                                              notifySequenceId: notifySequenceId,
                                              receivedAtTimestamp: receivedAtTimestamp,
                                              sequenceId: sequenceId,
                                              serverTimestamp: serverTimestamp,
                                              timestamp: timestamp,
                                              uniqueThreadId: uniqueThreadId,
                                              atPersons: atPersons,
                                              attachmentIds: attachmentIds,
                                              body: body,
                                              card: card,
                                              cardUniqueId: cardUniqueId,
                                              cardVersion: cardVersion,
                                              combinedForwardingMessage: combinedForwardingMessage,
                                              contactShare: contactShare,
                                              editable: editable,
                                              envelopSource: envelopSource,
                                              expireStartedAt: expireStartedAt,
                                              expiresAt: expiresAt,
                                              expiresInSeconds: expiresInSeconds,
                                              isPinnedMessage: isPinnedMessage,
                                              mentions: mentions,
                                              messageModeType: messageModeType,
                                              pinId: pinId,
                                              quotedMessage: quotedMessage,
                                              reactionMap: reactionMap,
                                              reactionMessage: reactionMessage,
                                              recall: recall,
                                              storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                              translateMessage: translateMessage,
                                              whisperMessageType: whisperMessageType,
                                              customMessage: customMessage,
                                              groupChatMode: groupChatMode,
                                              groupMetaMessage: groupMetaMessage,
                                              hasSyncedTranscript: hasSyncedTranscript,
                                              isFromLinkedDevice: isFromLinkedDevice,
                                              isVoiceMessage: isVoiceMessage,
                                              mostRecentFailureText: mostRecentFailureText,
                                              rapidFiles: rapidFiles,
                                              recipientStateMap: recipientStateMap,
                                              sourceDeviceId: sourceDeviceId,
                                              storedMessageState: storedMessageState)

        case .dTOutgoingCallMessage:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }
            let customMessage: String = try SDSDeserialization.required(record.customMessage, name: "customMessage")
            guard let groupChatMode: TSGroupChatMode = record.groupChatMode else {
               throw SDSError.missingRequiredField
            }
            guard let groupMetaMessage: TSGroupMetaMessage = record.groupMetaMessage else {
               throw SDSError.missingRequiredField
            }
            let hasSyncedTranscript: Bool = try SDSDeserialization.required(record.hasSyncedTranscript, name: "hasSyncedTranscript")
            let isFromLinkedDevice: Bool = try SDSDeserialization.required(record.isFromLinkedDevice, name: "isFromLinkedDevice")
            let isVoiceMessage: Bool = try SDSDeserialization.required(record.isVoiceMessage, name: "isVoiceMessage")
            let mostRecentFailureText: String = try SDSDeserialization.required(record.mostRecentFailureText, name: "mostRecentFailureText")
            let rapidFilesSerialized: Data? = record.rapidFiles
            let rapidFiles: [DTRapidFile] = try SDSDeserialization.unarchive(rapidFilesSerialized, name: "rapidFiles")
            let recipientStateMapSerialized: Data? = record.recipientStateMap
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]? = try SDSDeserialization.optionalUnarchive(recipientStateMapSerialized, name: "recipientStateMap")
            let sourceDeviceId: UInt32 = try SDSDeserialization.required(record.sourceDeviceId, name: "sourceDeviceId")
            guard let storedMessageState: TSOutgoingMessageState = record.storedMessageState else {
               throw SDSError.missingRequiredField
            }

            return DTOutgoingCallMessage(grdbId: recordId,
                                         uniqueId: uniqueId,
                                         associatedUniqueThreadId: associatedUniqueThreadId,
                                         notifySequenceId: notifySequenceId,
                                         receivedAtTimestamp: receivedAtTimestamp,
                                         sequenceId: sequenceId,
                                         serverTimestamp: serverTimestamp,
                                         timestamp: timestamp,
                                         uniqueThreadId: uniqueThreadId,
                                         atPersons: atPersons,
                                         attachmentIds: attachmentIds,
                                         body: body,
                                         card: card,
                                         cardUniqueId: cardUniqueId,
                                         cardVersion: cardVersion,
                                         combinedForwardingMessage: combinedForwardingMessage,
                                         contactShare: contactShare,
                                         editable: editable,
                                         envelopSource: envelopSource,
                                         expireStartedAt: expireStartedAt,
                                         expiresAt: expiresAt,
                                         expiresInSeconds: expiresInSeconds,
                                         isPinnedMessage: isPinnedMessage,
                                         mentions: mentions,
                                         messageModeType: messageModeType,
                                         pinId: pinId,
                                         quotedMessage: quotedMessage,
                                         reactionMap: reactionMap,
                                         reactionMessage: reactionMessage,
                                         recall: recall,
                                         storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                         translateMessage: translateMessage,
                                         whisperMessageType: whisperMessageType,
                                         customMessage: customMessage,
                                         groupChatMode: groupChatMode,
                                         groupMetaMessage: groupMetaMessage,
                                         hasSyncedTranscript: hasSyncedTranscript,
                                         isFromLinkedDevice: isFromLinkedDevice,
                                         isVoiceMessage: isVoiceMessage,
                                         mostRecentFailureText: mostRecentFailureText,
                                         rapidFiles: rapidFiles,
                                         recipientStateMap: recipientStateMap,
                                         sourceDeviceId: sourceDeviceId,
                                         storedMessageState: storedMessageState)

        case .dTReactionOutgoingMessage:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }
            let customMessage: String = try SDSDeserialization.required(record.customMessage, name: "customMessage")
            guard let groupChatMode: TSGroupChatMode = record.groupChatMode else {
               throw SDSError.missingRequiredField
            }
            guard let groupMetaMessage: TSGroupMetaMessage = record.groupMetaMessage else {
               throw SDSError.missingRequiredField
            }
            let hasSyncedTranscript: Bool = try SDSDeserialization.required(record.hasSyncedTranscript, name: "hasSyncedTranscript")
            let isFromLinkedDevice: Bool = try SDSDeserialization.required(record.isFromLinkedDevice, name: "isFromLinkedDevice")
            let isVoiceMessage: Bool = try SDSDeserialization.required(record.isVoiceMessage, name: "isVoiceMessage")
            let mostRecentFailureText: String = try SDSDeserialization.required(record.mostRecentFailureText, name: "mostRecentFailureText")
            let rapidFilesSerialized: Data? = record.rapidFiles
            let rapidFiles: [DTRapidFile] = try SDSDeserialization.unarchive(rapidFilesSerialized, name: "rapidFiles")
            let recipientStateMapSerialized: Data? = record.recipientStateMap
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]? = try SDSDeserialization.optionalUnarchive(recipientStateMapSerialized, name: "recipientStateMap")
            let sourceDeviceId: UInt32 = try SDSDeserialization.required(record.sourceDeviceId, name: "sourceDeviceId")
            guard let storedMessageState: TSOutgoingMessageState = record.storedMessageState else {
               throw SDSError.missingRequiredField
            }

            return DTReactionOutgoingMessage(grdbId: recordId,
                                             uniqueId: uniqueId,
                                             associatedUniqueThreadId: associatedUniqueThreadId,
                                             notifySequenceId: notifySequenceId,
                                             receivedAtTimestamp: receivedAtTimestamp,
                                             sequenceId: sequenceId,
                                             serverTimestamp: serverTimestamp,
                                             timestamp: timestamp,
                                             uniqueThreadId: uniqueThreadId,
                                             atPersons: atPersons,
                                             attachmentIds: attachmentIds,
                                             body: body,
                                             card: card,
                                             cardUniqueId: cardUniqueId,
                                             cardVersion: cardVersion,
                                             combinedForwardingMessage: combinedForwardingMessage,
                                             contactShare: contactShare,
                                             editable: editable,
                                             envelopSource: envelopSource,
                                             expireStartedAt: expireStartedAt,
                                             expiresAt: expiresAt,
                                             expiresInSeconds: expiresInSeconds,
                                             isPinnedMessage: isPinnedMessage,
                                             mentions: mentions,
                                             messageModeType: messageModeType,
                                             pinId: pinId,
                                             quotedMessage: quotedMessage,
                                             reactionMap: reactionMap,
                                             reactionMessage: reactionMessage,
                                             recall: recall,
                                             storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                             translateMessage: translateMessage,
                                             whisperMessageType: whisperMessageType,
                                             customMessage: customMessage,
                                             groupChatMode: groupChatMode,
                                             groupMetaMessage: groupMetaMessage,
                                             hasSyncedTranscript: hasSyncedTranscript,
                                             isFromLinkedDevice: isFromLinkedDevice,
                                             isVoiceMessage: isVoiceMessage,
                                             mostRecentFailureText: mostRecentFailureText,
                                             rapidFiles: rapidFiles,
                                             recipientStateMap: recipientStateMap,
                                             sourceDeviceId: sourceDeviceId,
                                             storedMessageState: storedMessageState)

        case .disappearingConfigurationUpdateInfoMessage:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }
            let authorId: String = try SDSDeserialization.required(record.authorId, name: "authorId")
            let customAttributedMessageSerialized: Data? = record.customAttributedMessage
            let customAttributedMessage: NSAttributedString? = try SDSDeserialization.optionalUnarchive(customAttributedMessageSerialized, name: "customAttributedMessage")
            let customMessage: String? = record.customMessage
            let inviteCode: String = try SDSDeserialization.required(record.inviteCode, name: "inviteCode")
            let meetingDetailUrl: String? = record.meetingDetailUrl
            let meetingName: String? = record.meetingName
            guard let meetingReminderType: DTMeetingReminderType = record.meetingReminderType else {
               throw SDSError.missingRequiredField
            }
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let realSourceSerialized: Data? = record.realSource
            let realSource: DTRealSourceEntity? = try SDSDeserialization.optionalUnarchive(realSourceSerialized, name: "realSource")
            let recallPreview: String = try SDSDeserialization.required(record.recallPreview, name: "recallPreview")
            let shouldAffectThreadSorting: Bool = try SDSDeserialization.required(record.shouldAffectThreadSorting, name: "shouldAffectThreadSorting")
            let sourceDeviceId: UInt32 = try SDSDeserialization.required(record.sourceDeviceId, name: "sourceDeviceId")
            let unregisteredRecipientId: String? = record.unregisteredRecipientId
            let configurationDurationSeconds: UInt32 = try SDSDeserialization.required(record.configurationDurationSeconds, name: "configurationDurationSeconds")

            return OWSDisappearingConfigurationUpdateInfoMessage(grdbId: recordId,
                                                                 uniqueId: uniqueId,
                                                                 associatedUniqueThreadId: associatedUniqueThreadId,
                                                                 notifySequenceId: notifySequenceId,
                                                                 receivedAtTimestamp: receivedAtTimestamp,
                                                                 sequenceId: sequenceId,
                                                                 serverTimestamp: serverTimestamp,
                                                                 timestamp: timestamp,
                                                                 uniqueThreadId: uniqueThreadId,
                                                                 atPersons: atPersons,
                                                                 attachmentIds: attachmentIds,
                                                                 body: body,
                                                                 card: card,
                                                                 cardUniqueId: cardUniqueId,
                                                                 cardVersion: cardVersion,
                                                                 combinedForwardingMessage: combinedForwardingMessage,
                                                                 contactShare: contactShare,
                                                                 editable: editable,
                                                                 envelopSource: envelopSource,
                                                                 expireStartedAt: expireStartedAt,
                                                                 expiresAt: expiresAt,
                                                                 expiresInSeconds: expiresInSeconds,
                                                                 isPinnedMessage: isPinnedMessage,
                                                                 mentions: mentions,
                                                                 messageModeType: messageModeType,
                                                                 pinId: pinId,
                                                                 quotedMessage: quotedMessage,
                                                                 reactionMap: reactionMap,
                                                                 reactionMessage: reactionMessage,
                                                                 recall: recall,
                                                                 storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                                                 translateMessage: translateMessage,
                                                                 whisperMessageType: whisperMessageType,
                                                                 authorId: authorId,
                                                                 customAttributedMessage: customAttributedMessage,
                                                                 customMessage: customMessage,
                                                                 inviteCode: inviteCode,
                                                                 meetingDetailUrl: meetingDetailUrl,
                                                                 meetingName: meetingName,
                                                                 meetingReminderType: meetingReminderType,
                                                                 messageType: messageType,
                                                                 read: read,
                                                                 realSource: realSource,
                                                                 recallPreview: recallPreview,
                                                                 shouldAffectThreadSorting: shouldAffectThreadSorting,
                                                                 sourceDeviceId: sourceDeviceId,
                                                                 unregisteredRecipientId: unregisteredRecipientId,
                                                                 configurationDurationSeconds: configurationDurationSeconds)

        case .errorMessage:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }
            guard let errorType: TSErrorMessageType = record.errorType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let recipientId: String? = record.recipientId

            return TSErrorMessage(grdbId: recordId,
                                  uniqueId: uniqueId,
                                  associatedUniqueThreadId: associatedUniqueThreadId,
                                  notifySequenceId: notifySequenceId,
                                  receivedAtTimestamp: receivedAtTimestamp,
                                  sequenceId: sequenceId,
                                  serverTimestamp: serverTimestamp,
                                  timestamp: timestamp,
                                  uniqueThreadId: uniqueThreadId,
                                  atPersons: atPersons,
                                  attachmentIds: attachmentIds,
                                  body: body,
                                  card: card,
                                  cardUniqueId: cardUniqueId,
                                  cardVersion: cardVersion,
                                  combinedForwardingMessage: combinedForwardingMessage,
                                  contactShare: contactShare,
                                  editable: editable,
                                  envelopSource: envelopSource,
                                  expireStartedAt: expireStartedAt,
                                  expiresAt: expiresAt,
                                  expiresInSeconds: expiresInSeconds,
                                  isPinnedMessage: isPinnedMessage,
                                  mentions: mentions,
                                  messageModeType: messageModeType,
                                  pinId: pinId,
                                  quotedMessage: quotedMessage,
                                  reactionMap: reactionMap,
                                  reactionMessage: reactionMessage,
                                  recall: recall,
                                  storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                  translateMessage: translateMessage,
                                  whisperMessageType: whisperMessageType,
                                  errorType: errorType,
                                  read: read,
                                  recipientId: recipientId)

        case .incomingMessage:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }
            let authorId: String = try SDSDeserialization.required(record.authorId, name: "authorId")
            guard let mentionedMsgType: OWSMentionedMsgType = record.mentionedMsgType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let sourceDeviceId: UInt32 = try SDSDeserialization.required(record.sourceDeviceId, name: "sourceDeviceId")

            return TSIncomingMessage(grdbId: recordId,
                                     uniqueId: uniqueId,
                                     associatedUniqueThreadId: associatedUniqueThreadId,
                                     notifySequenceId: notifySequenceId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sequenceId: sequenceId,
                                     serverTimestamp: serverTimestamp,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     atPersons: atPersons,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     card: card,
                                     cardUniqueId: cardUniqueId,
                                     cardVersion: cardVersion,
                                     combinedForwardingMessage: combinedForwardingMessage,
                                     contactShare: contactShare,
                                     editable: editable,
                                     envelopSource: envelopSource,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     isPinnedMessage: isPinnedMessage,
                                     mentions: mentions,
                                     messageModeType: messageModeType,
                                     pinId: pinId,
                                     quotedMessage: quotedMessage,
                                     reactionMap: reactionMap,
                                     reactionMessage: reactionMessage,
                                     recall: recall,
                                     storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                     translateMessage: translateMessage,
                                     whisperMessageType: whisperMessageType,
                                     authorId: authorId,
                                     mentionedMsgType: mentionedMsgType,
                                     read: read,
                                     sourceDeviceId: sourceDeviceId)

        case .infoMessage:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }
            let authorId: String = try SDSDeserialization.required(record.authorId, name: "authorId")
            let customAttributedMessageSerialized: Data? = record.customAttributedMessage
            let customAttributedMessage: NSAttributedString? = try SDSDeserialization.optionalUnarchive(customAttributedMessageSerialized, name: "customAttributedMessage")
            let customMessage: String? = record.customMessage
            let inviteCode: String = try SDSDeserialization.required(record.inviteCode, name: "inviteCode")
            let meetingDetailUrl: String? = record.meetingDetailUrl
            let meetingName: String? = record.meetingName
            guard let meetingReminderType: DTMeetingReminderType = record.meetingReminderType else {
               throw SDSError.missingRequiredField
            }
            guard let messageType: TSInfoMessageType = record.messageType else {
               throw SDSError.missingRequiredField
            }
            let read: Bool = try SDSDeserialization.required(record.read, name: "read")
            let realSourceSerialized: Data? = record.realSource
            let realSource: DTRealSourceEntity? = try SDSDeserialization.optionalUnarchive(realSourceSerialized, name: "realSource")
            let recallPreview: String = try SDSDeserialization.required(record.recallPreview, name: "recallPreview")
            let shouldAffectThreadSorting: Bool = try SDSDeserialization.required(record.shouldAffectThreadSorting, name: "shouldAffectThreadSorting")
            let sourceDeviceId: UInt32 = try SDSDeserialization.required(record.sourceDeviceId, name: "sourceDeviceId")
            let unregisteredRecipientId: String? = record.unregisteredRecipientId

            return TSInfoMessage(grdbId: recordId,
                                 uniqueId: uniqueId,
                                 associatedUniqueThreadId: associatedUniqueThreadId,
                                 notifySequenceId: notifySequenceId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sequenceId: sequenceId,
                                 serverTimestamp: serverTimestamp,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId,
                                 atPersons: atPersons,
                                 attachmentIds: attachmentIds,
                                 body: body,
                                 card: card,
                                 cardUniqueId: cardUniqueId,
                                 cardVersion: cardVersion,
                                 combinedForwardingMessage: combinedForwardingMessage,
                                 contactShare: contactShare,
                                 editable: editable,
                                 envelopSource: envelopSource,
                                 expireStartedAt: expireStartedAt,
                                 expiresAt: expiresAt,
                                 expiresInSeconds: expiresInSeconds,
                                 isPinnedMessage: isPinnedMessage,
                                 mentions: mentions,
                                 messageModeType: messageModeType,
                                 pinId: pinId,
                                 quotedMessage: quotedMessage,
                                 reactionMap: reactionMap,
                                 reactionMessage: reactionMessage,
                                 recall: recall,
                                 storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                 translateMessage: translateMessage,
                                 whisperMessageType: whisperMessageType,
                                 authorId: authorId,
                                 customAttributedMessage: customAttributedMessage,
                                 customMessage: customMessage,
                                 inviteCode: inviteCode,
                                 meetingDetailUrl: meetingDetailUrl,
                                 meetingName: meetingName,
                                 meetingReminderType: meetingReminderType,
                                 messageType: messageType,
                                 read: read,
                                 realSource: realSource,
                                 recallPreview: recallPreview,
                                 shouldAffectThreadSorting: shouldAffectThreadSorting,
                                 sourceDeviceId: sourceDeviceId,
                                 unregisteredRecipientId: unregisteredRecipientId)

        case .interaction:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId

            return TSInteraction(grdbId: recordId,
                                 uniqueId: uniqueId,
                                 associatedUniqueThreadId: associatedUniqueThreadId,
                                 notifySequenceId: notifySequenceId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sequenceId: sequenceId,
                                 serverTimestamp: serverTimestamp,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId)

        case .message:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }

            return TSMessage(grdbId: recordId,
                             uniqueId: uniqueId,
                             associatedUniqueThreadId: associatedUniqueThreadId,
                             notifySequenceId: notifySequenceId,
                             receivedAtTimestamp: receivedAtTimestamp,
                             sequenceId: sequenceId,
                             serverTimestamp: serverTimestamp,
                             timestamp: timestamp,
                             uniqueThreadId: uniqueThreadId,
                             atPersons: atPersons,
                             attachmentIds: attachmentIds,
                             body: body,
                             card: card,
                             cardUniqueId: cardUniqueId,
                             cardVersion: cardVersion,
                             combinedForwardingMessage: combinedForwardingMessage,
                             contactShare: contactShare,
                             editable: editable,
                             envelopSource: envelopSource,
                             expireStartedAt: expireStartedAt,
                             expiresAt: expiresAt,
                             expiresInSeconds: expiresInSeconds,
                             isPinnedMessage: isPinnedMessage,
                             mentions: mentions,
                             messageModeType: messageModeType,
                             pinId: pinId,
                             quotedMessage: quotedMessage,
                             reactionMap: reactionMap,
                             reactionMessage: reactionMessage,
                             recall: recall,
                             storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                             translateMessage: translateMessage,
                             whisperMessageType: whisperMessageType)

        case .outgoingMessage:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId
            let atPersons: String? = record.atPersons
            let attachmentIdsSerialized: Data? = record.attachmentIds
            let attachmentIds: [String] = try SDSDeserialization.unarchive(attachmentIdsSerialized, name: "attachmentIds")
            let body: String? = record.body
            let cardSerialized: Data? = record.card
            let card: DTCardMessageEntity? = try SDSDeserialization.optionalUnarchive(cardSerialized, name: "card")
            let cardUniqueId: String? = record.cardUniqueId
            let cardVersion: UInt32 = try SDSDeserialization.required(record.cardVersion, name: "cardVersion")
            let combinedForwardingMessageSerialized: Data? = record.combinedForwardingMessage
            let combinedForwardingMessage: DTCombinedForwardingMessage? = try SDSDeserialization.optionalUnarchive(combinedForwardingMessageSerialized, name: "combinedForwardingMessage")
            let contactShareSerialized: Data? = record.contactShare
            let contactShare: OWSContact? = try SDSDeserialization.optionalUnarchive(contactShareSerialized, name: "contactShare")
            let editable: Bool = try SDSDeserialization.required(record.editable, name: "editable")
            let envelopSource: String? = record.envelopSource
            let expireStartedAt: UInt64 = try SDSDeserialization.required(record.expireStartedAt, name: "expireStartedAt")
            let expiresAt: UInt64 = try SDSDeserialization.required(record.expiresAt, name: "expiresAt")
            let expiresInSeconds: UInt32 = try SDSDeserialization.required(record.expiresInSeconds, name: "expiresInSeconds")
            let isPinnedMessage: Bool = try SDSDeserialization.required(record.isPinnedMessage, name: "isPinnedMessage")
            let mentionsSerialized: Data? = record.mentions
            let mentions: [DTMention]? = try SDSDeserialization.optionalUnarchive(mentionsSerialized, name: "mentions")
            guard let messageModeType: TSMessageModeType = record.messageModeType else {
               throw SDSError.missingRequiredField
            }
            let pinId: String? = record.pinId
            let quotedMessageSerialized: Data? = record.quotedMessage
            let quotedMessage: TSQuotedMessage? = try SDSDeserialization.optionalUnarchive(quotedMessageSerialized, name: "quotedMessage")
            let reactionMapSerialized: Data? = record.reactionMap
            let reactionMap: [String: [DTReactionSource]]? = try SDSDeserialization.optionalUnarchive(reactionMapSerialized, name: "reactionMap")
            let reactionMessageSerialized: Data? = record.reactionMessage
            let reactionMessage: DTReactionMessage? = try SDSDeserialization.optionalUnarchive(reactionMessageSerialized, name: "reactionMessage")
            let recallSerialized: Data? = record.recall
            let recall: DTRecallMessage? = try SDSDeserialization.optionalUnarchive(recallSerialized, name: "recall")
            let storedShouldStartExpireTimer: Bool = try SDSDeserialization.required(record.storedShouldStartExpireTimer, name: "storedShouldStartExpireTimer")
            let translateMessageSerialized: Data? = record.translateMessage
            let translateMessage: DTTranslateMessage? = try SDSDeserialization.optionalUnarchive(translateMessageSerialized, name: "translateMessage")
            guard let whisperMessageType: TSWhisperMessageType = record.whisperMessageType else {
               throw SDSError.missingRequiredField
            }
            let customMessage: String = try SDSDeserialization.required(record.customMessage, name: "customMessage")
            guard let groupChatMode: TSGroupChatMode = record.groupChatMode else {
               throw SDSError.missingRequiredField
            }
            guard let groupMetaMessage: TSGroupMetaMessage = record.groupMetaMessage else {
               throw SDSError.missingRequiredField
            }
            let hasSyncedTranscript: Bool = try SDSDeserialization.required(record.hasSyncedTranscript, name: "hasSyncedTranscript")
            let isFromLinkedDevice: Bool = try SDSDeserialization.required(record.isFromLinkedDevice, name: "isFromLinkedDevice")
            let isVoiceMessage: Bool = try SDSDeserialization.required(record.isVoiceMessage, name: "isVoiceMessage")
            let mostRecentFailureText: String = try SDSDeserialization.required(record.mostRecentFailureText, name: "mostRecentFailureText")
            let rapidFilesSerialized: Data? = record.rapidFiles
            let rapidFiles: [DTRapidFile] = try SDSDeserialization.unarchive(rapidFilesSerialized, name: "rapidFiles")
            let recipientStateMapSerialized: Data? = record.recipientStateMap
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]? = try SDSDeserialization.optionalUnarchive(recipientStateMapSerialized, name: "recipientStateMap")
            let sourceDeviceId: UInt32 = try SDSDeserialization.required(record.sourceDeviceId, name: "sourceDeviceId")
            guard let storedMessageState: TSOutgoingMessageState = record.storedMessageState else {
               throw SDSError.missingRequiredField
            }

            return TSOutgoingMessage(grdbId: recordId,
                                     uniqueId: uniqueId,
                                     associatedUniqueThreadId: associatedUniqueThreadId,
                                     notifySequenceId: notifySequenceId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sequenceId: sequenceId,
                                     serverTimestamp: serverTimestamp,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     atPersons: atPersons,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     card: card,
                                     cardUniqueId: cardUniqueId,
                                     cardVersion: cardVersion,
                                     combinedForwardingMessage: combinedForwardingMessage,
                                     contactShare: contactShare,
                                     editable: editable,
                                     envelopSource: envelopSource,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     isPinnedMessage: isPinnedMessage,
                                     mentions: mentions,
                                     messageModeType: messageModeType,
                                     pinId: pinId,
                                     quotedMessage: quotedMessage,
                                     reactionMap: reactionMap,
                                     reactionMessage: reactionMessage,
                                     recall: recall,
                                     storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                     translateMessage: translateMessage,
                                     whisperMessageType: whisperMessageType,
                                     customMessage: customMessage,
                                     groupChatMode: groupChatMode,
                                     groupMetaMessage: groupMetaMessage,
                                     hasSyncedTranscript: hasSyncedTranscript,
                                     isFromLinkedDevice: isFromLinkedDevice,
                                     isVoiceMessage: isVoiceMessage,
                                     mostRecentFailureText: mostRecentFailureText,
                                     rapidFiles: rapidFiles,
                                     recipientStateMap: recipientStateMap,
                                     sourceDeviceId: sourceDeviceId,
                                     storedMessageState: storedMessageState)

        case .unreadIndicatorInteraction:

            let uniqueId: String = record.uniqueId
            let associatedUniqueThreadId: String = record.associatedUniqueThreadId
            let notifySequenceId: UInt64 = record.notifySequenceId
            let receivedAtTimestamp: UInt64 = record.receivedAtTimestamp
            let sequenceId: UInt64 = record.sequenceId
            let serverTimestamp: UInt64 = record.serverTimestamp
            let timestamp: UInt64 = record.timestamp
            let uniqueThreadId: String = record.threadUniqueId

            return TSUnreadIndicatorInteraction(grdbId: recordId,
                                                uniqueId: uniqueId,
                                                associatedUniqueThreadId: associatedUniqueThreadId,
                                                notifySequenceId: notifySequenceId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sequenceId: sequenceId,
                                                serverTimestamp: serverTimestamp,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId)

        default:
            owsFailDebug("Unexpected record type: \(record.recordType)")
            throw SDSError.invalidValue
        }
    }
}

// MARK: - SDSModel

extension TSInteraction: SDSModel {
    public var serializer: SDSSerializer {
        // Any subclass can be cast to it's superclass,
        // so the order of this switch statement matters.
        // We need to do a "depth first" search by type.
        switch self {
        case let model as TSUnreadIndicatorInteraction:
            assert(type(of: model) == TSUnreadIndicatorInteraction.self)
            return TSUnreadIndicatorInteractionSerializer(model: model)
        case let model as DTReactionOutgoingMessage:
            assert(type(of: model) == DTReactionOutgoingMessage.self)
            return DTReactionOutgoingMessageSerializer(model: model)
        case let model as DTOutgoingCallMessage:
            assert(type(of: model) == DTOutgoingCallMessage.self)
            return DTOutgoingCallMessageSerializer(model: model)
        case let model as DTHyperlinkOutgoingMessage:
            assert(type(of: model) == DTHyperlinkOutgoingMessage.self)
            return DTHyperlinkOutgoingMessageSerializer(model: model)
        case let model as DTCardOutgoingMessage:
            assert(type(of: model) == DTCardOutgoingMessage.self)
            return DTCardOutgoingMessageSerializer(model: model)
        case let model as TSOutgoingMessage:
            assert(type(of: model) == TSOutgoingMessage.self)
            return TSOutgoingMessageSerializer(model: model)
        case let model as OWSDisappearingConfigurationUpdateInfoMessage:
            assert(type(of: model) == OWSDisappearingConfigurationUpdateInfoMessage.self)
            return OWSDisappearingConfigurationUpdateInfoMessageSerializer(model: model)
        case let model as TSInfoMessage:
            assert(type(of: model) == TSInfoMessage.self)
            return TSInfoMessageSerializer(model: model)
        case let model as TSIncomingMessage:
            assert(type(of: model) == TSIncomingMessage.self)
            return TSIncomingMessageSerializer(model: model)
        case let model as TSErrorMessage:
            assert(type(of: model) == TSErrorMessage.self)
            return TSErrorMessageSerializer(model: model)
        case let model as TSMessage:
            assert(type(of: model) == TSMessage.self)
            return TSMessageSerializer(model: model)
        default:
            return TSInteractionSerializer(model: self)
        }
    }

    public func asRecord() throws -> SDSRecord {
        try serializer.asRecord()
    }

    public var sdsTableName: String {
        InteractionRecord.databaseTableName
    }

    public static var table: SDSTableMetadata {
        TSInteractionSerializer.table
    }
}

// MARK: - DeepCopyable

extension TSInteraction: DeepCopyable {

    public func deepCopy() throws -> AnyObject {
        // Any subclass can be cast to it's superclass,
        // so the order of this switch statement matters.
        // We need to do a "depth first" search by type.
        guard let id = self.grdbId?.int64Value else {
            throw OWSAssertionError("Model missing grdbId.")
        }

        if let modelToCopy = self as? TSUnreadIndicatorInteraction {
            assert(type(of: modelToCopy) == TSUnreadIndicatorInteraction.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId

            return TSUnreadIndicatorInteraction(grdbId: id,
                                                uniqueId: uniqueId,
                                                associatedUniqueThreadId: associatedUniqueThreadId,
                                                notifySequenceId: notifySequenceId,
                                                receivedAtTimestamp: receivedAtTimestamp,
                                                sequenceId: sequenceId,
                                                serverTimestamp: serverTimestamp,
                                                timestamp: timestamp,
                                                uniqueThreadId: uniqueThreadId)
        }

        if let modelToCopy = self as? DTReactionOutgoingMessage {
            assert(type(of: modelToCopy) == DTReactionOutgoingMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType
            let customMessage: String = modelToCopy.customMessage
            let groupChatMode: TSGroupChatMode = modelToCopy.groupChatMode
            let groupMetaMessage: TSGroupMetaMessage = modelToCopy.groupMetaMessage
            let hasSyncedTranscript: Bool = modelToCopy.hasSyncedTranscript
            let isFromLinkedDevice: Bool = modelToCopy.isFromLinkedDevice
            let isVoiceMessage: Bool = modelToCopy.isVoiceMessage
            let mostRecentFailureText: String = modelToCopy.mostRecentFailureText
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let rapidFiles: [DTRapidFile] = try DeepCopies.deepCopy(modelToCopy.rapidFiles)
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]?
            if let recipientStateMapForCopy = modelToCopy.recipientStateMap {
               recipientStateMap = try DeepCopies.deepCopy(recipientStateMapForCopy)
            } else {
               recipientStateMap = nil
            }
            let sourceDeviceId: UInt32 = modelToCopy.sourceDeviceId
            let storedMessageState: TSOutgoingMessageState = modelToCopy.storedMessageState

            return DTReactionOutgoingMessage(grdbId: id,
                                             uniqueId: uniqueId,
                                             associatedUniqueThreadId: associatedUniqueThreadId,
                                             notifySequenceId: notifySequenceId,
                                             receivedAtTimestamp: receivedAtTimestamp,
                                             sequenceId: sequenceId,
                                             serverTimestamp: serverTimestamp,
                                             timestamp: timestamp,
                                             uniqueThreadId: uniqueThreadId,
                                             atPersons: atPersons,
                                             attachmentIds: attachmentIds,
                                             body: body,
                                             card: card,
                                             cardUniqueId: cardUniqueId,
                                             cardVersion: cardVersion,
                                             combinedForwardingMessage: combinedForwardingMessage,
                                             contactShare: contactShare,
                                             editable: editable,
                                             envelopSource: envelopSource,
                                             expireStartedAt: expireStartedAt,
                                             expiresAt: expiresAt,
                                             expiresInSeconds: expiresInSeconds,
                                             isPinnedMessage: isPinnedMessage,
                                             mentions: mentions,
                                             messageModeType: messageModeType,
                                             pinId: pinId,
                                             quotedMessage: quotedMessage,
                                             reactionMap: reactionMap,
                                             reactionMessage: reactionMessage,
                                             recall: recall,
                                             storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                             translateMessage: translateMessage,
                                             whisperMessageType: whisperMessageType,
                                             customMessage: customMessage,
                                             groupChatMode: groupChatMode,
                                             groupMetaMessage: groupMetaMessage,
                                             hasSyncedTranscript: hasSyncedTranscript,
                                             isFromLinkedDevice: isFromLinkedDevice,
                                             isVoiceMessage: isVoiceMessage,
                                             mostRecentFailureText: mostRecentFailureText,
                                             rapidFiles: rapidFiles,
                                             recipientStateMap: recipientStateMap,
                                             sourceDeviceId: sourceDeviceId,
                                             storedMessageState: storedMessageState)
        }

        if let modelToCopy = self as? DTOutgoingCallMessage {
            assert(type(of: modelToCopy) == DTOutgoingCallMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType
            let customMessage: String = modelToCopy.customMessage
            let groupChatMode: TSGroupChatMode = modelToCopy.groupChatMode
            let groupMetaMessage: TSGroupMetaMessage = modelToCopy.groupMetaMessage
            let hasSyncedTranscript: Bool = modelToCopy.hasSyncedTranscript
            let isFromLinkedDevice: Bool = modelToCopy.isFromLinkedDevice
            let isVoiceMessage: Bool = modelToCopy.isVoiceMessage
            let mostRecentFailureText: String = modelToCopy.mostRecentFailureText
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let rapidFiles: [DTRapidFile] = try DeepCopies.deepCopy(modelToCopy.rapidFiles)
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]?
            if let recipientStateMapForCopy = modelToCopy.recipientStateMap {
               recipientStateMap = try DeepCopies.deepCopy(recipientStateMapForCopy)
            } else {
               recipientStateMap = nil
            }
            let sourceDeviceId: UInt32 = modelToCopy.sourceDeviceId
            let storedMessageState: TSOutgoingMessageState = modelToCopy.storedMessageState

            return DTOutgoingCallMessage(grdbId: id,
                                         uniqueId: uniqueId,
                                         associatedUniqueThreadId: associatedUniqueThreadId,
                                         notifySequenceId: notifySequenceId,
                                         receivedAtTimestamp: receivedAtTimestamp,
                                         sequenceId: sequenceId,
                                         serverTimestamp: serverTimestamp,
                                         timestamp: timestamp,
                                         uniqueThreadId: uniqueThreadId,
                                         atPersons: atPersons,
                                         attachmentIds: attachmentIds,
                                         body: body,
                                         card: card,
                                         cardUniqueId: cardUniqueId,
                                         cardVersion: cardVersion,
                                         combinedForwardingMessage: combinedForwardingMessage,
                                         contactShare: contactShare,
                                         editable: editable,
                                         envelopSource: envelopSource,
                                         expireStartedAt: expireStartedAt,
                                         expiresAt: expiresAt,
                                         expiresInSeconds: expiresInSeconds,
                                         isPinnedMessage: isPinnedMessage,
                                         mentions: mentions,
                                         messageModeType: messageModeType,
                                         pinId: pinId,
                                         quotedMessage: quotedMessage,
                                         reactionMap: reactionMap,
                                         reactionMessage: reactionMessage,
                                         recall: recall,
                                         storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                         translateMessage: translateMessage,
                                         whisperMessageType: whisperMessageType,
                                         customMessage: customMessage,
                                         groupChatMode: groupChatMode,
                                         groupMetaMessage: groupMetaMessage,
                                         hasSyncedTranscript: hasSyncedTranscript,
                                         isFromLinkedDevice: isFromLinkedDevice,
                                         isVoiceMessage: isVoiceMessage,
                                         mostRecentFailureText: mostRecentFailureText,
                                         rapidFiles: rapidFiles,
                                         recipientStateMap: recipientStateMap,
                                         sourceDeviceId: sourceDeviceId,
                                         storedMessageState: storedMessageState)
        }

        if let modelToCopy = self as? DTHyperlinkOutgoingMessage {
            assert(type(of: modelToCopy) == DTHyperlinkOutgoingMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType
            let customMessage: String = modelToCopy.customMessage
            let groupChatMode: TSGroupChatMode = modelToCopy.groupChatMode
            let groupMetaMessage: TSGroupMetaMessage = modelToCopy.groupMetaMessage
            let hasSyncedTranscript: Bool = modelToCopy.hasSyncedTranscript
            let isFromLinkedDevice: Bool = modelToCopy.isFromLinkedDevice
            let isVoiceMessage: Bool = modelToCopy.isVoiceMessage
            let mostRecentFailureText: String = modelToCopy.mostRecentFailureText
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let rapidFiles: [DTRapidFile] = try DeepCopies.deepCopy(modelToCopy.rapidFiles)
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]?
            if let recipientStateMapForCopy = modelToCopy.recipientStateMap {
               recipientStateMap = try DeepCopies.deepCopy(recipientStateMapForCopy)
            } else {
               recipientStateMap = nil
            }
            let sourceDeviceId: UInt32 = modelToCopy.sourceDeviceId
            let storedMessageState: TSOutgoingMessageState = modelToCopy.storedMessageState

            return DTHyperlinkOutgoingMessage(grdbId: id,
                                              uniqueId: uniqueId,
                                              associatedUniqueThreadId: associatedUniqueThreadId,
                                              notifySequenceId: notifySequenceId,
                                              receivedAtTimestamp: receivedAtTimestamp,
                                              sequenceId: sequenceId,
                                              serverTimestamp: serverTimestamp,
                                              timestamp: timestamp,
                                              uniqueThreadId: uniqueThreadId,
                                              atPersons: atPersons,
                                              attachmentIds: attachmentIds,
                                              body: body,
                                              card: card,
                                              cardUniqueId: cardUniqueId,
                                              cardVersion: cardVersion,
                                              combinedForwardingMessage: combinedForwardingMessage,
                                              contactShare: contactShare,
                                              editable: editable,
                                              envelopSource: envelopSource,
                                              expireStartedAt: expireStartedAt,
                                              expiresAt: expiresAt,
                                              expiresInSeconds: expiresInSeconds,
                                              isPinnedMessage: isPinnedMessage,
                                              mentions: mentions,
                                              messageModeType: messageModeType,
                                              pinId: pinId,
                                              quotedMessage: quotedMessage,
                                              reactionMap: reactionMap,
                                              reactionMessage: reactionMessage,
                                              recall: recall,
                                              storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                              translateMessage: translateMessage,
                                              whisperMessageType: whisperMessageType,
                                              customMessage: customMessage,
                                              groupChatMode: groupChatMode,
                                              groupMetaMessage: groupMetaMessage,
                                              hasSyncedTranscript: hasSyncedTranscript,
                                              isFromLinkedDevice: isFromLinkedDevice,
                                              isVoiceMessage: isVoiceMessage,
                                              mostRecentFailureText: mostRecentFailureText,
                                              rapidFiles: rapidFiles,
                                              recipientStateMap: recipientStateMap,
                                              sourceDeviceId: sourceDeviceId,
                                              storedMessageState: storedMessageState)
        }

        if let modelToCopy = self as? DTCardOutgoingMessage {
            assert(type(of: modelToCopy) == DTCardOutgoingMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType
            let customMessage: String = modelToCopy.customMessage
            let groupChatMode: TSGroupChatMode = modelToCopy.groupChatMode
            let groupMetaMessage: TSGroupMetaMessage = modelToCopy.groupMetaMessage
            let hasSyncedTranscript: Bool = modelToCopy.hasSyncedTranscript
            let isFromLinkedDevice: Bool = modelToCopy.isFromLinkedDevice
            let isVoiceMessage: Bool = modelToCopy.isVoiceMessage
            let mostRecentFailureText: String = modelToCopy.mostRecentFailureText
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let rapidFiles: [DTRapidFile] = try DeepCopies.deepCopy(modelToCopy.rapidFiles)
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]?
            if let recipientStateMapForCopy = modelToCopy.recipientStateMap {
               recipientStateMap = try DeepCopies.deepCopy(recipientStateMapForCopy)
            } else {
               recipientStateMap = nil
            }
            let sourceDeviceId: UInt32 = modelToCopy.sourceDeviceId
            let storedMessageState: TSOutgoingMessageState = modelToCopy.storedMessageState

            return DTCardOutgoingMessage(grdbId: id,
                                         uniqueId: uniqueId,
                                         associatedUniqueThreadId: associatedUniqueThreadId,
                                         notifySequenceId: notifySequenceId,
                                         receivedAtTimestamp: receivedAtTimestamp,
                                         sequenceId: sequenceId,
                                         serverTimestamp: serverTimestamp,
                                         timestamp: timestamp,
                                         uniqueThreadId: uniqueThreadId,
                                         atPersons: atPersons,
                                         attachmentIds: attachmentIds,
                                         body: body,
                                         card: card,
                                         cardUniqueId: cardUniqueId,
                                         cardVersion: cardVersion,
                                         combinedForwardingMessage: combinedForwardingMessage,
                                         contactShare: contactShare,
                                         editable: editable,
                                         envelopSource: envelopSource,
                                         expireStartedAt: expireStartedAt,
                                         expiresAt: expiresAt,
                                         expiresInSeconds: expiresInSeconds,
                                         isPinnedMessage: isPinnedMessage,
                                         mentions: mentions,
                                         messageModeType: messageModeType,
                                         pinId: pinId,
                                         quotedMessage: quotedMessage,
                                         reactionMap: reactionMap,
                                         reactionMessage: reactionMessage,
                                         recall: recall,
                                         storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                         translateMessage: translateMessage,
                                         whisperMessageType: whisperMessageType,
                                         customMessage: customMessage,
                                         groupChatMode: groupChatMode,
                                         groupMetaMessage: groupMetaMessage,
                                         hasSyncedTranscript: hasSyncedTranscript,
                                         isFromLinkedDevice: isFromLinkedDevice,
                                         isVoiceMessage: isVoiceMessage,
                                         mostRecentFailureText: mostRecentFailureText,
                                         rapidFiles: rapidFiles,
                                         recipientStateMap: recipientStateMap,
                                         sourceDeviceId: sourceDeviceId,
                                         storedMessageState: storedMessageState)
        }

        if let modelToCopy = self as? TSOutgoingMessage {
            assert(type(of: modelToCopy) == TSOutgoingMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType
            let customMessage: String = modelToCopy.customMessage
            let groupChatMode: TSGroupChatMode = modelToCopy.groupChatMode
            let groupMetaMessage: TSGroupMetaMessage = modelToCopy.groupMetaMessage
            let hasSyncedTranscript: Bool = modelToCopy.hasSyncedTranscript
            let isFromLinkedDevice: Bool = modelToCopy.isFromLinkedDevice
            let isVoiceMessage: Bool = modelToCopy.isVoiceMessage
            let mostRecentFailureText: String = modelToCopy.mostRecentFailureText
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let rapidFiles: [DTRapidFile] = try DeepCopies.deepCopy(modelToCopy.rapidFiles)
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recipientStateMap: [String: TSOutgoingMessageRecipientState]?
            if let recipientStateMapForCopy = modelToCopy.recipientStateMap {
               recipientStateMap = try DeepCopies.deepCopy(recipientStateMapForCopy)
            } else {
               recipientStateMap = nil
            }
            let sourceDeviceId: UInt32 = modelToCopy.sourceDeviceId
            let storedMessageState: TSOutgoingMessageState = modelToCopy.storedMessageState

            return TSOutgoingMessage(grdbId: id,
                                     uniqueId: uniqueId,
                                     associatedUniqueThreadId: associatedUniqueThreadId,
                                     notifySequenceId: notifySequenceId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sequenceId: sequenceId,
                                     serverTimestamp: serverTimestamp,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     atPersons: atPersons,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     card: card,
                                     cardUniqueId: cardUniqueId,
                                     cardVersion: cardVersion,
                                     combinedForwardingMessage: combinedForwardingMessage,
                                     contactShare: contactShare,
                                     editable: editable,
                                     envelopSource: envelopSource,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     isPinnedMessage: isPinnedMessage,
                                     mentions: mentions,
                                     messageModeType: messageModeType,
                                     pinId: pinId,
                                     quotedMessage: quotedMessage,
                                     reactionMap: reactionMap,
                                     reactionMessage: reactionMessage,
                                     recall: recall,
                                     storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                     translateMessage: translateMessage,
                                     whisperMessageType: whisperMessageType,
                                     customMessage: customMessage,
                                     groupChatMode: groupChatMode,
                                     groupMetaMessage: groupMetaMessage,
                                     hasSyncedTranscript: hasSyncedTranscript,
                                     isFromLinkedDevice: isFromLinkedDevice,
                                     isVoiceMessage: isVoiceMessage,
                                     mostRecentFailureText: mostRecentFailureText,
                                     rapidFiles: rapidFiles,
                                     recipientStateMap: recipientStateMap,
                                     sourceDeviceId: sourceDeviceId,
                                     storedMessageState: storedMessageState)
        }

        if let modelToCopy = self as? OWSDisappearingConfigurationUpdateInfoMessage {
            assert(type(of: modelToCopy) == OWSDisappearingConfigurationUpdateInfoMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType
            let authorId: String = modelToCopy.authorId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let customAttributedMessage: NSAttributedString?
            if let customAttributedMessageForCopy = modelToCopy.customAttributedMessage {
               customAttributedMessage = try DeepCopies.deepCopy(customAttributedMessageForCopy)
            } else {
               customAttributedMessage = nil
            }
            let customMessage: String? = modelToCopy.customMessage
            let inviteCode: String = modelToCopy.inviteCode
            let meetingDetailUrl: String? = modelToCopy.meetingDetailUrl
            let meetingName: String? = modelToCopy.meetingName
            let meetingReminderType: DTMeetingReminderType = modelToCopy.meetingReminderType
            let messageType: TSInfoMessageType = modelToCopy.messageType
            let read: Bool = modelToCopy.wasRead
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let realSource: DTRealSourceEntity?
            if let realSourceForCopy = modelToCopy.realSource {
               realSource = try DeepCopies.deepCopy(realSourceForCopy)
            } else {
               realSource = nil
            }
            let recallPreview: String = modelToCopy.recallPreview
            let shouldAffectThreadSorting: Bool = modelToCopy.isShouldAffectThreadSorting
            let sourceDeviceId: UInt32 = modelToCopy.sourceDeviceId
            let unregisteredRecipientId: String? = modelToCopy.unregisteredRecipientId
            let configurationDurationSeconds: UInt32 = modelToCopy.configurationDurationSeconds

            return OWSDisappearingConfigurationUpdateInfoMessage(grdbId: id,
                                                                 uniqueId: uniqueId,
                                                                 associatedUniqueThreadId: associatedUniqueThreadId,
                                                                 notifySequenceId: notifySequenceId,
                                                                 receivedAtTimestamp: receivedAtTimestamp,
                                                                 sequenceId: sequenceId,
                                                                 serverTimestamp: serverTimestamp,
                                                                 timestamp: timestamp,
                                                                 uniqueThreadId: uniqueThreadId,
                                                                 atPersons: atPersons,
                                                                 attachmentIds: attachmentIds,
                                                                 body: body,
                                                                 card: card,
                                                                 cardUniqueId: cardUniqueId,
                                                                 cardVersion: cardVersion,
                                                                 combinedForwardingMessage: combinedForwardingMessage,
                                                                 contactShare: contactShare,
                                                                 editable: editable,
                                                                 envelopSource: envelopSource,
                                                                 expireStartedAt: expireStartedAt,
                                                                 expiresAt: expiresAt,
                                                                 expiresInSeconds: expiresInSeconds,
                                                                 isPinnedMessage: isPinnedMessage,
                                                                 mentions: mentions,
                                                                 messageModeType: messageModeType,
                                                                 pinId: pinId,
                                                                 quotedMessage: quotedMessage,
                                                                 reactionMap: reactionMap,
                                                                 reactionMessage: reactionMessage,
                                                                 recall: recall,
                                                                 storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                                                 translateMessage: translateMessage,
                                                                 whisperMessageType: whisperMessageType,
                                                                 authorId: authorId,
                                                                 customAttributedMessage: customAttributedMessage,
                                                                 customMessage: customMessage,
                                                                 inviteCode: inviteCode,
                                                                 meetingDetailUrl: meetingDetailUrl,
                                                                 meetingName: meetingName,
                                                                 meetingReminderType: meetingReminderType,
                                                                 messageType: messageType,
                                                                 read: read,
                                                                 realSource: realSource,
                                                                 recallPreview: recallPreview,
                                                                 shouldAffectThreadSorting: shouldAffectThreadSorting,
                                                                 sourceDeviceId: sourceDeviceId,
                                                                 unregisteredRecipientId: unregisteredRecipientId,
                                                                 configurationDurationSeconds: configurationDurationSeconds)
        }

        if let modelToCopy = self as? TSInfoMessage {
            assert(type(of: modelToCopy) == TSInfoMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType
            let authorId: String = modelToCopy.authorId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let customAttributedMessage: NSAttributedString?
            if let customAttributedMessageForCopy = modelToCopy.customAttributedMessage {
               customAttributedMessage = try DeepCopies.deepCopy(customAttributedMessageForCopy)
            } else {
               customAttributedMessage = nil
            }
            let customMessage: String? = modelToCopy.customMessage
            let inviteCode: String = modelToCopy.inviteCode
            let meetingDetailUrl: String? = modelToCopy.meetingDetailUrl
            let meetingName: String? = modelToCopy.meetingName
            let meetingReminderType: DTMeetingReminderType = modelToCopy.meetingReminderType
            let messageType: TSInfoMessageType = modelToCopy.messageType
            let read: Bool = modelToCopy.wasRead
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let realSource: DTRealSourceEntity?
            if let realSourceForCopy = modelToCopy.realSource {
               realSource = try DeepCopies.deepCopy(realSourceForCopy)
            } else {
               realSource = nil
            }
            let recallPreview: String = modelToCopy.recallPreview
            let shouldAffectThreadSorting: Bool = modelToCopy.isShouldAffectThreadSorting
            let sourceDeviceId: UInt32 = modelToCopy.sourceDeviceId
            let unregisteredRecipientId: String? = modelToCopy.unregisteredRecipientId

            return TSInfoMessage(grdbId: id,
                                 uniqueId: uniqueId,
                                 associatedUniqueThreadId: associatedUniqueThreadId,
                                 notifySequenceId: notifySequenceId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sequenceId: sequenceId,
                                 serverTimestamp: serverTimestamp,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId,
                                 atPersons: atPersons,
                                 attachmentIds: attachmentIds,
                                 body: body,
                                 card: card,
                                 cardUniqueId: cardUniqueId,
                                 cardVersion: cardVersion,
                                 combinedForwardingMessage: combinedForwardingMessage,
                                 contactShare: contactShare,
                                 editable: editable,
                                 envelopSource: envelopSource,
                                 expireStartedAt: expireStartedAt,
                                 expiresAt: expiresAt,
                                 expiresInSeconds: expiresInSeconds,
                                 isPinnedMessage: isPinnedMessage,
                                 mentions: mentions,
                                 messageModeType: messageModeType,
                                 pinId: pinId,
                                 quotedMessage: quotedMessage,
                                 reactionMap: reactionMap,
                                 reactionMessage: reactionMessage,
                                 recall: recall,
                                 storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                 translateMessage: translateMessage,
                                 whisperMessageType: whisperMessageType,
                                 authorId: authorId,
                                 customAttributedMessage: customAttributedMessage,
                                 customMessage: customMessage,
                                 inviteCode: inviteCode,
                                 meetingDetailUrl: meetingDetailUrl,
                                 meetingName: meetingName,
                                 meetingReminderType: meetingReminderType,
                                 messageType: messageType,
                                 read: read,
                                 realSource: realSource,
                                 recallPreview: recallPreview,
                                 shouldAffectThreadSorting: shouldAffectThreadSorting,
                                 sourceDeviceId: sourceDeviceId,
                                 unregisteredRecipientId: unregisteredRecipientId)
        }

        if let modelToCopy = self as? TSIncomingMessage {
            assert(type(of: modelToCopy) == TSIncomingMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType
            let authorId: String = modelToCopy.authorId
            let mentionedMsgType: OWSMentionedMsgType = modelToCopy.mentionedMsgType
            let read: Bool = modelToCopy.wasRead
            let sourceDeviceId: UInt32 = modelToCopy.sourceDeviceId

            return TSIncomingMessage(grdbId: id,
                                     uniqueId: uniqueId,
                                     associatedUniqueThreadId: associatedUniqueThreadId,
                                     notifySequenceId: notifySequenceId,
                                     receivedAtTimestamp: receivedAtTimestamp,
                                     sequenceId: sequenceId,
                                     serverTimestamp: serverTimestamp,
                                     timestamp: timestamp,
                                     uniqueThreadId: uniqueThreadId,
                                     atPersons: atPersons,
                                     attachmentIds: attachmentIds,
                                     body: body,
                                     card: card,
                                     cardUniqueId: cardUniqueId,
                                     cardVersion: cardVersion,
                                     combinedForwardingMessage: combinedForwardingMessage,
                                     contactShare: contactShare,
                                     editable: editable,
                                     envelopSource: envelopSource,
                                     expireStartedAt: expireStartedAt,
                                     expiresAt: expiresAt,
                                     expiresInSeconds: expiresInSeconds,
                                     isPinnedMessage: isPinnedMessage,
                                     mentions: mentions,
                                     messageModeType: messageModeType,
                                     pinId: pinId,
                                     quotedMessage: quotedMessage,
                                     reactionMap: reactionMap,
                                     reactionMessage: reactionMessage,
                                     recall: recall,
                                     storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                     translateMessage: translateMessage,
                                     whisperMessageType: whisperMessageType,
                                     authorId: authorId,
                                     mentionedMsgType: mentionedMsgType,
                                     read: read,
                                     sourceDeviceId: sourceDeviceId)
        }

        if let modelToCopy = self as? TSErrorMessage {
            assert(type(of: modelToCopy) == TSErrorMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType
            let errorType: TSErrorMessageType = modelToCopy.errorType
            let read: Bool = modelToCopy.wasRead
            let recipientId: String? = modelToCopy.recipientId

            return TSErrorMessage(grdbId: id,
                                  uniqueId: uniqueId,
                                  associatedUniqueThreadId: associatedUniqueThreadId,
                                  notifySequenceId: notifySequenceId,
                                  receivedAtTimestamp: receivedAtTimestamp,
                                  sequenceId: sequenceId,
                                  serverTimestamp: serverTimestamp,
                                  timestamp: timestamp,
                                  uniqueThreadId: uniqueThreadId,
                                  atPersons: atPersons,
                                  attachmentIds: attachmentIds,
                                  body: body,
                                  card: card,
                                  cardUniqueId: cardUniqueId,
                                  cardVersion: cardVersion,
                                  combinedForwardingMessage: combinedForwardingMessage,
                                  contactShare: contactShare,
                                  editable: editable,
                                  envelopSource: envelopSource,
                                  expireStartedAt: expireStartedAt,
                                  expiresAt: expiresAt,
                                  expiresInSeconds: expiresInSeconds,
                                  isPinnedMessage: isPinnedMessage,
                                  mentions: mentions,
                                  messageModeType: messageModeType,
                                  pinId: pinId,
                                  quotedMessage: quotedMessage,
                                  reactionMap: reactionMap,
                                  reactionMessage: reactionMessage,
                                  recall: recall,
                                  storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                                  translateMessage: translateMessage,
                                  whisperMessageType: whisperMessageType,
                                  errorType: errorType,
                                  read: read,
                                  recipientId: recipientId)
        }

        if let modelToCopy = self as? TSMessage {
            assert(type(of: modelToCopy) == TSMessage.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId
            let atPersons: String? = modelToCopy.atPersons
            // NOTE: If this generates build errors, you made need to
            // implement DeepCopyable for this type in DeepCopy.swift.
            let attachmentIds: [String] = try DeepCopies.deepCopy(modelToCopy.attachmentIds)
            let body: String? = modelToCopy.body
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let card: DTCardMessageEntity?
            if let cardForCopy = modelToCopy.card {
               card = try DeepCopies.deepCopy(cardForCopy)
            } else {
               card = nil
            }
            let cardUniqueId: String? = modelToCopy.cardUniqueId
            let cardVersion: UInt32 = modelToCopy.cardVersion
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let combinedForwardingMessage: DTCombinedForwardingMessage?
            if let combinedForwardingMessageForCopy = modelToCopy.combinedForwardingMessage {
               combinedForwardingMessage = try DeepCopies.deepCopy(combinedForwardingMessageForCopy)
            } else {
               combinedForwardingMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let contactShare: OWSContact?
            if let contactShareForCopy = modelToCopy.contactShare {
               contactShare = try DeepCopies.deepCopy(contactShareForCopy)
            } else {
               contactShare = nil
            }
            let editable: Bool = modelToCopy.editable
            let envelopSource: String? = modelToCopy.envelopSource
            let expireStartedAt: UInt64 = modelToCopy.expireStartedAt
            let expiresAt: UInt64 = modelToCopy.expiresAt
            let expiresInSeconds: UInt32 = modelToCopy.expiresInSeconds
            let isPinnedMessage: Bool = modelToCopy.isPinnedMessage
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let mentions: [DTMention]?
            if let mentionsForCopy = modelToCopy.mentions {
               mentions = try DeepCopies.deepCopy(mentionsForCopy)
            } else {
               mentions = nil
            }
            let messageModeType: TSMessageModeType = modelToCopy.messageModeType
            let pinId: String? = modelToCopy.pinId
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let quotedMessage: TSQuotedMessage?
            if let quotedMessageForCopy = modelToCopy.quotedMessage {
               quotedMessage = try DeepCopies.deepCopy(quotedMessageForCopy)
            } else {
               quotedMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMap: [String: [DTReactionSource]]?
            if let reactionMapForCopy = modelToCopy.reactionMap {
               reactionMap = try DeepCopies.deepCopy(reactionMapForCopy)
            } else {
               reactionMap = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let reactionMessage: DTReactionMessage?
            if let reactionMessageForCopy = modelToCopy.reactionMessage {
               reactionMessage = try DeepCopies.deepCopy(reactionMessageForCopy)
            } else {
               reactionMessage = nil
            }
            // NOTE: If this generates build errors, you made need to
            // modify DeepCopy.swift to support this type.
            //
            // That might mean:
            //
            // * Implement DeepCopyable for this type (e.g. a model).
            // * Modify DeepCopies.deepCopy() to support this type (e.g. a collection).
            let recall: DTRecallMessage?
            if let recallForCopy = modelToCopy.recall {
               recall = try DeepCopies.deepCopy(recallForCopy)
            } else {
               recall = nil
            }
            let storedShouldStartExpireTimer: Bool = modelToCopy.storedShouldStartExpireTimer
            let translateMessage: DTTranslateMessage?
            if let translateMessageForCopy = modelToCopy.translateMessage {
               translateMessage = try DeepCopies.deepCopy(translateMessageForCopy)
            } else {
               translateMessage = nil
            }
            let whisperMessageType: TSWhisperMessageType = modelToCopy.whisperMessageType

            return TSMessage(grdbId: id,
                             uniqueId: uniqueId,
                             associatedUniqueThreadId: associatedUniqueThreadId,
                             notifySequenceId: notifySequenceId,
                             receivedAtTimestamp: receivedAtTimestamp,
                             sequenceId: sequenceId,
                             serverTimestamp: serverTimestamp,
                             timestamp: timestamp,
                             uniqueThreadId: uniqueThreadId,
                             atPersons: atPersons,
                             attachmentIds: attachmentIds,
                             body: body,
                             card: card,
                             cardUniqueId: cardUniqueId,
                             cardVersion: cardVersion,
                             combinedForwardingMessage: combinedForwardingMessage,
                             contactShare: contactShare,
                             editable: editable,
                             envelopSource: envelopSource,
                             expireStartedAt: expireStartedAt,
                             expiresAt: expiresAt,
                             expiresInSeconds: expiresInSeconds,
                             isPinnedMessage: isPinnedMessage,
                             mentions: mentions,
                             messageModeType: messageModeType,
                             pinId: pinId,
                             quotedMessage: quotedMessage,
                             reactionMap: reactionMap,
                             reactionMessage: reactionMessage,
                             recall: recall,
                             storedShouldStartExpireTimer: storedShouldStartExpireTimer,
                             translateMessage: translateMessage,
                             whisperMessageType: whisperMessageType)
        }

        do {
            let modelToCopy = self
            assert(type(of: modelToCopy) == TSInteraction.self)
            let uniqueId: String = modelToCopy.uniqueId
            let associatedUniqueThreadId: String = modelToCopy.associatedUniqueThreadId
            let notifySequenceId: UInt64 = modelToCopy.notifySequenceId
            let receivedAtTimestamp: UInt64 = modelToCopy.receivedAtTimestamp
            let sequenceId: UInt64 = modelToCopy.sequenceId
            let serverTimestamp: UInt64 = modelToCopy.serverTimestamp
            let timestamp: UInt64 = modelToCopy.timestamp
            let uniqueThreadId: String = modelToCopy.uniqueThreadId

            return TSInteraction(grdbId: id,
                                 uniqueId: uniqueId,
                                 associatedUniqueThreadId: associatedUniqueThreadId,
                                 notifySequenceId: notifySequenceId,
                                 receivedAtTimestamp: receivedAtTimestamp,
                                 sequenceId: sequenceId,
                                 serverTimestamp: serverTimestamp,
                                 timestamp: timestamp,
                                 uniqueThreadId: uniqueThreadId)
        }

    }
}

// MARK: - Table Metadata

extension TSInteractionSerializer {

    // This defines all of the columns used in the table
    // where this model (and any subclasses) are persisted.
    static var idColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "id", columnType: .primaryKey) }
    static var recordTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "recordType", columnType: .int64) }
    static var uniqueIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "uniqueId", columnType: .unicodeString, isUnique: true) }
    // Properties
    static var associatedUniqueThreadIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "associatedUniqueThreadId", columnType: .unicodeString) }
    static var atPersonsColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "atPersons", columnType: .unicodeString, isOptional: true) }
    static var attachmentIdsColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "attachmentIds", columnType: .blob, isOptional: true) }
    static var authorIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "authorId", columnType: .unicodeString, isOptional: true) }
    static var bodyColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "body", columnType: .unicodeString, isOptional: true) }
    static var cardColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "card", columnType: .blob, isOptional: true) }
    static var combinedForwardingMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "combinedForwardingMessage", columnType: .blob, isOptional: true) }
    static var contactShareColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "contactShare", columnType: .blob, isOptional: true) }
    static var customAttributedMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "customAttributedMessage", columnType: .blob, isOptional: true) }
    static var customMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "customMessage", columnType: .unicodeString, isOptional: true) }
    static var editableColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "editable", columnType: .int, isOptional: true) }
    static var errorTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "errorType", columnType: .int, isOptional: true) }
    static var expireStartedAtColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "expireStartedAt", columnType: .int64, isOptional: true) }
    static var expiresAtColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "expiresAt", columnType: .int64, isOptional: true) }
    static var expiresInSecondsColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "expiresInSeconds", columnType: .int64, isOptional: true) }
    static var groupChatModeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "groupChatMode", columnType: .int, isOptional: true) }
    static var groupMetaMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "groupMetaMessage", columnType: .int, isOptional: true) }
    static var hasSyncedTranscriptColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "hasSyncedTranscript", columnType: .int, isOptional: true) }
    static var inviteCodeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "inviteCode", columnType: .unicodeString, isOptional: true) }
    static var isFromLinkedDeviceColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "isFromLinkedDevice", columnType: .int, isOptional: true) }
    static var isPinnedMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "isPinnedMessage", columnType: .int, isOptional: true) }
    static var isVoiceMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "isVoiceMessage", columnType: .int, isOptional: true) }
    static var meetingDetailUrlColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "meetingDetailUrl", columnType: .unicodeString, isOptional: true) }
    static var meetingNameColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "meetingName", columnType: .unicodeString, isOptional: true) }
    static var meetingReminderTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "meetingReminderType", columnType: .int, isOptional: true) }
    static var messageTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "messageType", columnType: .int, isOptional: true) }
    static var mostRecentFailureTextColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "mostRecentFailureText", columnType: .unicodeString, isOptional: true) }
    static var notifySequenceIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "notifySequenceId", columnType: .int64) }
    static var pinIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "pinId", columnType: .unicodeString, isOptional: true) }
    static var quotedMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "quotedMessage", columnType: .blob, isOptional: true) }
    static var rapidFilesColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "rapidFiles", columnType: .blob, isOptional: true) }
    static var reactionMapColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "reactionMap", columnType: .blob, isOptional: true) }
    static var reactionMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "reactionMessage", columnType: .blob, isOptional: true) }
    static var readColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "read", columnType: .int, isOptional: true) }
    static var realSourceColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "realSource", columnType: .blob, isOptional: true) }
    static var recallColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "recall", columnType: .blob, isOptional: true) }
    static var recallPreviewColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "recallPreview", columnType: .unicodeString, isOptional: true) }
    static var receivedAtTimestampColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "receivedAtTimestamp", columnType: .int64) }
    static var recipientIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "recipientId", columnType: .unicodeString, isOptional: true) }
    static var recipientStateMapColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "recipientStateMap", columnType: .blob, isOptional: true) }
    static var sequenceIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "sequenceId", columnType: .int64) }
    static var serverTimestampColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "serverTimestamp", columnType: .int64) }
    static var sourceDeviceIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "sourceDeviceId", columnType: .int64, isOptional: true) }
    static var timestampColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "timestamp", columnType: .int64) }
    static var translateMessageColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "translateMessage", columnType: .blob, isOptional: true) }
    static var uniqueThreadIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "uniqueThreadId", columnType: .unicodeString) }
    static var unregisteredRecipientIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "unregisteredRecipientId", columnType: .unicodeString, isOptional: true) }
    static var whisperMessageTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "whisperMessageType", columnType: .int, isOptional: true) }
    static var storedShouldStartExpireTimerColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "storedShouldStartExpireTimer", columnType: .int, isOptional: true) }
    static var mentionedMsgTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "mentionedMsgType", columnType: .int, isOptional: true) }
    static var configurationDurationSecondsColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "configurationDurationSeconds", columnType: .int64, isOptional: true) }
    static var shouldAffectThreadSortingColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "shouldAffectThreadSorting", columnType: .int, isOptional: true) }
    static var mentionsColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "mentions", columnType: .blob, isOptional: true) }
    static var storedMessageStateColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "storedMessageState", columnType: .int, isOptional: true) }
    static var envelopSourceColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "envelopSource", columnType: .unicodeString, isOptional: true) }
    static var cardUniqueIdColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "cardUniqueId", columnType: .unicodeString, isOptional: true) }
    static var cardVersionColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "cardVersion", columnType: .int64, isOptional: true) }
    static var messageModeTypeColumn: SDSColumnMetadata { SDSColumnMetadata(columnName: "messageModeType", columnType: .int, isOptional: true) }

    // TODO: We should decide on a naming convention for
    //       tables that store models.
    public static var table: SDSTableMetadata {
        SDSTableMetadata(collection: TSInteraction.collection(),
                         tableName: "model_TSInteraction",
                         columns: [
        idColumn,
        recordTypeColumn,
        uniqueIdColumn,
        associatedUniqueThreadIdColumn,
        atPersonsColumn,
        attachmentIdsColumn,
        authorIdColumn,
        bodyColumn,
        cardColumn,
        combinedForwardingMessageColumn,
        contactShareColumn,
        customAttributedMessageColumn,
        customMessageColumn,
        editableColumn,
        errorTypeColumn,
        expireStartedAtColumn,
        expiresAtColumn,
        expiresInSecondsColumn,
        groupChatModeColumn,
        groupMetaMessageColumn,
        hasSyncedTranscriptColumn,
        inviteCodeColumn,
        isFromLinkedDeviceColumn,
        isPinnedMessageColumn,
        isVoiceMessageColumn,
        meetingDetailUrlColumn,
        meetingNameColumn,
        meetingReminderTypeColumn,
        messageTypeColumn,
        mostRecentFailureTextColumn,
        notifySequenceIdColumn,
        pinIdColumn,
        quotedMessageColumn,
        rapidFilesColumn,
        reactionMapColumn,
        reactionMessageColumn,
        readColumn,
        realSourceColumn,
        recallColumn,
        recallPreviewColumn,
        receivedAtTimestampColumn,
        recipientIdColumn,
        recipientStateMapColumn,
        sequenceIdColumn,
        serverTimestampColumn,
        sourceDeviceIdColumn,
        timestampColumn,
        translateMessageColumn,
        uniqueThreadIdColumn,
        unregisteredRecipientIdColumn,
        whisperMessageTypeColumn,
        storedShouldStartExpireTimerColumn,
        mentionedMsgTypeColumn,
        configurationDurationSecondsColumn,
        shouldAffectThreadSortingColumn,
        mentionsColumn,
        storedMessageStateColumn,
        envelopSourceColumn,
        cardUniqueIdColumn,
        cardVersionColumn,
        messageModeTypeColumn
        ])
    }
}

// MARK: - Save/Remove/Update

@objc
public extension TSInteraction {
    func anyInsert(transaction: SDSAnyWriteTransaction) {
        sdsSave(saveMode: .insert, transaction: transaction)
    }

    // Avoid this method whenever feasible.
    //
    // If the record has previously been saved, this method does an overwriting
    // update of the corresponding row, otherwise if it's a new record, this
    // method inserts a new row.
    //
    // For performance, when possible, you should explicitly specify whether
    // you are inserting or updating rather than calling this method.
    func anyUpsert(transaction: SDSAnyWriteTransaction) {
        let isInserting: Bool
        if TSInteraction.anyFetch(uniqueId: uniqueId, transaction: transaction) != nil {
            isInserting = false
        } else {
            isInserting = true
        }
        sdsSave(saveMode: isInserting ? .insert : .update, transaction: transaction)
    }

    // This method is used by "updateWith..." methods.
    //
    // This model may be updated from many threads. We don't want to save
    // our local copy (this instance) since it may be out of date.  We also
    // want to avoid re-saving a model that has been deleted.  Therefore, we
    // use "updateWith..." methods to:
    //
    // a) Update a property of this instance.
    // b) If a copy of this model exists in the database, load an up-to-date copy,
    //    and update and save that copy.
    // b) If a copy of this model _DOES NOT_ exist in the database, do _NOT_ save
    //    this local instance.
    //
    // After "updateWith...":
    //
    // a) Any copy of this model in the database will have been updated.
    // b) The local property on this instance will always have been updated.
    // c) Other properties on this instance may be out of date.
    //
    // All mutable properties of this class have been made read-only to
    // prevent accidentally modifying them directly.
    //
    // This isn't a perfect arrangement, but in practice this will prevent
    // data loss and will resolve all known issues.
    func anyUpdate(transaction: SDSAnyWriteTransaction, block: (TSInteraction) -> Void) {

        block(self)

        guard let dbCopy = type(of: self).anyFetch(uniqueId: uniqueId,
                                                   transaction: transaction) else {
            return
        }

        // Don't apply the block twice to the same instance.
        // It's at least unnecessary and actually wrong for some blocks.
        // e.g. `block: { $0 in $0.someField++ }`
        if dbCopy !== self {
            block(dbCopy)
        }

        dbCopy.sdsSave(saveMode: .update, transaction: transaction)
    }

    // This method is an alternative to `anyUpdate(transaction:block:)` methods.
    //
    // We should generally use `anyUpdate` to ensure we're not unintentionally
    // clobbering other columns in the database when another concurrent update
    // has occurred.
    //
    // There are cases when this doesn't make sense, e.g. when  we know we've
    // just loaded the model in the same transaction. In those cases it is
    // safe and faster to do a "overwriting" update
    func anyOverwritingUpdate(transaction: SDSAnyWriteTransaction) {
        sdsSave(saveMode: .update, transaction: transaction)
    }

    func anyRemove(transaction: SDSAnyWriteTransaction) {
        sdsRemove(transaction: transaction)
    }

    func anyReload(transaction: SDSAnyReadTransaction) {
        anyReload(transaction: transaction, ignoreMissing: false)
    }

    func anyReload(transaction: SDSAnyReadTransaction, ignoreMissing: Bool) {
        guard let latestVersion = type(of: self).anyFetch(uniqueId: uniqueId, transaction: transaction) else {
            if !ignoreMissing {
                owsFailDebug("`latest` was unexpectedly nil")
            }
            return
        }

        setValuesForKeys(latestVersion.dictionaryValue)
    }
}

// MARK: - TSInteractionCursor

@objc
public class TSInteractionCursor: NSObject, SDSCursor {
    private let transaction: GRDBReadTransaction
    private let cursor: RecordCursor<InteractionRecord>?

    init(transaction: GRDBReadTransaction, cursor: RecordCursor<InteractionRecord>?) {
        self.transaction = transaction
        self.cursor = cursor
    }

    public func next() throws -> TSInteraction? {
        guard let cursor = cursor else {
            return nil
        }
        guard let record = try cursor.next() else {
            return nil
        }
        let value = try TSInteraction.fromRecord(record)
        Self.modelReadCaches.interactionReadCache.didReadInteraction(value, transaction: transaction.asAnyRead)
        return value
    }

    public func all() throws -> [TSInteraction] {
        var result = [TSInteraction]()
        while true {
            guard let model = try next() else {
                break
            }
            result.append(model)
        }
        return result
    }
}

// MARK: - Obj-C Fetch

// TODO: We may eventually want to define some combination of:
//
// * fetchCursor, fetchOne, fetchAll, etc. (ala GRDB)
// * Optional "where clause" parameters for filtering.
// * Async flavors with completions.
//
// TODO: I've defined flavors that take a read transaction.
//       Or we might take a "connection" if we end up having that class.
@objc
public extension TSInteraction {
    class func grdbFetchCursor(transaction: GRDBReadTransaction) -> TSInteractionCursor {
        let database = transaction.database
        do {
            let cursor = try InteractionRecord.fetchCursor(database)
            return TSInteractionCursor(transaction: transaction, cursor: cursor)
        } catch {
            owsFailDebug("Read failed: \(error)")
            return TSInteractionCursor(transaction: transaction, cursor: nil)
        }
    }

    // Fetches a single model by "unique id".
    class func anyFetch(uniqueId: String,
                        transaction: SDSAnyReadTransaction) -> TSInteraction? {
        assert(uniqueId.count > 0)

        return anyFetch(uniqueId: uniqueId, transaction: transaction, ignoreCache: false)
    }

    // Fetches a single model by "unique id".
    class func anyFetch(uniqueId: String,
                        transaction: SDSAnyReadTransaction,
                        ignoreCache: Bool) -> TSInteraction? {
        assert(uniqueId.count > 0)

        if !ignoreCache,
            let cachedCopy = Self.modelReadCaches.interactionReadCache.getInteraction(uniqueId: uniqueId, transaction: transaction) {
            return cachedCopy
        }

        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            let sql = "SELECT * FROM \(InteractionRecord.databaseTableName) WHERE \(interactionColumn: .uniqueId) = ?"
            return grdbFetchOne(sql: sql, arguments: [uniqueId], transaction: grdbTransaction)
        }
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    class func anyEnumerate(transaction: SDSAnyReadTransaction,
                            block: @escaping (TSInteraction, UnsafeMutablePointer<ObjCBool>) -> Void) {
        anyEnumerate(transaction: transaction, batched: false, block: block)
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    class func anyEnumerate(transaction: SDSAnyReadTransaction,
                            batched: Bool = false,
                            block: @escaping (TSInteraction, UnsafeMutablePointer<ObjCBool>) -> Void) {
        let batchSize = batched ? Batching.kDefaultBatchSize : 0
        anyEnumerate(transaction: transaction, batchSize: batchSize, block: block)
    }

    // Traverses all records.
    // Records are not visited in any particular order.
    //
    // If batchSize > 0, the enumeration is performed in autoreleased batches.
    class func anyEnumerate(transaction: SDSAnyReadTransaction,
                            batchSize: UInt,
                            block: @escaping (TSInteraction, UnsafeMutablePointer<ObjCBool>) -> Void) {
        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            let cursor = TSInteraction.grdbFetchCursor(transaction: grdbTransaction)
            Batching.loop(batchSize: batchSize,
                          loopBlock: { stop in
                                do {
                                    guard let value = try cursor.next() else {
                                        stop.pointee = true
                                        return
                                    }
                                    block(value, stop)
                                } catch let error {
                                    owsFailDebug("Couldn't fetch model: \(error)")
                                }
                              })
        }
    }

    // Traverses all records' unique ids.
    // Records are not visited in any particular order.
    class func anyEnumerateUniqueIds(transaction: SDSAnyReadTransaction,
                                     block: @escaping (String, UnsafeMutablePointer<ObjCBool>) -> Void) {
        anyEnumerateUniqueIds(transaction: transaction, batched: false, block: block)
    }

    // Traverses all records' unique ids.
    // Records are not visited in any particular order.
    class func anyEnumerateUniqueIds(transaction: SDSAnyReadTransaction,
                                     batched: Bool = false,
                                     block: @escaping (String, UnsafeMutablePointer<ObjCBool>) -> Void) {
        let batchSize = batched ? Batching.kDefaultBatchSize : 0
        anyEnumerateUniqueIds(transaction: transaction, batchSize: batchSize, block: block)
    }

    // Traverses all records' unique ids.
    // Records are not visited in any particular order.
    //
    // If batchSize > 0, the enumeration is performed in autoreleased batches.
    class func anyEnumerateUniqueIds(transaction: SDSAnyReadTransaction,
                                     batchSize: UInt,
                                     block: @escaping (String, UnsafeMutablePointer<ObjCBool>) -> Void) {
        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            grdbEnumerateUniqueIds(transaction: grdbTransaction,
                                   sql: """
                    SELECT \(interactionColumn: .uniqueId)
                    FROM \(InteractionRecord.databaseTableName)
                """,
                batchSize: batchSize,
                block: block)
        }
    }

    // Does not order the results.
    class func anyFetchAll(transaction: SDSAnyReadTransaction) -> [TSInteraction] {
        var result = [TSInteraction]()
        anyEnumerate(transaction: transaction) { (model, _) in
            result.append(model)
        }
        return result
    }

    // Does not order the results.
    class func anyAllUniqueIds(transaction: SDSAnyReadTransaction) -> [String] {
        var result = [String]()
        anyEnumerateUniqueIds(transaction: transaction) { (uniqueId, _) in
            result.append(uniqueId)
        }
        return result
    }

    class func anyCount(transaction: SDSAnyReadTransaction) -> UInt {
        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            return InteractionRecord.ows_fetchCount(grdbTransaction.database)
        }
    }

    // WARNING: Do not use this method for any models which do cleanup
    //          in their anyWillRemove(), anyDidRemove() methods.
    class func anyRemoveAllWithoutInstantation(transaction: SDSAnyWriteTransaction) {
        switch transaction.writeTransaction {
        //Kris GRDB
        case .grdbWrite(let grdbTransaction):
            do {
                try InteractionRecord.deleteAll(grdbTransaction.database)
            } catch {
                owsFailDebug("deleteAll() failed: \(error)")
            }
        }

        if ftsIndexMode != .never {
            FullTextSearchFinder.allModelsWereRemoved(collection: collection(), transaction: transaction)
        }
    }

    class func anyRemoveAllWithInstantation(transaction: SDSAnyWriteTransaction) {
        // To avoid mutationDuringEnumerationException, we need
        // to remove the instances outside the enumeration.
        let uniqueIds = anyAllUniqueIds(transaction: transaction)

        var index: Int = 0
        Batching.loop(batchSize: Batching.kDefaultBatchSize,
                      loopBlock: { stop in
            guard index < uniqueIds.count else {
                stop.pointee = true
                return
            }
            let uniqueId = uniqueIds[index]
            index += 1
            guard let instance = anyFetch(uniqueId: uniqueId, transaction: transaction) else {
                owsFailDebug("Missing instance.")
                return
            }
            instance.anyRemove(transaction: transaction)
        })

        if ftsIndexMode != .never {
            FullTextSearchFinder.allModelsWereRemoved(collection: collection(), transaction: transaction)
        }
    }

    class func anyExists(
        uniqueId: String,
        transaction: SDSAnyReadTransaction
    ) -> Bool {
        assert(uniqueId.count > 0)

        switch transaction.readTransaction {
        //Kris GRDB
        case .grdbRead(let grdbTransaction):
            let sql = "SELECT EXISTS ( SELECT 1 FROM \(InteractionRecord.databaseTableName) WHERE \(interactionColumn: .uniqueId) = ? )"
            let arguments: StatementArguments = [uniqueId]
            return try! Bool.fetchOne(grdbTransaction.database, sql: sql, arguments: arguments) ?? false
        }
    }
}

// MARK: - Swift Fetch

public extension TSInteraction {
    class func grdbFetchCursor(sql: String,
                               arguments: StatementArguments = StatementArguments(),
                               transaction: GRDBReadTransaction) -> TSInteractionCursor {
        do {
            let sqlRequest = SQLRequest<Void>(sql: sql, arguments: arguments, cached: true)
            let cursor = try InteractionRecord.fetchCursor(transaction.database, sqlRequest)
            return TSInteractionCursor(transaction: transaction, cursor: cursor)
        } catch {
            Logger.verbose("sql: \(sql)")
            owsFailDebug("Read failed: \(error)")
            return TSInteractionCursor(transaction: transaction, cursor: nil)
        }
    }

    class func grdbFetchOne(sql: String,
                            arguments: StatementArguments = StatementArguments(),
                            transaction: GRDBReadTransaction) -> TSInteraction? {
        assert(sql.count > 0)

        do {
            let sqlRequest = SQLRequest<Void>(sql: sql, arguments: arguments, cached: true)
            guard let record = try InteractionRecord.fetchOne(transaction.database, sqlRequest) else {
                return nil
            }

            let value = try TSInteraction.fromRecord(record)
            Self.modelReadCaches.interactionReadCache.didReadInteraction(value, transaction: transaction.asAnyRead)
            return value
        } catch {
            owsFailDebug("error: \(error)")
            return nil
        }
    }
}

// MARK: - SDSSerializer

// The SDSSerializer protocol specifies how to insert and update the
// row that corresponds to this model.
class TSInteractionSerializer: SDSSerializer {

    private let model: TSInteraction
    public required init(model: TSInteraction) {
        self.model = model
    }

    // MARK: - Record

    func asRecord() throws -> SDSRecord {
        let id: Int64? = model.grdbId?.int64Value

        let recordType: SDSRecordType = .interaction
        let uniqueId: String = model.uniqueId

        // Properties
        let associatedUniqueThreadId: String = model.associatedUniqueThreadId
        let atPersons: String? = nil
        let attachmentIds: Data? = nil
        let authorId: String? = nil
        let body: String? = nil
        let card: Data? = nil
        let combinedForwardingMessage: Data? = nil
        let contactShare: Data? = nil
        let customAttributedMessage: Data? = nil
        let customMessage: String? = nil
        let editable: Bool? = nil
        let errorType: TSErrorMessageType? = nil
        let expireStartedAt: UInt64? = nil
        let expiresAt: UInt64? = nil
        let expiresInSeconds: UInt32? = nil
        let groupChatMode: TSGroupChatMode? = nil
        let groupMetaMessage: TSGroupMetaMessage? = nil
        let hasSyncedTranscript: Bool? = nil
        let inviteCode: String? = nil
        let isFromLinkedDevice: Bool? = nil
        let isPinnedMessage: Bool? = nil
        let isVoiceMessage: Bool? = nil
        let meetingDetailUrl: String? = nil
        let meetingName: String? = nil
        let meetingReminderType: DTMeetingReminderType? = nil
        let messageType: TSInfoMessageType? = nil
        let mostRecentFailureText: String? = nil
        let notifySequenceId: UInt64 = model.notifySequenceId
        let pinId: String? = nil
        let quotedMessage: Data? = nil
        let rapidFiles: Data? = nil
        let reactionMap: Data? = nil
        let reactionMessage: Data? = nil
        let read: Bool? = nil
        let realSource: Data? = nil
        let recall: Data? = nil
        let recallPreview: String? = nil
        let receivedAtTimestamp: UInt64 = model.receivedAtTimestamp
        let recipientId: String? = nil
        let recipientStateMap: Data? = nil
        let sequenceId: UInt64 = model.sequenceId
        let serverTimestamp: UInt64 = model.serverTimestamp
        let sourceDeviceId: UInt32? = nil
        let timestamp: UInt64 = model.timestamp
        let translateMessage: Data? = nil
        let threadUniqueId: String = model.uniqueThreadId
        let unregisteredRecipientId: String? = nil
        let whisperMessageType: TSWhisperMessageType? = nil
        let storedShouldStartExpireTimer: Bool? = nil
        let mentionedMsgType: OWSMentionedMsgType? = nil
        let configurationDurationSeconds: UInt32? = nil
        let shouldAffectThreadSorting: Bool? = nil
        let mentions: Data? = nil
        let storedMessageState: TSOutgoingMessageState? = nil
        let envelopSource: String? = nil
        let cardUniqueId: String? = nil
        let cardVersion: UInt32? = nil
        let messageModeType: TSMessageModeType? = nil

        return InteractionRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, associatedUniqueThreadId: associatedUniqueThreadId, atPersons: atPersons, attachmentIds: attachmentIds, authorId: authorId, body: body, card: card, combinedForwardingMessage: combinedForwardingMessage, contactShare: contactShare, customAttributedMessage: customAttributedMessage, customMessage: customMessage, editable: editable, errorType: errorType, expireStartedAt: expireStartedAt, expiresAt: expiresAt, expiresInSeconds: expiresInSeconds, groupChatMode: groupChatMode, groupMetaMessage: groupMetaMessage, hasSyncedTranscript: hasSyncedTranscript, inviteCode: inviteCode, isFromLinkedDevice: isFromLinkedDevice, isPinnedMessage: isPinnedMessage, isVoiceMessage: isVoiceMessage, meetingDetailUrl: meetingDetailUrl, meetingName: meetingName, meetingReminderType: meetingReminderType, messageType: messageType, mostRecentFailureText: mostRecentFailureText, notifySequenceId: notifySequenceId, pinId: pinId, quotedMessage: quotedMessage, rapidFiles: rapidFiles, reactionMap: reactionMap, reactionMessage: reactionMessage, read: read, realSource: realSource, recall: recall, recallPreview: recallPreview, receivedAtTimestamp: receivedAtTimestamp, recipientId: recipientId, recipientStateMap: recipientStateMap, sequenceId: sequenceId, serverTimestamp: serverTimestamp, sourceDeviceId: sourceDeviceId, timestamp: timestamp, translateMessage: translateMessage, threadUniqueId: threadUniqueId, unregisteredRecipientId: unregisteredRecipientId, whisperMessageType: whisperMessageType, storedShouldStartExpireTimer: storedShouldStartExpireTimer, mentionedMsgType: mentionedMsgType, configurationDurationSeconds: configurationDurationSeconds, shouldAffectThreadSorting: shouldAffectThreadSorting, mentions: mentions, storedMessageState: storedMessageState, envelopSource: envelopSource, cardUniqueId: cardUniqueId, cardVersion: cardVersion, messageModeType: messageModeType)
    }
}

// MARK: - Deep Copy

#if TESTABLE_BUILD
@objc
public extension TSInteraction {
    // We're not using this method at the moment,
    // but we might use it for validation of
    // other deep copy methods.
    func deepCopyUsingRecord() throws -> TSInteraction {
        guard let record = try asRecord() as? InteractionRecord else {
            throw OWSAssertionError("Could not convert to record.")
        }
        return try TSInteraction.fromRecord(record)
    }
}
#endif
                                                          
