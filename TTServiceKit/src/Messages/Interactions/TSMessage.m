//
//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.
//

#import "TSMessage.h"
#import "AppContext.h"
#import "MIMETypeUtil.h"
#import <SignalCoreKit/NSDate+OWS.h>
#import "NSString+SSK.h"
#import "OWSContact.h"
#import "OWSDisappearingMessagesConfiguration.h"
#import "TSAttachment.h"
#import "TSAttachmentStream.h"
#import "TSQuotedMessage.h"
#import "DTCombinedForwardingMessage.h"
#import "TSThread.h"
#import "DTRecallMessage.h"
#import "DTReactionMessage.h"
#import <TTServiceKit/TTServiceKit-Swift.h>
#import "DTParamsBaseUtils.h"
#import "DTMention.h"
#import "NSString+DTMarkdown.h"

NS_ASSUME_NONNULL_BEGIN

NSString *const MENTIONS_ALL = @"MENTIONS_ALL";
static const NSUInteger OWSMessageSchemaVersion = 4;

#pragma mark -

@interface TSMessage ()

@property (nonatomic, nullable) NSString *body;
@property (nonatomic, nullable) NSString *atPersons;
@property (nonatomic, nullable) NSArray <DTMention *> *mentions;
@property (nonatomic) uint32_t expiresInSeconds;
@property (nonatomic) uint64_t expireStartedAt;

/**
 * The version of the model class's schema last used to serialize this model. Use this to manage data migrations during
 * object de/serialization.
 *
 * e.g.
 *
 *    - (id)initWithCoder:(NSCoder *)coder
 *    {
 *      self = [super initWithCoder:coder];
 *      if (!self) { return self; }
 *      if (_schemaVersion < 2) {
 *        _newName = [coder decodeObjectForKey:@"oldName"]
 *      }
 *      ...
 *      _schemaVersion = 2;
 *    }
 */
@property (nonatomic, readonly) NSUInteger schemaVersion;

// The timestamp property is populated by the envelope,
// which is created by the sender.
//
// We typically want to order messages locally by when
// they were received & decrypted, not by when they were sent.
//@property (nonatomic) uint64_t receivedAtTimestamp;


// This property is only intended to be used by GRDB queries.
@property (nonatomic, readonly) BOOL storedShouldStartExpireTimer;

@end

#pragma mark -

@implementation TSMessage

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
        associatedUniqueThreadId:(NSString *)associatedUniqueThreadId
                notifySequenceId:(uint64_t)notifySequenceId
             receivedAtTimestamp:(uint64_t)receivedAtTimestamp
                      sequenceId:(uint64_t)sequenceId
                 serverTimestamp:(uint64_t)serverTimestamp
                       timestamp:(uint64_t)timestamp
                  uniqueThreadId:(NSString *)uniqueThreadId
                       atPersons:(nullable NSString *)atPersons
                   attachmentIds:(NSArray<NSString *> *)attachmentIds
                            body:(nullable NSString *)body
                            card:(nullable DTCardMessageEntity *)card
                    cardUniqueId:(nullable NSString *)cardUniqueId
                     cardVersion:(unsigned int)cardVersion
       combinedForwardingMessage:(nullable DTCombinedForwardingMessage *)combinedForwardingMessage
                    contactShare:(nullable OWSContact *)contactShare
                        editable:(BOOL)editable
                   envelopSource:(nullable NSString *)envelopSource
                 expireStartedAt:(uint64_t)expireStartedAt
                       expiresAt:(uint64_t)expiresAt
                expiresInSeconds:(unsigned int)expiresInSeconds
                 isPinnedMessage:(BOOL)isPinnedMessage
                        mentions:(nullable NSArray<DTMention *> *)mentions
                 messageModeType:(TSMessageModeType)messageModeType
                           pinId:(nullable NSString *)pinId
                   quotedMessage:(nullable TSQuotedMessage *)quotedMessage
                     reactionMap:(nullable NSDictionary<NSString *,NSArray<DTReactionSource *> *> *)reactionMap
                 reactionMessage:(nullable DTReactionMessage *)reactionMessage
                          recall:(nullable DTRecallMessage *)recall
    storedShouldStartExpireTimer:(BOOL)storedShouldStartExpireTimer
                translateMessage:(nullable DTTranslateMessage *)translateMessage
              whisperMessageType:(TSWhisperMessageType)whisperMessageType
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId
          associatedUniqueThreadId:associatedUniqueThreadId
                  notifySequenceId:notifySequenceId
               receivedAtTimestamp:receivedAtTimestamp
                        sequenceId:sequenceId
                   serverTimestamp:serverTimestamp
                         timestamp:timestamp
                    uniqueThreadId:uniqueThreadId];

    if (!self) {
        return self;
    }

    _atPersons = atPersons;
    _attachmentIds = attachmentIds;
    _body = body;
    _card = card;
    _cardUniqueId = cardUniqueId;
    _cardVersion = cardVersion;
    _combinedForwardingMessage = combinedForwardingMessage;
    _contactShare = contactShare;
    _editable = editable;
    _envelopSource = envelopSource;
    _expireStartedAt = expireStartedAt;
    _expiresAt = expiresAt;
    _expiresInSeconds = expiresInSeconds;
    _isPinnedMessage = isPinnedMessage;
    _mentions = mentions;
    _messageModeType = messageModeType;
    _pinId = pinId;
    _quotedMessage = quotedMessage;
    _reactionMap = reactionMap;
    _reactionMessage = reactionMessage;
    _recall = recall;
    _storedShouldStartExpireTimer = storedShouldStartExpireTimer;
    _translateMessage = translateMessage;
    _whisperMessageType = whisperMessageType;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

- (instancetype)initMessageWithTimestamp:(uint64_t)timestamp
                         serverTimestamp:(uint64_t)serverTimestamp
                              sequenceId:(uint64_t)sequenceId
                        notifySequenceId:(uint64_t)notifySequenceId
                                inThread:(nullable TSThread *)thread
                                authorId:(nullable NSString *)authorId
                                deviceId:(uint32_t)deviceId
                             messageBody:(nullable NSString *)body
                               atPersons:(nullable NSString *)atPersons
                                mentions:(nullable NSArray <DTMention *> *)mentions
                           attachmentIds:(NSArray<NSString *> *)attachmentIds
                        expiresInSeconds:(uint32_t)expiresInSeconds
                         expireStartedAt:(uint64_t)expireStartedAt
                           quotedMessage:(nullable TSQuotedMessage *)quotedMessage
                       forwardingMessage:(nullable DTCombinedForwardingMessage *)forwardingMessage
                            contactShare:(nullable OWSContact *)contactShare
{
    self = [super initInteractionWithTimestamp:timestamp
                               serverTimestamp:serverTimestamp
                                    sequenceId:sequenceId
                              notifySequenceId:notifySequenceId
                                      inThread:thread
                                      authorId:authorId
                                      deviceId:deviceId];
    
    if (!self) {
        return self;
    }
    
    _schemaVersion = OWSMessageSchemaVersion;
    _body = body;
    _mentions = mentions;
    _atPersons = [DTMention atPersons:mentions];
    if (!_atPersons) _atPersons = atPersons;
    
    _attachmentIds = attachmentIds ? [attachmentIds mutableCopy] : [NSMutableArray new];
    _expiresInSeconds = expiresInSeconds;
    _expireStartedAt = expireStartedAt;
    [self updateExpiresAt];
    _quotedMessage = quotedMessage;
    _combinedForwardingMessage = forwardingMessage;
    _contactShare = contactShare;
    
    return self;
}

- (nullable instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];
    if (!self) {
        return self;
    }
    
    if (_schemaVersion < 2) {
        // renamed _attachments to _attachmentIds
        if (!_attachmentIds) {
            _attachmentIds = [coder decodeObjectForKey:@"attachments"];
        }
    }
    
    if (_schemaVersion < 3) {
        _expiresInSeconds = 0;
        _expireStartedAt = 0;
        _expiresAt = 0;
    }
    
    if (_schemaVersion < 4) {
        // Wipe out the body field on these legacy attachment messages.
        //
        // Explantion: Historically, a message sent from iOS could be an attachment XOR a text message,
        // but now we support sending an attachment+caption as a single message.
        //
        // Other clients have supported sending attachment+caption in a single message for a long time.
        // So the way we used to handle receiving them was to make it look like they'd sent two messages:
        // first the attachment+caption (we'd ignore this caption when rendering), followed by a separate
        // message with just the caption (which we'd render as a simple independent text message), for
        // which we'd offset the timestamp by a little bit to get the desired ordering.
        //
        // Now that we can properly render an attachment+caption message together, these legacy "dummy" text
        // messages are not only unnecessary, but worse, would be rendered redundantly. For safety, rather
        // than building the logic to try to find and delete the redundant "dummy" text messages which users
        // have been seeing and interacting with, we delete the body field from the attachment message,
        // which iOS users have never seen directly.
        if (_attachmentIds.count > 0) {
            _body = nil;
        }
    }
    
    if (!_attachmentIds) {
        _attachmentIds = [NSMutableArray new];
    }
    
    _schemaVersion = OWSMessageSchemaVersion;
    
    return self;
}

- (void)setExpiresInSeconds:(uint32_t)expiresInSeconds
{
    uint32_t maxExpirationDuration = [OWSDisappearingMessagesConfiguration maxDurationSeconds];
    if (expiresInSeconds > maxExpirationDuration) {
        //        OWSFailDebug(@"%@ in %s using `maxExpirationDuration` instead of: %u", self.logTag, __PRETTY_FUNCTION__, maxExpirationDuration);
    }
    
    _expiresInSeconds = MIN(expiresInSeconds, maxExpirationDuration);
    [self updateExpiresAt];
}

- (void)setExpireStartedAt:(uint64_t)expireStartedAt
{
    if (_expireStartedAt != 0 && _expireStartedAt < expireStartedAt) {
        DDLogDebug(@"%@ in %s ignoring later startedAt time", self.logTag, __PRETTY_FUNCTION__);
        return;
    }
    
    uint64_t now = [NSDate ows_millisecondTimeStamp];
    if (expireStartedAt > now) {
        DDLogWarn(@"%@ in %s using `now` instead of future time", self.logTag, __PRETTY_FUNCTION__);
    }
    
    _expireStartedAt = MIN(now, expireStartedAt);
    [self updateExpiresAt];
}

//  TODO: check This method will be called after every insert and update, so it needs to be cheap.
- (BOOL)shouldStartExpireTimer
{
    if (self.hasPerConversationExpirationStarted) {
        // Expiration already started.
        return YES;
    }
    
    return self.hasPerConversationExpiration;
}

// TODO: a downloaded media doesn't start counting until download is complete.
- (void)updateExpiresAt
{
    if (self.hasPerConversationExpirationStarted) {
        _expiresAt = _expireStartedAt + _expiresInSeconds * 1000;
    } else {
        _expiresAt = 0;
    }
}

#pragma mark - Attachments

- (BOOL)hasAttachments
{
    return self.attachmentIds ? (self.attachmentIds.count > 0) : NO;
}

//GRDB-Kris--

- (TSAttachment *)firstBodyAttachmentWithTransaction:(SDSAnyReadTransaction *)transaction
{
    // Note: attachmentIds vs. allAttachmentIds
    if(!DTParamsUtils.validateArray(self.attachmentIds)){
        return nil;
    }
    return [TSAttachment anyFetchWithUniqueId:self.attachmentIds.firstObject transaction:transaction];
    
}



- (nullable TSAttachment *)attachmentWithTransaction:(SDSAnyReadTransaction *)transaction
{
    BOOL hasForwardAttachment = NO;//单条转发附件展示，多条暂不处理
    if (self.isSingleForward) {
        hasForwardAttachment = self.combinedForwardingMessage.subForwardingMessages.firstObject.forwardingAttachmentIds.count == 1;
    }
    if (!self.hasAttachments && !hasForwardAttachment) {
        return nil;
    }
    
    if (self.hasAttachments) {
        OWSAssertDebug(self.attachmentIds.count >= 1);
        return [self firstBodyAttachmentWithTransaction:transaction];
    }
    
    if (hasForwardAttachment) {
        NSString *forwardAttactmentId = self.combinedForwardingMessage.subForwardingMessages.firstObject.forwardingAttachmentIds.firstObject;
        return [TSAttachment anyFetchWithUniqueId:forwardAttactmentId transaction:transaction];;
    }
    
    return nil;
}

- (NSString *)debugDescription
{
    if ([self hasAttachments] && self.body.length > 0) {
        NSString *attachmentId = self.attachmentIds[0];
        return [NSString
                stringWithFormat:@"Media Message with attachmentId: %@ and caption: '%@'", attachmentId, self.body];
    } else if ([self hasAttachments]) {
        NSString *attachmentId = self.attachmentIds[0];
        return [NSString stringWithFormat:@"Media Message with attachmentId: %@", attachmentId];
    } else {
        return [NSString stringWithFormat:@"%@ with body: %@", [self class], self.body];
    }
}

// TODO: This method contains view-specific logic and probably belongs in NotificationsManager, not in SSK.
- (NSString *)previewTextWithTransaction:(SDSAnyReadTransaction *)transaction
{
    if(self.messageModeType == TSMessageModeTypeConfidential){
        return [NSString stringWithFormat:@"%@",Localized(@"MESSAGE_PREVIEW_TYPE_CONFIDENTIAL",
                                                                        @"A label for conversations with blocked users.")];
    }
    
    if (self.contactShare) {
        return Localized(@"MESSAGE_PREVIEW_TYPE_CONTACT_CARD", @"");
    }
    if (self.combinedForwardingMessage) {
        return Localized(@"MESSAGE_PREVIEW_TYPE_HISTORY", @"");
    }
    
    NSString *_Nullable attachmentDescription = nil;
    if ([self hasAttachments]) {
        //MARK GRDB YAP business yap Done!
        TSAttachment *attachment = [self firstBodyAttachmentWithTransaction:transaction];
        if (![attachment isKindOfClass:[TSAttachment class]]) {
            return Localized(@"QUOTED_REPLY_TYPE_ATTACHMENT", nil);
        }
        if ([OWSMimeTypeOversizeTextMessage isEqualToString:attachment.contentType]) {
            // Handle oversize text attachments.
            //            if ([attachment isKindOfClass:[TSAttachmentStream class]]) {
            //                TSAttachmentStream *attachmentStream = (TSAttachmentStream *)attachment;
            //                NSData *_Nullable data = [NSData dataWithContentsOfFile:attachmentStream.filePath];
            //                if (data) {
            //                    NSString *_Nullable text = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
            //                    if (text) {
            //                        return text.filterStringForDisplay;
            //                    }
            //                }
            //            }
            return self.body && self.body.length > 0 ? self.body : Localized(@"QUOTED_REPLY_TYPE_ATTACHMENT", nil);
        } else if (attachment) {
            attachmentDescription = attachment.description;
        } else {
            attachmentDescription = Localized(@"UNKNOWN_ATTACHMENT_LABEL",
                                              @"In Inbox view, last message label for thread with corrupted attachment.");
        }
    }
    
    NSString *_Nullable bodyDescription = nil;
    if (self.body.length > 0) {
        bodyDescription = self.body;
        if (self.cardUniqueId.length) {
            DTCardMessageEntity *latestCard = [DTCardMessageEntity anyFetchWithUniqueId:self.cardUniqueId
                                                                            transaction:transaction];
            if(latestCard && latestCard.version > self.card.version){
                bodyDescription = latestCard.content;
            }
        }
    }
    
    if (attachmentDescription.length > 0 && bodyDescription.length > 0) {
        // Attachment with caption.
        if ([CurrentAppContext() isRTL]) {
            return [bodyDescription stringByAppendingString:attachmentDescription];
        } else {
            return [attachmentDescription stringByAppendingString:bodyDescription];
        }
    } else if (bodyDescription.length > 0) {
        // 如果是卡片消息，预览时移除 markdown 格式
        if (self.isCardMessage) {
            NSString *removedStyleBody = [bodyDescription removeMarkdownStyle];
            return removedStyleBody;
        } else {
            return bodyDescription;
        }
    } else if (attachmentDescription.length > 0) {
        return attachmentDescription;
    } else {
        OWSLogDebug(@"%@ message has neither body nor attachment.", self.logTag);
        // TODO: We should do better here.
        return @"";
    }
}

- (void)anyDidRemoveWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyDidRemoveWithTransaction:transaction];
    
    //    [self removeAllAttachmentsWithTransaction:transaction];
    //
    //    [self removeAllReactionsWithTransaction:transaction];
    
    
    [self removeAllAttachmentsIfNeedWithTransaction:transaction];
    
}

- (void)removeAllAttachmentsIfNeedWithTransaction:(SDSAnyWriteTransaction *)transaction {
    // 如果当前消息正在被 pin，不删除附件内容，因为 pin 消息和原始消息共用一份附件
    if (self.pinId && self.pinId.length > 0) {
        return;
    }
    
    for (NSString *attachmentId in self.attachmentIds) {
        // We need to fetch each attachment, since [TSAttachment removeWithTransaction:] does important work.
        TSAttachment *_Nullable attachment =
        [TSAttachment anyFetchWithUniqueId:attachmentId transaction:transaction];
        if (!attachment) {
            OWSLogError(@"%@ couldn't load interaction's attachment for deletion.", self.logTag);
            continue;
        }
        [attachment anyRemoveWithTransaction:transaction];
    };
    
    for (NSString *attachmentId in self.quotedMessage.thumbnailAttachmentStreamIds) {
        TSAttachment *_Nullable attachment = [TSAttachment anyFetchWithUniqueId:attachmentId transaction:transaction];
        if (!attachment) {
            OWSLogError(@"%@ couldn't load interaction's attachment for deletion.", self.logTag);
            continue;
        }
        [attachment anyRemoveWithTransaction:transaction];
    }
    
    for (NSString *attachmentId in self.combinedForwardingMessage.allForwardingAttachmentIds) {
        TSAttachment *_Nullable attachment = [TSAttachment anyFetchWithUniqueId:attachmentId transaction:transaction];
        if (!attachment) {
            OWSLogError(@"%@ couldn't load interaction's attachment for deletion.", self.logTag);
            continue;
        }
        [attachment anyRemoveWithTransaction:transaction];
    };
    
    if (self.contactShare.avatarAttachmentId) {
        [self.contactShare removeAvatarAttachmentWithTransaction:transaction];
    }
}

- (BOOL)hasPerConversationExpiration
{
    return self.expiresInSeconds > 0;
}

- (BOOL)hasPerConversationExpirationStarted
{
    return _expireStartedAt > 0 && _expiresInSeconds > 0;
}

- (uint64_t)timestampForSorting
{
    return self.serverTimestamp ? self.serverTimestamp : self.timestamp;
}

- (BOOL)shouldUseReceiptDateForSorting
{
    return NO;
}

- (nullable NSString *)body
{
    return _body.filterStringForDisplay;
}

- (void)setQuotedMessageThumbnailAttachmentStream:(TSAttachmentStream *)attachmentStream
{
    OWSAssertDebug([attachmentStream isKindOfClass:[TSAttachmentStream class]]);
    OWSAssertDebug(self.quotedMessage);
    OWSAssertDebug(self.quotedMessage.quotedAttachments.count == 1);
    
    [self.quotedMessage setThumbnailAttachmentStream:attachmentStream];
}

#pragma mark - Update With... Methods

- (void)updateWithExpireStartedAt:(uint64_t)expireStartedAt transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(expireStartedAt > 0);
    
    [self anyUpdateMessageWithTransaction:transaction
                                    block:^(TSMessage * message) {
        [message setExpireStartedAt:expireStartedAt];
    }];
    
}

- (void)updateStoredShouldStartExpireTimer
{
    _storedShouldStartExpireTimer = [self shouldStartExpireTimer];
}

#pragma mark - hook

- (void)anyWillInsertWithTransaction:(SDSAnyWriteTransaction *)transaction{
    
    [super anyWillInsertWithTransaction:transaction];
    
    [self updateStoredShouldStartExpireTimer];
    
}

- (OWSDetailMessageType)detailMessageType {
    if(self.combinedForwardingMessage && self.combinedForwardingMessage.subForwardingMessages && self.combinedForwardingMessage.subForwardingMessages.count >= 1){
        return OWSDetailMessageTypeForward;
    } else if ([self isContactShareMessage]) {
        return OWSDetailMessageTypeContact;
    } else if ([self isRecalMessage]) {
        return OWSDetailMessageTypeRecall;
    } else if ([self isReactionMessage]) {
        return OWSDetailMessageTypeReaction;
    } else if (self.card){
        return OWSDetailMessageTypeCard;
    } else {
        return OWSDetailMessageTypeUnknow;
    }
}
#pragma mark - util

- (BOOL)isTextMessage{
    if((self.body.length &&
        self.attachmentIds.count == 0 &&
        !self.quotedMessage &&
        !self.combinedForwardingMessage &&
        !self.contactShare &&
        !self.recall &&
        !self.isReactionMessage) ||
       (self.body.length && self.quotedMessage) ||
       (self.body.length && self.attachmentIds.count)){
        return YES;
    }
    return NO;
}

- (BOOL)isContactShareMessage {
    if(!self.body.length &&
       self.contactShare){
        return YES;
    }
    return NO;
}

- (BOOL)isSingleForward {
    if (self.combinedForwardingMessage && self.combinedForwardingMessage.subForwardingMessages && self.combinedForwardingMessage.subForwardingMessages.count == 1) {
        return YES;
    }
    return NO;
}

- (BOOL)isMultiForward {
    if (self.combinedForwardingMessage && self.combinedForwardingMessage.subForwardingMessages && self.combinedForwardingMessage.subForwardingMessages.count > 1) {
        return YES;
    }
    return NO;
}

- (BOOL)isPinned {
    
    return self.pinId && self.pinId.length > 0;
}

- (BOOL)isPinMessage {
    
    return NO;
}

- (BOOL)isRecalMessage {
    return self.recall;
}

- (BOOL)isReactionMessage {
    
    return self.reactionMessage != nil;
}

- (BOOL)isCardMessage {
    return DTParamsUtils.validateString(self.cardUniqueId);
}

- (BOOL)isConfidentialMessage {
    return self.messageModeType == TSMessageModeTypeConfidential;
}

- (nullable DTCardMessageEntity *)card {
    if(!_card.grdbId){
        [_card updateRowId:0];
    }
    return _card;
}

- (void)updateCardWithCard:(DTCardMessageEntity *)newCard {
    self.card = newCard;
    self.body = newCard.content;
}

@end

NS_ASSUME_NONNULL_END
