//
//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.
//

#import "TSOutgoingMessage.h"
#import <SignalCoreKit/NSDate+OWS.h>
#import "NSString+SSK.h"
#import "OWSContact.h"
#import "OWSMessageSender.h"
#import "OWSOutgoingSyncMessage.h"
//
#import "SignalRecipient.h"
#import "TSAccountManager.h"
#import "TSAttachmentStream.h"
#import "TSContactThread.h"
#import "TSGroupThread.h"
#import "TSQuotedMessage.h"
#import "DTCombinedForwardingMessage.h"
#import "TextSecureKitEnv.h"
//
//
#import "OWSDevice.h"
#import "SecurityUtils.h"
#import "DTParamsBaseUtils.h"
//
#import <TTServiceKit/TTServiceKit-Swift.h>
#import "DTGroupConfig.h"
#import "OWSDevice.h"
#import "DTMention.h"

NS_ASSUME_NONNULL_BEGIN

NSString *const kTSOutgoingMessageSentRecipientAll = @"kTSOutgoingMessageSentRecipientAll";

NSString *NSStringForOutgoingMessageState(TSOutgoingMessageState value)
{
    switch (value) {
        case TSOutgoingMessageStateSending:
            return @"TSOutgoingMessageStateSending";
        case TSOutgoingMessageStateFailed:
            return @"TSOutgoingMessageStateFailed";
        case TSOutgoingMessageStateSent_OBSOLETE:
            return @"TSOutgoingMessageStateSent_OBSOLETE";
        case TSOutgoingMessageStateDelivered_OBSOLETE:
            return @"TSOutgoingMessageStateDelivered_OBSOLETE";
        case TSOutgoingMessageStateSent:
            return @"TSOutgoingMessageStateSent";
    }
}

NSString *NSStringForOutgoingMessageRecipientState(OWSOutgoingMessageRecipientState value)
{
    switch (value) {
        case OWSOutgoingMessageRecipientStateFailed:
            return @"OWSOutgoingMessageRecipientStateFailed";
        case OWSOutgoingMessageRecipientStateSending:
            return @"OWSOutgoingMessageRecipientStateSending";
        case OWSOutgoingMessageRecipientStateSkipped:
            return @"OWSOutgoingMessageRecipientStateSkipped";
        case OWSOutgoingMessageRecipientStateSent:
            return @"OWSOutgoingMessageRecipientStateSent";
    }
}

@interface TSOutgoingMessageRecipientState ()

@end

#pragma mark -

@implementation TSOutgoingMessageRecipientState

@end

#pragma mark -

@interface TSOutgoingMessage ()

@property (atomic) BOOL hasSyncedTranscript;
@property (atomic) NSString *customMessage;
@property (atomic) NSString *mostRecentFailureText;
@property (atomic) BOOL isFromLinkedDevice;
@property (atomic) TSGroupMetaMessage groupMetaMessage;

@property (nonatomic, readonly) TSOutgoingMessageState storedMessageState;

@end

#pragma mark -

@implementation TSOutgoingMessage

- (nullable instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];
    
    if (self) {
        //        if (!_attachmentFilenameMap) {
        //            _attachmentFilenameMap = [NSMutableDictionary new];
        //        }
        
        if (!self.recipientStateMap) {
            //            [self migrateRecipientStateMapWithCoder:coder];
            OWSAssertDebug(self.recipientStateMap);
        }
    }
    
    return self;
}

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
        associatedUniqueThreadId:(NSString *)associatedUniqueThreadId
                notifySequenceId:(uint64_t)notifySequenceId
             receivedAtTimestamp:(uint64_t)receivedAtTimestamp
                      sequenceId:(uint64_t)sequenceId
                 serverTimestamp:(uint64_t)serverTimestamp
                       timestamp:(uint64_t)timestamp
                  uniqueThreadId:(NSString *)uniqueThreadId
                       atPersons:(nullable NSString *)atPersons
                   attachmentIds:(NSArray<NSString *> *)attachmentIds
                            body:(nullable NSString *)body
                            card:(nullable DTCardMessageEntity *)card
                    cardUniqueId:(nullable NSString *)cardUniqueId
                     cardVersion:(unsigned int)cardVersion
       combinedForwardingMessage:(nullable DTCombinedForwardingMessage *)combinedForwardingMessage
                    contactShare:(nullable OWSContact *)contactShare
                        editable:(BOOL)editable
                   envelopSource:(nullable NSString *)envelopSource
                 expireStartedAt:(uint64_t)expireStartedAt
                       expiresAt:(uint64_t)expiresAt
                expiresInSeconds:(unsigned int)expiresInSeconds
                 isPinnedMessage:(BOOL)isPinnedMessage
                        mentions:(nullable NSArray<DTMention *> *)mentions
                 messageModeType:(TSMessageModeType)messageModeType
                           pinId:(nullable NSString *)pinId
                   quotedMessage:(nullable TSQuotedMessage *)quotedMessage
                     reactionMap:(nullable NSDictionary<NSString *,NSArray<DTReactionSource *> *> *)reactionMap
                 reactionMessage:(nullable DTReactionMessage *)reactionMessage
                          recall:(nullable DTRecallMessage *)recall
    storedShouldStartExpireTimer:(BOOL)storedShouldStartExpireTimer
                translateMessage:(nullable DTTranslateMessage *)translateMessage
              whisperMessageType:(TSWhisperMessageType)whisperMessageType
                   customMessage:(NSString *)customMessage
                   groupChatMode:(TSGroupChatMode)groupChatMode
                groupMetaMessage:(TSGroupMetaMessage)groupMetaMessage
             hasSyncedTranscript:(BOOL)hasSyncedTranscript
              isFromLinkedDevice:(BOOL)isFromLinkedDevice
                  isVoiceMessage:(BOOL)isVoiceMessage
           mostRecentFailureText:(NSString *)mostRecentFailureText
                      rapidFiles:(NSArray<DTRapidFile *> *)rapidFiles
               recipientStateMap:(nullable NSDictionary<NSString *,TSOutgoingMessageRecipientState *> *)recipientStateMap
                  sourceDeviceId:(unsigned int)sourceDeviceId
              storedMessageState:(TSOutgoingMessageState)storedMessageState
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId
          associatedUniqueThreadId:associatedUniqueThreadId
                  notifySequenceId:notifySequenceId
               receivedAtTimestamp:receivedAtTimestamp
                        sequenceId:sequenceId
                   serverTimestamp:serverTimestamp
                         timestamp:timestamp
                    uniqueThreadId:uniqueThreadId
                         atPersons:atPersons
                     attachmentIds:attachmentIds
                              body:body
                              card:card
                      cardUniqueId:cardUniqueId
                       cardVersion:cardVersion
         combinedForwardingMessage:combinedForwardingMessage
                      contactShare:contactShare
                          editable:editable
                     envelopSource:envelopSource
                   expireStartedAt:expireStartedAt
                         expiresAt:expiresAt
                  expiresInSeconds:expiresInSeconds
                   isPinnedMessage:isPinnedMessage
                          mentions:mentions
                   messageModeType:messageModeType
                             pinId:pinId
                     quotedMessage:quotedMessage
                       reactionMap:reactionMap
                   reactionMessage:reactionMessage
                            recall:recall
      storedShouldStartExpireTimer:storedShouldStartExpireTimer
                  translateMessage:translateMessage
                whisperMessageType:whisperMessageType];

    if (!self) {
        return self;
    }

    _customMessage = customMessage;
    _groupChatMode = groupChatMode;
    _groupMetaMessage = groupMetaMessage;
    _hasSyncedTranscript = hasSyncedTranscript;
    _isFromLinkedDevice = isFromLinkedDevice;
    _isVoiceMessage = isVoiceMessage;
    _mostRecentFailureText = mostRecentFailureText;
    _rapidFiles = rapidFiles;
    _recipientStateMap = recipientStateMap;
    _sourceDeviceId = sourceDeviceId;
    _storedMessageState = storedMessageState;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

+ (instancetype)outgoingMessageInThread:(nullable TSThread *)thread
                            messageBody:(nullable NSString *)body
                              atPersons:(nullable NSString *)atPersons
                               mentions:(nullable NSArray <DTMention *> *)mentions
                           attachmentId:(nullable NSString *)attachmentId
{
    return [self outgoingMessageInThread:thread
                             messageBody:body
                               atPersons:atPersons
                                mentions:mentions
                            attachmentId:attachmentId
                        expiresInSeconds:0
                           quotedMessage:nil
                       forwardingMessage:nil];
}

+ (instancetype)outgoingMessageInThread:(nullable TSThread *)thread
                            messageBody:(nullable NSString *)body
                              atPersons:(nullable NSString *)atPersons
                               mentions:(nullable NSArray <DTMention *> *)mentions
                           attachmentId:(nullable NSString *)attachmentId
                       expiresInSeconds:(uint32_t)expiresInSeconds
{
    return [self outgoingMessageInThread:thread
                             messageBody:body
                               atPersons:atPersons
                                mentions:mentions
                            attachmentId:attachmentId
                        expiresInSeconds:expiresInSeconds
                           quotedMessage:nil
                       forwardingMessage:nil];
}

+ (instancetype)outgoingMessageInThread:(nullable TSThread *)thread
                            messageBody:(nullable NSString *)body
                              atPersons:(nullable NSString *)atPersons
                               mentions:(nullable NSArray <DTMention *> *)mentions
                           attachmentId:(nullable NSString *)attachmentId
                       expiresInSeconds:(uint32_t)expiresInSeconds
                          quotedMessage:(nullable TSQuotedMessage *)quotedMessage
                      forwardingMessage:(nullable DTCombinedForwardingMessage *)forwardingMessage
{
    NSMutableArray<NSString *> *attachmentIds = [NSMutableArray new];
    if (attachmentId) {
        [attachmentIds addObject:attachmentId];
    }
    
    return [[TSOutgoingMessage alloc] initOutgoingMessageWithTimestamp:[NSDate ows_millisecondTimeStamp]
                                                              inThread:thread
                                                           messageBody:body
                                                             atPersons:atPersons
                                                              mentions:mentions
                                                         attachmentIds:attachmentIds
                                                      expiresInSeconds:expiresInSeconds
                                                       expireStartedAt:0
                                                        isVoiceMessage:NO
                                                      groupMetaMessage:TSGroupMessageUnspecified
                                                         quotedMessage:quotedMessage
                                                     forwardingMessage:forwardingMessage
                                                          contactShare:nil];
}

+ (instancetype)outgoingMessageInThread:(nullable TSThread *)thread
                       groupMetaMessage:(TSGroupMetaMessage)groupMetaMessage
                              atPersons:(nullable NSString *)atPersons
                               mentions:(nullable NSArray <DTMention *> *)mentions
                       expiresInSeconds:(uint32_t)expiresInSeconds;
{
    return [[TSOutgoingMessage alloc] initOutgoingMessageWithTimestamp:[NSDate ows_millisecondTimeStamp]
                                                              inThread:thread
                                                           messageBody:nil
                                                             atPersons:atPersons
                                                              mentions:mentions
                                                         attachmentIds:[NSMutableArray new]
                                                      expiresInSeconds:expiresInSeconds
                                                       expireStartedAt:0
                                                        isVoiceMessage:NO
                                                      groupMetaMessage:groupMetaMessage
                                                         quotedMessage:nil
                                                     forwardingMessage:nil
                                                          contactShare:nil];
}

- (instancetype)initOutgoingMessageWithTimestamp:(uint64_t)timestamp
                                        inThread:(nullable TSThread *)thread
                                     messageBody:(nullable NSString *)body
                                       atPersons:(nullable NSString *)atPersons
                                        mentions:(nullable NSArray <DTMention *> *)mentions
                                   attachmentIds:(NSMutableArray<NSString *> *)attachmentIds
                                expiresInSeconds:(uint32_t)expiresInSeconds
                                 expireStartedAt:(uint64_t)expireStartedAt
                                  isVoiceMessage:(BOOL)isVoiceMessage
                                groupMetaMessage:(TSGroupMetaMessage)groupMetaMessage
                                   quotedMessage:(nullable TSQuotedMessage *)quotedMessage
                               forwardingMessage:(nullable DTCombinedForwardingMessage *)forwardingMessage
                                    contactShare:(nullable OWSContact *)contactShare
{
    self = [super initMessageWithTimestamp:timestamp
                           serverTimestamp:timestamp // outgoingmessage 默认 serverTimestamp 为当前时间，发送成功时会做修正
                                sequenceId:0
                          notifySequenceId:0
                                  inThread:thread
                                  authorId:[TSAccountManager localNumber]
                                  deviceId:[OWSDevice currentDeviceId]
                               messageBody:body
                                 atPersons:atPersons
                                  mentions:mentions
                             attachmentIds:attachmentIds
                          expiresInSeconds:expiresInSeconds
                           expireStartedAt:expireStartedAt
                             quotedMessage:quotedMessage
                         forwardingMessage:forwardingMessage
                              contactShare:contactShare];
    if (!self) {
        return self;
    }
    
    _hasSyncedTranscript = NO;
    
    if ([thread isKindOfClass:TSGroupThread.class]) {
        // Unless specified, we assume group messages are "Delivery" i.e. normal messages.
        if (groupMetaMessage == TSGroupMessageUnspecified) {
            _groupMetaMessage = TSGroupMessageDeliver;
        } else {
            _groupMetaMessage = groupMetaMessage;
        }
    } else {
        OWSAssertDebug(groupMetaMessage == TSGroupMessageUnspecified);
        // Specifying a group meta message only makes sense for Group threads
        _groupMetaMessage = TSGroupMessageUnspecified;
    }
    
    _isVoiceMessage = isVoiceMessage;
    
    //    _attachmentFilenameMap = [NSMutableDictionary new];
    
    // New outgoing messages should immediately determine their
    // recipient list from current thread state.
    [self updateRecipientStateMapWithThread:thread state:OWSOutgoingMessageRecipientStateSending];
    
    return self;
}

- (void)updateRecipientStateMapWithThread:(TSThread *)thread state:(OWSOutgoingMessageRecipientState)state {
    NSMutableDictionary<NSString *, TSOutgoingMessageRecipientState *> *recipientStateMap = [NSMutableDictionary new];
    NSArray<NSString *> *recipientIds;
    NSString *_Nullable localNumber = [TSAccountManager localNumber];
    if ([self isKindOfClass:[OWSOutgoingSyncMessage class]]) {
        OWSAssertDebug(localNumber);
        if(DTParamsUtils.validateString(localNumber)){
            recipientIds = @[
                localNumber,
            ];
        }
    } else {
        recipientIds = [thread recipientIdentifiers];
        // Fix 修复一个人的群组，无法撤回消息的问题
        if ([thread isKindOfClass:TSGroupThread.class]
            && ((!recipientIds || recipientIds.count == 0))
            && DTParamsUtils.validateString(localNumber)) {
            recipientIds = @[
                localNumber,
            ];
        }
    }
    for (NSString *recipientId in recipientIds) {
        TSOutgoingMessageRecipientState *recipientState = [TSOutgoingMessageRecipientState new];
        recipientState.state = state;
        recipientStateMap[recipientId] = recipientState;
    }
    self.recipientStateMap = [recipientStateMap copy];
}

- (TSOutgoingMessageState)messageState
{
    if (self.isPinnedMessage) {
        return TSOutgoingMessageStateSent;
    }
    TSOutgoingMessageState newMessageState =
    [TSOutgoingMessage messageStateForRecipientStates:self.recipientStateMap.allValues];
    return newMessageState;
}

- (BOOL)wasDeliveredToAnyRecipient
{
    if ([self deliveredRecipientIds].count > 0) {
        return YES;
    }
    return NO;
}

+ (TSOutgoingMessageState)messageStateForRecipientStates:(NSArray<TSOutgoingMessageRecipientState *> *)recipientStates
{
    OWSAssertDebug(recipientStates);
    
    // If there are any "sending" recipients, consider this message "sending".
    BOOL hasFailed = NO;
    for (TSOutgoingMessageRecipientState *recipientState in recipientStates) {
        if (recipientState.state == OWSOutgoingMessageRecipientStateSending) {
            return TSOutgoingMessageStateSending;
        } else if (recipientState.state == OWSOutgoingMessageRecipientStateFailed) {
            hasFailed = YES;
        }
    }
    
    // If there are any "failed" recipients, consider this message "failed".
    if (hasFailed) {
        return TSOutgoingMessageStateFailed;
    }
    
    // Otherwise, consider the message "sent".
    //
    // NOTE: This includes messages with no recipients.
    return TSOutgoingMessageStateSent;
}

- (BOOL)shouldBeSaved
{
    
    if (self.groupChatMode == TSGroupChatModePin) {
        return NO;
    }
    
    if (self.isReactionMessage) {
        return NO;
    }
    
    if (self.groupMetaMessage == TSGroupMessageDeliver || self.groupMetaMessage == TSGroupMessageUnspecified) {
        return YES;
    }
    
    return NO;
}


- (BOOL)shouldStartExpireTimer
{
    // It's not clear if we should wait until _all_ recipients have reached "sent or later"
    // (which could never occur if one group member is unregistered) or only wait until
    // the first recipient has reached "sent or later" (which could cause partially delivered
    // messages to expire).  For now, we'll do the latter.
    //
    // TODO: Revisit this decision.
    
    if (!self.hasPerConversationExpiration) {
        return NO;
    } else if (self.messageState == TSOutgoingMessageStateSent) {
        return YES;
    } else {
        if (self.expireStartedAt > 0) {
            // Our initial migration to populate the recipient state map was incomplete. It's since been
            // addressed, but it's possible there are edge cases where a previously sent message would
            // no longer be considered sent.
            // So here we take extra care not to stop any expiration that had previously started.
            // This can also happen under normal cirumstances with an outgoing group message.
            OWSLogWarn(@"%@ expiration previously started", self.logTag);
            
            return YES;
        }
        
        return NO;
    }
}

- (BOOL)isSilent
{
    if (self.groupMetaMessage == TSGroupMessageDeliver || self.groupMetaMessage == TSGroupMessageUnspecified) {
        return NO;
    }
    return YES;
}

- (OWSInteractionType)interactionType
{
    return OWSInteractionType_OutgoingMessage;
}

- (NSArray<NSString *> *)recipientIds
{
    return self.recipientStateMap.allKeys;
}

- (NSArray<NSString *> *)sendingRecipientIds
{
    NSMutableArray<NSString *> *result = [NSMutableArray new];
    for (NSString *recipientId in self.recipientStateMap) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientStateMap[recipientId];
        if (recipientState.state == OWSOutgoingMessageRecipientStateSending) {
            [result addObject:recipientId];
        }
    }
    return result;
}

- (NSArray<NSString *> *)deliveredRecipientIds
{
    NSMutableArray<NSString *> *result = [NSMutableArray new];
    for (NSString *recipientId in self.recipientStateMap) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientStateMap[recipientId];
        if (recipientState.deliveryTimestamp != nil) {
            [result addObject:recipientId];
        }
    }
    return result;
}

- (NSArray<NSString *> *)readRecipientIds
{
    NSMutableArray<NSString *> *result = [NSMutableArray new];
    for (NSString *recipientId in self.recipientStateMap) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientStateMap[recipientId];
        if (recipientState.readTimestamp != nil) {
            [result addObject:recipientId];
        }
    }
    return result;
}

- (NSUInteger)sentRecipientsCount
{
    return [self.recipientStateMap.allValues
            filteredArrayUsingPredicate:[NSPredicate
                                         predicateWithBlock:^BOOL(TSOutgoingMessageRecipientState *recipientState,
                                                                  NSDictionary<NSString *, id> *_Nullable bindings) {
        return recipientState.state == OWSOutgoingMessageRecipientStateSent;
    }]]
        .count;
}

- (nullable TSOutgoingMessageRecipientState *)recipientStateForRecipientId:(NSString *)recipientId
{
    OWSAssertDebug(recipientId.length > 0);
    
    
    TSOutgoingMessageRecipientState *_Nullable result = self.recipientStateMap[recipientId];
    OWSAssertDebug(result);
    return [result copy];
}

#pragma mark - Update With... Methods

- (void)updateWithSendingError:(NSError *)error
{
    OWSAssertDebug(error);
    // 允许离线操作
    [DatabaseOfflineManager shared].canOfflineUpdateDatabase = true;
    
    DatabaseStorageAsyncWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *writeTransaction) {
        [self anyUpdateOutgoingMessageWithTransaction:writeTransaction
                                                block:^(TSOutgoingMessage *message) {
            // Mark any "sending" recipients as "failed."
            for (TSOutgoingMessageRecipientState *recipientState in message.recipientStateMap.allValues) {
                if (recipientState.state == OWSOutgoingMessageRecipientStateSending) {
                    recipientState.state = OWSOutgoingMessageRecipientStateFailed;
                }
            }
            [message setMostRecentFailureText:error.localizedDescription];
        }];
    });
}

- (void)updateWithAllSendingRecipientsMarkedAsFailedWithTansaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(transaction);
    
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        // Mark any "sending" recipients as "failed."
        for (TSOutgoingMessageRecipientState *recipientState in message
             .recipientStateMap.allValues) {
                 if (recipientState.state == OWSOutgoingMessageRecipientStateSending) {
                     recipientState.state = OWSOutgoingMessageRecipientStateFailed;
                 }
             }
    }];
}

- (void)updateWithAllRecipientsMarkedAsSentWithServerReceipts:(DTOutgoingMessageServerReceipts *)serverReceipts
                                                  transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(transaction);
    
    if ([self isKindOfClass:[OWSOutgoingSentMessageTranscript class]]) {
        OWSOutgoingSentMessageTranscript *syncMsg = (OWSOutgoingSentMessageTranscript *)self;
        if (!syncMsg.toNote) {
            // 非note消息不需要更新状态；
            return;
        }
    }
    
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        if (![message isKindOfClass:[TSOutgoingMessage class]]) {
            return;
        }
        
        message.serverTimestamp = serverReceipts.systemShowTimestamp;
        message.sequenceId = serverReceipts.sequenceId;
        message.notifySequenceId = serverReceipts.notifySequenceId;
        
        for (TSOutgoingMessageRecipientState *recipientState in message.recipientStateMap.allValues) {
            recipientState.state = OWSOutgoingMessageRecipientStateSent;
        }
        
        //send to note need update origin outgoing message state
        if ([self isKindOfClass:[OWSOutgoingSentMessageTranscript class]]) {
            OWSOutgoingSentMessageTranscript *syncMsg = (OWSOutgoingSentMessageTranscript *)self;
            for (TSOutgoingMessageRecipientState *recipientState in syncMsg.message.recipientStateMap.allValues) {
                recipientState.state = OWSOutgoingMessageRecipientStateSent;
            }
        }
        
    }];
    
}

- (void)updateWithMarkingAllUnsentRecipientsAsSendingWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(transaction);
    
    if (self.isReactionMessage) {
        return;
    }
    
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        // Mark any "sending" recipients as "failed."
        if ([message isKindOfClass:[TSOutgoingMessage class]]) {
            for (TSOutgoingMessageRecipientState *recipientState in message.recipientStateMap
                 .allValues) {
                     if (recipientState.state == OWSOutgoingMessageRecipientStateFailed) {
                         recipientState.state = OWSOutgoingMessageRecipientStateSending;
                     }
                 }
        }
    }];
    
}

- (void)updateWithHasSyncedTranscript:(BOOL)hasSyncedTranscript
                          transaction:(SDSAnyWriteTransaction *)transaction
{
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        [message setHasSyncedTranscript:hasSyncedTranscript];
    }];
    
}

- (void)updateWithCustomMessage:(NSString *)customMessage transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(customMessage);
    OWSAssertDebug(transaction);
    
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        [message setCustomMessage:customMessage];
    }];
}

- (void)updateWithCustomMessage:(NSString *)customMessage
{
    DatabaseStorageWrite(self.databaseStorage, ^(SDSAnyWriteTransaction *writeTransaction) {
        [self updateWithCustomMessage:customMessage transaction:writeTransaction];
    });
}

- (void)updateWithSentRecipient:(NSString *)recipientId
                 serverReceipts:(nullable DTOutgoingMessageServerReceipts *)serverReceipts
                    transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(recipientId.length > 0);
    OWSAssertDebug(transaction);
    
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        message.serverTimestamp = serverReceipts.systemShowTimestamp;
        message.sequenceId = serverReceipts.sequenceId;
        
        TSOutgoingMessageRecipientState *_Nullable recipientState
        = message.recipientStateMap[recipientId];
        if (!recipientState) {
            OWSFailDebug(@"%@ Missing recipient state for recipient: %@", self.logTag, recipientId);
            return;
        }
        recipientState.state = OWSOutgoingMessageRecipientStateSent;
    }];
}

- (void)updateWithSkippedRecipient:(NSString *)recipientId transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(recipientId.length > 0);
    OWSAssertDebug(transaction);
    
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        TSOutgoingMessageRecipientState *_Nullable recipientState
        = message.recipientStateMap[recipientId];
        if (!recipientState) {
            OWSFailDebug(@"%@ Missing recipient state for recipient: %@", self.logTag, recipientId);
            return;
        }
        recipientState.state = OWSOutgoingMessageRecipientStateSkipped;
    }];
}

- (void)updateWithDeliveredRecipient:(NSString *)recipientId
                   deliveryTimestamp:(NSNumber *_Nullable)deliveryTimestamp
                         transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(recipientId.length > 0);
    OWSAssertDebug(transaction);
    
    // If delivery notification doesn't include timestamp, use "now" as an estimate.
    if (!deliveryTimestamp) {
        deliveryTimestamp = @([NSDate ows_millisecondTimeStamp]);
    }
    
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        TSOutgoingMessageRecipientState *_Nullable recipientState
        = message.recipientStateMap[recipientId];
        if (!recipientState) {
            OWSFailDebug(@"%@ Missing recipient state for delivered recipient: %@",
                         self.logTag,
                         recipientId);
            return;
        }
        if (recipientState.state != OWSOutgoingMessageRecipientStateSent) {
            OWSLogWarn(@"%@ marking unsent message as delivered.", self.logTag);
        }
        recipientState.state = OWSOutgoingMessageRecipientStateSent;
        recipientState.deliveryTimestamp = deliveryTimestamp;
    }];
    
}

- (void)updateWithReadRecipientId:(NSString *)recipientId
                    readTimestamp:(uint64_t)readTimestamp
                      transaction:(SDSAnyReadTransaction *)transaction
{
    OWSAssertDebug(recipientId.length > 0);
    OWSAssertDebug(transaction);
    
    TSOutgoingMessageRecipientState *_Nullable recipientState
    = self.recipientStateMap[recipientId];
    
    //    TSThread *fetchedThread = [TSThread anyFetchWithUniqueId:self.uniqueThreadId transaction:transaction];
    
    if (!recipientState) {
        OWSLogError(@"%@ Missing recipient state for delivered recipient: %@",
                    self.logTag,
                    recipientId);
        return;
    }
    
    if (recipientState.state != OWSOutgoingMessageRecipientStateSent) {
        OWSLogWarn(@"%@ marking unsent message as delivered.", self.logTag);
    }
    recipientState.state = OWSOutgoingMessageRecipientStateSent;
    recipientState.readTimestamp = @(readTimestamp);
}

- (void)updateWithWasSentFromLinkedDevice
{
    // Mark any "sending" recipients as "sent."
    for (TSOutgoingMessageRecipientState *recipientState in self.recipientStateMap
         .allValues) {
             if (recipientState.state == OWSOutgoingMessageRecipientStateSending) {
                 recipientState.state = OWSOutgoingMessageRecipientStateSent;
             }
         }
    [self setIsFromLinkedDevice:YES];
}

- (void)updateWithSendingToSingleGroupRecipient:(NSString *)singleGroupRecipient
                                    transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(transaction);
    OWSAssertDebug(singleGroupRecipient.length > 0);
    
    
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        TSOutgoingMessageRecipientState *recipientState =
        [TSOutgoingMessageRecipientState new];
        recipientState.state = OWSOutgoingMessageRecipientStateSending;
        [message setRecipientStateMap:@{
            singleGroupRecipient : recipientState,
        }];
    }];
    
}

- (nullable NSNumber *)firstRecipientReadTimestamp
{
    NSNumber *result = nil;
    for (TSOutgoingMessageRecipientState *recipientState in self.recipientStateMap.allValues) {
        if (!recipientState.readTimestamp) {
            continue;
        }
        if (!result || (result.unsignedLongLongValue > recipientState.readTimestamp.unsignedLongLongValue)) {
            result = recipientState.readTimestamp;
        }
    }
    return result;
}

- (void)updateWithFakeMessageState:(TSOutgoingMessageState)messageState
                       transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(transaction);
    
    [self anyUpdateOutgoingMessageWithTransaction:transaction
                                            block:^(TSOutgoingMessage *message) {
        for (TSOutgoingMessageRecipientState *recipientState in message.recipientStateMap
             .allValues) {
                 switch (messageState) {
                     case TSOutgoingMessageStateSending:
                         recipientState.state = OWSOutgoingMessageRecipientStateSending;
                         break;
                     case TSOutgoingMessageStateFailed:
                         recipientState.state = OWSOutgoingMessageRecipientStateFailed;
                         break;
                     case TSOutgoingMessageStateSent:
                         recipientState.state = OWSOutgoingMessageRecipientStateSent;
                         break;
                     default:
                         OWSFailDebug(@"%@ unexpected message state.", self.logTag);
                         break;
                 }
             }
    }];
}
#pragma mark -

- (DSKProtoDataMessageBuilder *)dataMessageBuilder
{
    TSThread *thread = self.threadWithSneakyTransaction;
    OWSAssertDebug(thread);
    
    DSKProtoDataMessageBuilder *builder = [DSKProtoDataMessage builder];
    [builder setTimestamp:self.timestamp];
    
    if ([self.body lengthOfBytesUsingEncoding:NSUTF8StringEncoding] <= kOversizeTextMessageSizeThreshold) {
        [builder setBody:self.body];
    } else {
        //MARK: 这里不会执行，外层已做处理
        OWSFailDebug(@"%@ message body length too long.", self.logTag);
        NSString *truncatedBody = [self.body copy];
        while ([truncatedBody lengthOfBytesUsingEncoding:NSUTF8StringEncoding] > kOversizeTextMessageSizeThreshold) {
            OWSLogError(@"%@ truncating body which is too long: %lu",
                        self.logTag,
                        (unsigned long)[truncatedBody lengthOfBytesUsingEncoding:NSUTF8StringEncoding]);
            truncatedBody = [truncatedBody substringToIndex:truncatedBody.length / 2];
        }
        [builder setBody:truncatedBody];
    }
    builder.requiredProtocolVersion = DSKProtoDataMessageProtocolVersionInitial;
    
    [builder setAtPersons:self.atPersons];
    [builder setExpireTimer:self.expiresInSeconds];
    
    NSArray <DSKProtoDataMessageMention *> *dataMessageMentions = [DTMention mentionsProtoWithMentions:self.mentions];
    [builder setMentions:dataMessageMentions];
    
    // Group Messages
    BOOL attachmentWasGroupAvatar = NO;
    if ([thread isKindOfClass:[TSGroupThread class]]) {
        TSGroupThread *gThread = (TSGroupThread *)thread;
        DSKProtoGroupContextBuilder *groupBuilder = [DSKProtoGroupContext builder];
        
        switch (self.groupMetaMessage) {
            case TSGroupMessageQuit:
                [groupBuilder setType:DSKProtoGroupContextTypeQuit];
                break;
            case TSGroupMessageUpdate:
            case TSGroupMessageNew: {
                if (gThread.groupModel.groupImage != nil && self.attachmentIds.count == 1) {
                    attachmentWasGroupAvatar = YES;
                    [groupBuilder setAvatar:[TSAttachmentStream buildProtoForAttachmentId:self.attachmentIds.firstObject]];
                }
                
                [groupBuilder setMembers:gThread.groupModel.groupMemberIds];
                [groupBuilder setName:gThread.groupModel.groupName];
                [groupBuilder setType:DSKProtoGroupContextTypeUpdate];
                break;
            }
            default:
                [groupBuilder setType:DSKProtoGroupContextTypeDeliver];
                break;
        }
        [groupBuilder setId:gThread.groupModel.groupId];
        
        [builder setGroup:[groupBuilder buildAndReturnError:nil]];
    }
    
    // Message Attachments
    if (!attachmentWasGroupAvatar) {
        NSMutableArray *attachments = [NSMutableArray new];
        for (NSString *attachmentId in self.attachmentIds) {
            [attachments addObject:[TSAttachmentStream buildProtoForAttachmentId:attachmentId]];
        }
        [builder setAttachments:attachments];
    }
    
    // Quoted Reply
    DSKProtoDataMessageQuote *_Nullable dataMessageQuote = self.quotedMessageBuilder;
    if (dataMessageQuote) {
        [builder setQuote:dataMessageQuote];
    }
    
    // combine forwarding
    DSKProtoDataMessageForwardContext *_Nullable forwardingContextProto = self.combinedForwardingContextProto;
    if (forwardingContextProto) {
        [builder setForwardContext:forwardingContextProto];
        builder.requiredProtocolVersion = DSKProtoDataMessageProtocolVersionForward;
    }
    
    // Contact Share
    if (self.contactShare) {
        DSKProtoDataMessageContact *_Nullable contactProto = [OWSContacts protoForContact:self.contactShare];
        if (contactProto) {
            builder.requiredProtocolVersion = DSKProtoDataMessageProtocolVersionContact;
            [builder addContact:contactProto];
        } else {
            OWSFailDebug(@"%@ in %s contactProto was unexpectedly nil", self.logTag, __PRETTY_FUNCTION__);
        }
    }
    
    if(self.messageModeType == TSMessageModeTypeConfidential){
        builder.messageMode = DSKProtoDataMessageMessageModeConfidential;
        builder.requiredProtocolVersion = DSKProtoDataMessageProtocolVersionConfide;
    }
    
    return builder;
}

- (nullable DSKProtoDataMessageQuote *)quotedMessageBuilder
{
    if (!self.quotedMessage) {
        return nil;
    }
    TSQuotedMessage *quotedMessage = self.quotedMessage;
    
    DSKProtoDataMessageQuoteBuilder *quoteBuilder = [DSKProtoDataMessageQuote builder];
    [quoteBuilder setId:quotedMessage.timestamp];
    [quoteBuilder setAuthor:quotedMessage.authorId];
    
    BOOL hasQuotedText = NO;
    BOOL hasQuotedAttachment = NO;
    if (self.quotedMessage.body.length > 0) {
        hasQuotedText = YES;
        [quoteBuilder setText:quotedMessage.body];
    }
    
    if (quotedMessage.quotedAttachments) {
        for (OWSAttachmentInfo *attachment in quotedMessage.quotedAttachments) {
            hasQuotedAttachment = YES;
            
            DSKProtoDataMessageQuoteQuotedAttachmentBuilder *quotedAttachmentBuilder = [DSKProtoDataMessageQuoteQuotedAttachment builder];
            
            quotedAttachmentBuilder.contentType = attachment.contentType;
            quotedAttachmentBuilder.fileName = attachment.sourceFilename;
            if (attachment.thumbnailAttachmentStreamId) {
                quotedAttachmentBuilder.thumbnail =
                [TSAttachmentStream buildProtoForAttachmentId:attachment.thumbnailAttachmentStreamId];
            }
            
            DSKProtoDataMessageQuoteQuotedAttachment *quoteQuotedAttachment = [quotedAttachmentBuilder buildAndReturnError:nil];
            if (quoteQuotedAttachment) {
                [quoteBuilder addAttachments:quoteQuotedAttachment];
            }
        }
    }
    
    if (hasQuotedText || hasQuotedAttachment) {
        return [quoteBuilder buildAndReturnError:nil];
    } else {
        OWSFailDebug(@"%@ Invalid quoted message data.", self.logTag);
        return nil;
    }
}

- (nullable DSKProtoDataMessageForward *)handleCombinedForwardingMessageBuilder:(DSKProtoDataMessageForwardBuilder *)forwardingBuilder forwardingMessage:(DTCombinedForwardingMessage *)forwardingMessage {
    
    if (!forwardingMessage) {
        return nil;
    }
    
    [forwardingBuilder setId:forwardingMessage.timestamp];
    [forwardingBuilder setServerTimestamp:forwardingMessage.serverTimestamp];
    [forwardingBuilder setType:forwardingMessage.messageType];
    [forwardingBuilder setIsFromGroup:forwardingMessage.isFromGroup];
    [forwardingBuilder setAuthor:forwardingMessage.authorId];
    
    if (forwardingMessage.body.length > 0) {
        [forwardingBuilder setText:forwardingMessage.body];
    }
    
    if (forwardingMessage.card) {
        [forwardingBuilder setCard:[DTCardMessageEntity cardProtoWithEntity:forwardingMessage.card]];
    }
    
    if (DTParamsUtils.validateArray(forwardingMessage.forwardingMentions)) {
        NSArray <DSKProtoDataMessageMention *> *mentionsProto = [DTMention mentionsProtoWithMentions:forwardingMessage.forwardingMentions];
        [forwardingBuilder setMentions:mentionsProto.copy];
    }
    
    __block NSMutableArray *attachments = @[].mutableCopy;
    [self.databaseStorage readWithBlock:^(SDSAnyReadTransaction * _Nonnull transaction) {
        for (NSString *attachmentId in forwardingMessage.forwardingAttachmentIds) {
            TSAttachment *attachment = [TSAttachment anyFetchWithUniqueId:attachmentId transaction:transaction];
            if (attachment && [attachment isKindOfClass:[TSAttachment class]]) {
                DSKProtoAttachmentPointer *pointer = [attachment buildProto];
                if (pointer) {
                    [attachments addObject:pointer];
                } else {
                    OWSLogWarn(@"%@ pointer = %@ not exists",self.logTag ,attachmentId);
                }
            } else {
                OWSLogWarn(@"%@ pointer = %@ not exists",self.logTag ,attachmentId);
            }
        }
    }];
    [forwardingBuilder setAttachments:attachments.copy];
    
    [forwardingMessage.subForwardingMessages enumerateObjectsUsingBlock:^(DTCombinedForwardingMessage * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        DSKProtoDataMessageForwardBuilder *subForwardingBuilder = [DSKProtoDataMessageForward builder];
        DSKProtoDataMessageForward *subForwardProto = [self handleCombinedForwardingMessageBuilder:subForwardingBuilder forwardingMessage:obj];
        if (subForwardProto) {
            [forwardingBuilder addForwards:subForwardProto];
        }
    }];
    
    DSKProtoDataMessageForward *forwardProto = [forwardingBuilder buildAndReturnError:nil];
    
    return forwardProto;
}


- (nullable DSKProtoDataMessageForwardContext *)combinedForwardingContextProto
{
    if (!self.combinedForwardingMessage) {
        return nil;
    }
    DSKProtoDataMessageForwardContextBuilder *forwardingContextBuilder = [DSKProtoDataMessageForwardContext builder];
    
    DSKProtoDataMessageForwardBuilder *forwardingBuilder = [DSKProtoDataMessageForward builder];
    
    NSMutableArray *rapidFiles = @[].mutableCopy;
    [self.combinedForwardingMessage.rapidFiles enumerateObjectsUsingBlock:^(DTRapidFile * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        
        DSKProtoRapidFileBuilder *rapidFileBuilder = [DSKProtoRapidFile builder];
        rapidFileBuilder.rapidHash = obj.rapidHash;
        if (obj.authorizedId) {
            [rapidFileBuilder setAuthorizedID:obj.authorizedId];
        }
        
        DSKProtoRapidFile *rapidFileProto = [rapidFileBuilder buildAndReturnError:nil];
        if (rapidFileProto) {
            [rapidFiles addObject:rapidFileProto];
        }
    }];
    
    NSArray<DSKProtoDataMessageForward *> * forwards = [self handleCombinedForwardingMessageBuilder:forwardingBuilder forwardingMessage:self.combinedForwardingMessage].forwards;
    
    if (forwards) {
        [forwardingContextBuilder setForwards:forwards];
    }
    
    if (rapidFiles.count) {
        [forwardingContextBuilder setRapidFiles:rapidFiles.copy];
    }
    
    return [forwardingContextBuilder buildAndReturnError:nil];
}

// recipientId is nil when building "sent" sync messages for messages sent to groups.
- (DSKProtoDataMessage *)buildDataMessage:(NSString *_Nullable)recipientId
{
    OWSAssertDebug(self.threadWithSneakyTransaction);
    DSKProtoDataMessageBuilder *builder = [self dataMessageBuilder];
    // TODO: proto check
    //    [builder addLocalProfileKeyIfNecessary:self.threadWithSneakyTransaction recipientId:recipientId];
    
    return [builder buildAndReturnError:nil];
}

- (nullable NSData *)buildPlainTextData:(SignalRecipient *)recipient
{
    DSKProtoContentBuilder *contentBuilder = [DSKProtoContent builder];
    contentBuilder.dataMessage = [self buildDataMessage:recipient.recipientId];
    
    NSError *error;
    NSData *data = [contentBuilder buildSerializedDataAndReturnError:&error];
    if (error) {
        OWSLogError(@"%@ error:%@", self.logTag, error);
    }
    
    return data;
}
- (nullable NSData *)buildClientNotifyData:(SignalRecipient *)recipient
{
    return nil;
}

- (BOOL)shouldSyncTranscript
{
    return !self.hasSyncedTranscript;
}

- (NSString *)statusDescription
{
    NSMutableString *result = [NSMutableString new];
    [result appendFormat:@"[status: %@", NSStringForOutgoingMessageState(self.messageState)];
    for (NSString *recipientId in self.recipientStateMap) {
        TSOutgoingMessageRecipientState *recipientState = self.recipientStateMap[recipientId];
        [result appendFormat:@", %@: %@", recipientId, NSStringForOutgoingMessageRecipientState(recipientState.state)];
    }
    [result appendString:@"]"];
    return [result copy];
}

- (NSString *)collapseId{
    if(self.timestamp <= 0 &&
       [OWSDevice currentDeviceId] <= 0 &&
       ![TSAccountManager sharedInstance].localNumber.length){
        return @"";
    }
    NSString *inputString = [NSString stringWithFormat:@"%lld%@%u",self.timestamp, [TSAccountManager sharedInstance].localNumber, self.sourceDeviceId?:[OWSDevice currentDeviceId]];
    
    return [SecurityUtils getMd5WithString:inputString];
}

//- (BOOL)recipientsContainsBot{
//    __block BOOL containsBot = NO;
//    [self.recipientIds enumerateObjectsUsingBlock:^(NSString * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
//        if(DTParamsUtils.validateString(obj)){
//            NSString *numberString = [obj stringByReplacingOccurrencesOfString:@"+"withString:@""];
//            if(numberString.length <= 6){
//                containsBot = YES;
//                *stop = YES;
//            }
//        }
//    }];
//    return containsBot;
//}

+ (nullable instancetype)findSyncMessageWithTimestamp:(uint64_t)timestamp
                                          transaction:(SDSAnyWriteTransaction *)transaction
{
    OWSAssertDebug(transaction);
    
    NSError *error;
    NSArray<TSOutgoingMessage *> *messages = (NSArray<TSOutgoingMessage *> *)[InteractionFinder
                                                                              interactionsWithTimestamp:timestamp
                                                                              filter:^(TSInteraction *interaction) {
        return [interaction isKindOfClass:[TSOutgoingMessage class]];
    }
                                                                              transaction:transaction
                                                                              error:&error];
    if (error != nil) {
        OWSFailDebug(@"Error loading interactions: %@", error);
        return nil;
    }
    
    if (messages.count < 1) {
        // This message may have disappeared.
        OWSLogError(@"No matching message with timestamp: %llu.", timestamp);
        return nil;
    }
    
    return messages.firstObject;
}

- (void)anyWillInsertWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyWillInsertWithTransaction:transaction];
    
    _storedMessageState = self.messageState;
}


- (void)anyWillUpdateWithTransaction:(SDSAnyWriteTransaction *)transaction
{
    [super anyWillUpdateWithTransaction:transaction];
    
    _storedMessageState = self.messageState;
}

- (TSGroupChatMode)groupChatMode{
    if(_groupChatMode == TSGroupChatModeEndToEnds){
        
        //        if(self.thread.isLargeGroupThread){
        //            _groupChatMode = TSGroupChatModeEndToServer;
        //        }
        
        _groupChatMode = TSGroupChatModeEndToEnds;
    }
    return _groupChatMode;
}

- (void)resetUniqueIdWithTransaction:(SDSAnyWriteTransaction *)transaction {
    NSString *localNumber = [TSAccountManager.sharedInstance localNumberWithTransaction:transaction];
    self.uniqueId = [[self class] generateUniqueIdWithAuthorId:localNumber
                                                      deviceId:self.sourceDeviceId
                                                     timestamp:self.timestamp];
}

- (void)resetRecipientStateMapWithThread:(TSThread *)thread {
    // New outgoing messages should immediately determine their
    // recipient list from current thread state.
    NSMutableDictionary<NSString *, TSOutgoingMessageRecipientState *> *recipientStateMap = [NSMutableDictionary new];
    NSArray<NSString *> *recipientIds;
    if ([self isKindOfClass:[OWSOutgoingSyncMessage class]]) {
        NSString *_Nullable localNumber = [TSAccountManager localNumber];
        OWSAssertDebug(localNumber);
        recipientIds = @[
            localNumber,
        ];
    } else {
        recipientIds = [thread recipientIdentifiers];
    }
    for (NSString *recipientId in recipientIds) {
        TSOutgoingMessageRecipientState *recipientState = [TSOutgoingMessageRecipientState new];
        recipientState.state = OWSOutgoingMessageRecipientStateSending;
        recipientStateMap[recipientId] = recipientState;
    }
    self.recipientStateMap = [recipientStateMap copy];
}

@end

NS_ASSUME_NONNULL_END
