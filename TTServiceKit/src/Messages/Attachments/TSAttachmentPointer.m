//
//  Copyright (c) 2018 Open Whisper Systems. All rights reserved.
//

#import "TSAttachmentPointer.h"
#import "MIMETypeUtil.h"
#import "TSMessage.h"
#import <TTServiceKit/TTServiceKit-Swift.h>

NS_ASSUME_NONNULL_BEGIN

@implementation TSAttachmentPointer

- (nullable instancetype)initWithCoder:(NSCoder *)coder
{
    self = [super initWithCoder:coder];
    if (!self) {
        return self;
    }

    // A TSAttachmentPointer is a yet-to-be-downloaded attachment.
    // If this is an old TSAttachmentPointer from another session,
    // we know that it failed to complete before the session completed.
    if (![coder containsValueForKey:@"state"]) {
        _state = TSAttachmentPointerStateFailed;
    }

    return self;
}

// --- CODE GENERATION MARKER

// This snippet is generated by /Scripts/sds_codegen/sds_generate.py. Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// clang-format off

- (instancetype)initWithGrdbId:(int64_t)grdbId
                      uniqueId:(NSString *)uniqueId
                         albumId:(nullable NSString *)albumId
                  albumMessageId:(nullable NSString *)albumMessageId
            appearInMediaGallery:(BOOL)appearInMediaGallery
         attachmentSchemaVersion:(NSUInteger)attachmentSchemaVersion
                  attachmentType:(TSAttachmentType)attachmentType
                       byteCount:(unsigned int)byteCount
                     contentType:(NSString *)contentType
                   encryptionKey:(NSData *)encryptionKey
                    isDownloaded:(BOOL)isDownloaded
                        serverId:(unsigned long long)serverId
                  sourceFilename:(nullable NSString *)sourceFilename
                          digest:(nullable NSData *)digest
  mostRecentFailureLocalizedText:(nullable NSString *)mostRecentFailureLocalizedText
                           relay:(NSString *)relay
                           state:(TSAttachmentPointerState)state
{
    self = [super initWithGrdbId:grdbId
                        uniqueId:uniqueId
                           albumId:albumId
                    albumMessageId:albumMessageId
              appearInMediaGallery:appearInMediaGallery
           attachmentSchemaVersion:attachmentSchemaVersion
                    attachmentType:attachmentType
                         byteCount:byteCount
                       contentType:contentType
                     encryptionKey:encryptionKey
                      isDownloaded:isDownloaded
                          serverId:serverId
                    sourceFilename:sourceFilename];

    if (!self) {
        return self;
    }

    _digest = digest;
    _mostRecentFailureLocalizedText = mostRecentFailureLocalizedText;
    _relay = relay;
    _state = state;

    return self;
}

// clang-format on

// --- CODE GENERATION MARKER

- (instancetype)initWithServerId:(UInt64)serverId
                             key:(NSData *)key
                          digest:(nullable NSData *)digest
                       byteCount:(UInt32)byteCount
                     contentType:(NSString *)contentType
                           relay:(NSString *)relay
                  sourceFilename:(nullable NSString *)sourceFilename
                  attachmentType:(TSAttachmentType)attachmentType
                  albumMessageId:(nullable NSString *)albumMessageId
                         albumId:(nullable NSString *)albumId
{
    self = [super initWithServerId:serverId
                     encryptionKey:key
                         byteCount:byteCount
                       contentType:contentType
                    sourceFilename:sourceFilename
                    albumMessageId:albumMessageId
                           albumId:albumId];
    if (!self) {
        return self;
    }

    _digest = digest;
    _state = TSAttachmentPointerStateEnqueued;
    _relay = relay;
    self.attachmentType = attachmentType;

    return self;
}


+ (TSAttachmentPointer *)attachmentPointerFromProto:(DSKProtoAttachmentPointer *)attachmentProto
                                              relay:(nullable NSString *)relay
                                     albumMessageId:(nullable NSString *)albumMessageId
                                            albumId:(nullable NSString *)albumId
{
    OWSAssertDebug(attachmentProto.id != 0);
    OWSAssertDebug(attachmentProto.key != nil);
    OWSAssertDebug(attachmentProto.contentType != nil);

    // digest will be empty for old clients.
    NSData *digest = attachmentProto.hasDigest ? attachmentProto.digest : nil;

    TSAttachmentType attachmentType = TSAttachmentTypeDefault;
    if ([MIMETypeUtil isVoiceMessage:attachmentProto]) {
        attachmentType = TSAttachmentTypeVoiceMessage;
    }
    
    albumMessageId = albumMessageId;

    TSAttachmentPointer *pointer = [[TSAttachmentPointer alloc] initWithServerId:attachmentProto.id
                                                                             key:attachmentProto.key
                                                                          digest:digest
                                                                       byteCount:attachmentProto.size
                                                                     contentType:attachmentProto.contentType
                                                                           relay:relay
                                                                  sourceFilename:attachmentProto.fileName
                                                                  attachmentType:attachmentType
                                                                  albumMessageId:albumMessageId
                                                                         albumId:albumId];
    return pointer;
}

+ (NSArray<TSAttachmentPointer *> *)attachmentPointersFromProtos:(NSArray<DSKProtoAttachmentPointer *> *)attachmentProtos
                                                           relay:(nullable NSString *)relay
                                                  albumMessageId:(nullable NSString *)albumMessageId
                                                         albumId:(nullable NSString *)albumId {
    NSMutableArray<TSAttachmentPointer *> *attachmentPointers = [NSMutableArray new];

    for (DSKProtoAttachmentPointer *attachmentProto in attachmentProtos) {
        TSAttachmentPointer *pointer = [TSAttachmentPointer attachmentPointerFromProto:attachmentProto relay:relay albumMessageId:albumMessageId albumId:albumId];

        [attachmentPointers addObject:pointer];
    }
    
    return attachmentPointers;
}


- (BOOL)isDecimalNumberText:(NSString *)text
{
    return [text componentsSeparatedByCharactersInSet:[NSCharacterSet decimalDigitCharacterSet]].count == 1;
}

- (void)upgradeFromAttachmentSchemaVersion:(NSUInteger)attachmentSchemaVersion
{
    // Legacy instances of TSAttachmentPointer apparently used the serverId as their
    // uniqueId.
    if (attachmentSchemaVersion < 2 && self.serverId == 0) {
        OWSAssertDebug([self isDecimalNumberText:self.uniqueId]);
        if ([self isDecimalNumberText:self.uniqueId]) {
            // For legacy instances, try to parse the serverId from the uniqueId.
            self.serverId = [self.uniqueId integerValue];
        } else {
            DDLogError(@"%@ invalid legacy attachment uniqueId: %@.", self.logTag, self.uniqueId);
        }
    }
}

- (nullable DSKProtoAttachmentPointer *)buildProto
{
    DSKProtoAttachmentPointerBuilder *builder = [DSKProtoAttachmentPointer builder];

    builder.id = self.serverId;

    OWSAssertDebug(self.contentType.length > 0);
    builder.contentType = self.contentType;

    OWSLogVerbose(@"%@ Sending attachment with filename: '%@'", self.logTag, self.sourceFilename);
    builder.fileName = self.sourceFilename;

    builder.size = self.byteCount;
    builder.key = self.encryptionKey;
    builder.digest = self.digest;
    builder.flags = self.isVoiceMessage ? DSKProtoAttachmentPointerFlagsVoiceMessage : 0;

    return [builder buildAndReturnError:nil];
}

- (void)updateAfterFileCheckWithServerId:(UInt64)serverId transaction:(SDSAnyWriteTransaction *)transaction
{
    [self anyUpdateWithTransaction:transaction block:^(TSAttachment * _Nonnull instance) {
        instance.serverId = serverId;
    }];
}

@end

NS_ASSUME_NONNULL_END
