//
//  Copyright (c) 2022 Open Whisper Systems. All rights reserved.
//

import Foundation
import GRDB
import SignalCoreKit

// NOTE: This file is generated by /Scripts/sds_codegen/sds_generate.py.
// Do not manually edit it, instead run `sds_codegen.sh`. Please contact Kris for support.

// MARK: - Typed Convenience Methods

@objc
public extension TSAttachmentStream {
    // NOTE: This method will fail if the object has unexpected type.
    class func anyFetchAttachmentStream(
        uniqueId: String,
        transaction: SDSAnyReadTransaction
    ) -> TSAttachmentStream? {
        assert(uniqueId.count > 0)

        guard let object = anyFetch(uniqueId: uniqueId,
                                    transaction: transaction) else {
                                        return nil
        }
        guard let instance = object as? TSAttachmentStream else {
            owsFailDebug("Object has unexpected type: \(type(of: object))")
            return nil
        }
        return instance
    }

    // NOTE: This method will fail if the object has unexpected type.
    func anyUpdateAttachmentStream(transaction: SDSAnyWriteTransaction, block: (TSAttachmentStream) -> Void) {
        anyUpdate(transaction: transaction) { (object) in
            guard let instance = object as? TSAttachmentStream else {
                owsFailDebug("Object has unexpected type: \(type(of: object))")
                return
            }
            block(instance)
        }
    }
}

// MARK: - SDSSerializer

// The SDSSerializer protocol specifies how to insert and update the
// row that corresponds to this model.
class TSAttachmentStreamSerializer: SDSSerializer {

    private let model: TSAttachmentStream
    public required init(model: TSAttachmentStream) {
        self.model = model
    }

    // MARK: - Record

    func asRecord() throws -> SDSRecord {
        let id: Int64? = model.grdbId?.int64Value

        let recordType: SDSRecordType = .attachmentStream
        let uniqueId: String = model.uniqueId

        // Properties
        let attachmentSchemaVersion: UInt = model.attachmentSchemaVersion
        let attachmentType: TSAttachmentType = model.attachmentType
        let byteCount: UInt32 = model.byteCount
        let cachedAudioDurationSeconds: UInt64? = archiveOptionalNSNumber(model.cachedAudioDurationSeconds, conversion: { $0.uint64Value })
        let cachedImageHeight: UInt64? = archiveOptionalNSNumber(model.cachedImageHeight, conversion: { $0.uint64Value })
        let cachedImageWidth: UInt64? = archiveOptionalNSNumber(model.cachedImageWidth, conversion: { $0.uint64Value })
        let contentType: String = model.contentType
        let creationTimestamp: Double? = archiveOptionalDate(model.creationTimestamp)
        let digest: Data? = model.digest
        let encryptedDatalength: Int? = model.encryptedDatalength
        let encryptionKey: Data = model.encryptionKey
        let isDownloaded: Bool = model.isDownloaded
        let isUploaded: Bool? = model.isUploaded
        let lazyRestoreFragmentId: String? = model.lazyRestoreFragmentId
        let localRelativeFilePath: String? = model.localRelativeFilePath
        let mostRecentFailureLocalizedText: String? = nil
        let relay: String? = nil
        let serverAttachmentId: String? = model.serverAttachmentId
        let serverId: UInt64 = model.serverId
        let sourceFilename: String? = model.sourceFilename
        let state: TSAttachmentPointerState? = nil
        let albumId: String? = model.albumId
        let albumMessageId: String? = model.albumMessageId
        let appearInMediaGallery: Bool = model.appearInMediaGallery
        let decibelSamples: Data? = optionalArchive(model.decibelSamples)

        return AttachmentRecord(delegate: model, id: id, recordType: recordType, uniqueId: uniqueId, attachmentSchemaVersion: attachmentSchemaVersion, attachmentType: attachmentType, byteCount: byteCount, cachedAudioDurationSeconds: cachedAudioDurationSeconds, cachedImageHeight: cachedImageHeight, cachedImageWidth: cachedImageWidth, contentType: contentType, creationTimestamp: creationTimestamp, digest: digest, encryptedDatalength: encryptedDatalength, encryptionKey: encryptionKey, isDownloaded: isDownloaded, isUploaded: isUploaded, lazyRestoreFragmentId: lazyRestoreFragmentId, localRelativeFilePath: localRelativeFilePath, mostRecentFailureLocalizedText: mostRecentFailureLocalizedText, relay: relay, serverAttachmentId: serverAttachmentId, serverId: serverId, sourceFilename: sourceFilename, state: state, albumId: albumId, albumMessageId: albumMessageId, appearInMediaGallery: appearInMediaGallery, decibelSamples: decibelSamples)
    }
}
                                                                                 